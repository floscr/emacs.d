#+TITLE: Doom Emacs configuration
#+AUTHOR: floscr
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: org-startup-folded: showall
#+DISABLE_SPELLCHECKER: t
#+TODO: TODO(t) ACTIVE(a) | INACTIVE(i) DISABLED(d)

* Docs
** Code style

Most of the code here will follow a functional mindset using [[https://github.com/magnars/dash.el][dash.el]] and [[https://github.com/magnars/s.el][s.el]].
I will prefer those functions over built in functions if they are nicer to use.

I often use my helper function [[*Template Literals][(t!)]] for template strings.

** Variable Naming

All my private functions have the prefix ~my~.
It's the only prefix where you can assume that packages/emacs/doom won't override it and vice-versa.

*** Schema

- ~my::namespace~
  Its not pretty, but it's the only way to work with emacs-lisps global scope for everything.
  - ~my::namespace::sub-namespace~
- ~my:variable~: Variable
- ~my/function~: Private function
  - ~my::namespace/function~: Private function with namespace
- ~my|function~: Interactive function
  - ~my::namespace|function~: Interactive function
- ~my@function~: Macro
- ~my*hook~: Hook function

*** Exceptions

There are only a few exceptions, which I'm keeping without the prefix for ease of writing/reading:

- [[*Dash Extensions][Dash Extensions]]
  Prefixed with a ~-~
- [[*Template Literals][Template Literals]]
  ~template~ or ~t~ macros

* Setup
** Tangle Headers

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "init.el" :comments no
;; -*- no-byte-compile: t; -*-
#+END_SRC
** Required Packages

Packages and utilities needed for this config.

- [[https://github.com/magnars/dash.el][magnars/dash.el: List Manipulation]]
- [[https://github.com/magnars/s.el][magnars/s.el: String Manipulation]]

#+BEGIN_SRC elisp
(require 'dash)
(require 's)
(require 'f)
(require 'noflet)
#+END_SRC

#+BEGIN_SRC elisp :tangle "autoload.el" :comments link
(require 'dash)
(require 's)
(require 'f)
(require 'noflet)
#+END_SRC

* My Standard Library
:PROPERTIES:
:header-args: :tangle "autoload.el" :comments link
:END:

Macros & Functions that extend my elisp standard library.
If you copy any of my emacs-lisp code, you will need these functions.

Tangles to [[file:autoload.el][autoload.el]]

** Macros
*** Template Literals
:PROPERTIES:
:SOURCE:   https://gist.github.com/cbowdon/012d623920bd28453bf8
:END:

#+BEGIN_SRC elisp :tangle no
(template "2 = <<(+ 1 1)>>")
#+END_SRC

#+RESULTS:
: 2 = 2

#+BEGIN_SRC elisp
;;;###autoload
(defmacro template (text)
  "Template literals"
  (let ((pattern "<<\\(.*?\\)>>"))
    ;; The regexp matches anything between delimiters, non-greedily
    (with-temp-buffer
      (save-excursion (insert text))
      (let ((matches '()))
        (while (re-search-forward pattern nil t)
          (push (match-string 1) matches)
          (replace-match "%s" t t))
        `(format ,(buffer-string) ,@(reverse (mapcar 'read matches)))))))

;;;###autoload
(defalias 't! 'template)
#+END_SRC

*** Ignore Arguments
:PROPERTIES:
:SOURCE:   https://emacs.stackexchange.com/a/33063
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defmacro my@ignore-args (fn)
  "Return function that ignores its arguments and invokes FN."
  `(lambda (&rest _rest)
     (funcall ,fn)))
#+END_SRC

** General
*** Noop

#+BEGIN_SRC elisp
;;;###autoload
(defun my/noop (&optional args) nil)
#+END_SRC

*** Without undo

#+BEGIN_SRC elisp
;;;###autoload
(defmacro my/without-undo (&rest forms)
  "Executes FORMS with a temporary buffer-undo-list that is discarded afterwards.
Taken from http://www.emacswiki.org/emacs/UndoCommands with some
modifications."
  `(let* ((buffer-undo-list)
          (modified (buffer-modified-p))
          (inhibit-read-only t))
     (unwind-protect
         (progn ,@forms)
       (set-buffer-modified-p modified)) ()))
#+END_SRC
*** INACTIVE String match or original

#+BEGIN_SRC elisp :tangle no
;;;###autoload
(defun my/s-match-or (regex x)
  "Return match groups or original"
  (interactive)
  (-if-let ((match (s-match regex x)))
      (cdr match)
    (list x)))

;;;###autoload
(defun my/s-match-or-1 (regex x)
  "Return 1st match group or original."
  (interactive)
  (-if-let ((match (s-match regex x)))
      (car (cdr match))
    x))
#+END_SRC
** Buffer
*** Check if buffer has line

#+BEGIN_SRC elisp
(defun my::buffer/contains-line (string)
  (save-excursion
    (save-match-data
      (goto-char (point-min))
      (search-forward string nil t))))
#+END_SRC

*** Get current line indentation

#+BEGIN_SRC elisp
;;;###autoload
(defun my::buffer/line-indent ()
  "Get the indent of the current line."
  (interactive)
  (or (-some->> (substring-no-properties (thing-at-point 'line))
        (s-match "^\\(\s*\\).*\n$")
        (nth 1)
        (length))
      0))
#+END_SRC

*** Check current line for regex

#+BEGIN_SRC elisp
;;;###autoload
(defun my::buffer/line-contains (regexp)
  "Check for REGEXP at current line."
  (save-excursion
    (goto-char (point-at-bol))
    (search-forward-regexp regexp (point-at-eol) t)))
#+END_SRC

*** Delete current line

#+BEGIN_SRC elisp
;;;###autoload
(defun my::buffer/delete-current-line ()
  "Delete (not kill) the current line."
  (interactive)
  (save-excursion
    (delete-region
     (progn (forward-visible-line 0) (point))
     (progn (forward-visible-line 1) (point)))))
#+END_SRC

*** INACTIVE Map buffer lines

#+BEGIN_SRC elisp :tangle no
;;;###autoload
(defun my::buffer/map-lines (fun &optional start end)
  "Map lines in buffer with FUN, fn gets called with the line contents."
  (let ((start (or start (point-min)))
        (end (or end (point-max)))
        (lines (list)))
    (save-excursion
      (goto-char start)
      (while (< (point) end)
        (add-to-list 'lines
          (funcall fun (buffer-substring (line-beginning-position) (line-end-position))))
        (forward-line 1))
      (erase-buffer)
      (->> lines
           reverse
           (s-join "\n")
           insert))))
#+END_SRC
** Shell Commands & Aliases
*** Async Command No Window
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/a/47910509/2298462][How to avoid pop-up of *Async Shell Command* buffer in Emacs?]]
:END:

Prevent ~async-shell-command~ displaying a popup or a buffer.

#+BEGIN_SRC elisp
(defun my::shell/async-command-no-window (command)
  "Execute async command without showing the result buffer."
  (interactive)
  (let ((display-buffer-alist (list (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))))
    (async-shell-command command)))
#+END_SRC

*** Shell command to list

#+BEGIN_SRC elisp
(defun my::shell/command-to-list (cmd)
  "Split output from shell-command to list"
  (split-string (shell-command-to-string cmd) "\n" t))
#+END_SRC

*** Start process that stays alive

I don't want some processes to exit, when I close emacs.

#+BEGIN_SRC elisp
;;;###autoload
(defun my::shell/no-exit-command (cmd &optional &rest args)
  "Launch a shell command, without opening a message buffer.
The proram persists when emacs is closed."
  (let ((args-str (or (-some->> args
                        (s-join " "))
                      "")))
    (call-process-shell-command
       (template "nohup 1>/dev/null 2>/dev/null <<cmd>> <<args-str>> &") nil nil)))
#+END_SRC

*** Open youtube link with MPV

#+BEGIN_SRC elisp
;;;###autoload
(defun my::shell/mpv-youtube-url (url)
  (-when-let* ((quality-val
                (-some->> (completing-read
                            "Max height resolution (0 for unlimited): "
                            '("720" "0" "480" "1080"))
                  (string-to-number)))
               (quality-arg (if (> 0 quality-val)
                                (template "--ytdl-format=\"[height<=?<<quality-val>>]\"")
                              "")))
    (message (template "Opening <<url>> at <<quality-val>> with mpv…"))
    (my::shell/no-exit-command "mpv" quality-arg (s-wrap url "\""))))
#+END_SRC
** Files
*** Get file timestamp

#+BEGIN_SRC elisp
;;;###autoload
(defun my::file/timestamp (path)
  (->> (file-attributes path)
       (nth 5)))
#+END_SRC

*** Get the last modified file in directory
:PROPERTIES:
:SOURCE:   https://stackoverflow.com/a/30886283
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defun my::file/last-modified-file-in-dir (path)
  (->> (f-entries path)
       (-sort (lambda (a b) (not (time-less-p (my::file/timestamp a)
                                              (my::file/timestamp b)))))
       (car)))
#+END_SRC

*** Chmod current file

#+BEGIN_SRC elisp
;;;###autoload
(defun my::file|chmod-this-file ()
  "Chmod +x the current file."
  (interactive)
  (shell-command (template "chmod +x \"<<(buffer-file-name)>>\"")))
#+END_SRC
*** Dir has hidden entry

#+BEGIN_SRC elisp
(defun my::file/dir-has-hidden-entries (dir)
  "Check if a DIR has any hidden entries.
Return the first found file when one is found."
  (--find (s-starts-with-p "." (f-filename it)) (f-entries dir)))
#+END_SRC

*** Find project root

#+BEGIN_SRC elisp
(defun my::file/project-root ()
  "Find the project root either via projectile (not available in certain buffers like dired)
or manually traverse upwards until the .git directory is found."
  (interactive)
  (or
   projectile-project-root
   (f--traverse-upwards (f-exists? (f-expand ".git" it)))))

(cl-defun my::file/git-root (&optional (skip-worktree? t))
  (let ((checker-fn (if skip-worktree? #'f-dir? #'f-exists?)))
    (f--traverse-upwards (funcall checker-fn (f-expand ".git" it)))))
#+END_SRC

** Debugging / Logging
*** Kill and Message

#+BEGIN_SRC elisp
;;;###autoload
(defun my/kill-and-message (x)
  "Executes kill-new but with a message log side effect."
  (kill-new x)
  (message "Copied to clipboard: %s" x))
#+END_SRC

*** Convert boolean to enabled/disabled string

#+BEGIN_SRC elisp
(defun my/bool-to-enabled-string (x)
  "Convert bool X to string for messaging.
t   -> \"Enabled\")
nil -> \"Disabled\""
  (if x "Enabled" "Disabled"))
#+END_SRC

*** Variable t/nil toggle message

#+BEGIN_SRC elisp
(defun my/bool-state-message (x)
  "Log message if a bool is enabled or not"
  (interactive)
  (message (t! "<<(symbol-name x)>>: <<(my/bool-to-enabled-string (symbol-value x))>>")))
#+END_SRC

** Dash Extensions
*** -tap

Run a side effect ~fn~ on the initial input ~x~.
But Return the original input ~x~.

#+BEGIN_SRC elisp
;;;###autoload
(defun -tap (fn x)
  "Function docstring"
  (funcall fn x)
  x)

;;;###autoload
(defmacro --tap (fn it)
  "Anaphoric form of `-tap'."
  `(-tap (lambda (it) ,fn) ,it))
#+END_SRC

*** -log

Log the current input without breaking the pipe.

#+BEGIN_SRC elisp
;;;###autoload
(defun -log (x)
  "Function docstring"
  (--tap (message "%s" it) x))
#+END_SRC

*** -when

#+BEGIN_SRC elisp
;;;###autoload
(defun -when (pred fn x)
  "When FN equals t forward X."
  (if pred
      (funcall fn x)
    x))

;;;###autoload
(defmacro --when (pred form xs)
  "Anaphoric form of -id-when"
  (declare (debug (form form)))
  `(let ((it ,xs))
     (if ,pred
         ,form
       ,xs)))
#+END_SRC

*** -id-when

#+BEGIN_SRC elisp
;;;###autoload
(defun -id-when (fn x)
  "When FN equals t forward X."
  (when (funcall fn x) x))

;;;###autoload
(defmacro --id-when (form xs)
  "Anaphoric form of -id-when"
  (declare (debug (form form)))
  `(let ((it ,xs))
     (when ,form ,xs)))
#+END_SRC

*** -append

#+BEGIN_SRC elisp
;;;###autoload
(defun -append (elem list)
  "Append ELEM to the end of list.

This is like -snoc but it takes the ELEM as the first argument for easier composition"
  (-snoc list elem))
#+END_SRC

*** -shuffle
:PROPERTIES:
:SOURCE:   [[http://kitchingroup.cheme.cmu.edu/blog/2014/09/06/Randomize-a-list-in-Emacs/][Randomize a list in Emacs]]
:END:

#+BEGIN_SRC elisp
(defun swap-list-items (LIST el1 el2)
  "in LIST swap indices EL1 and EL2 in place"
  (let ((tmp (elt LIST el1)))
    (setf (elt LIST el1) (elt LIST el2))
    (setf (elt LIST el2) tmp)))

;;;###autoload
(defun -shuffle (LIST)
  "Shuffle the elements in LIST.
shuffling is done in place."
  (loop for i in (reverse (number-sequence 1 (1- (length LIST))))
        do (let ((j (random (+ i 1))))
             (swap-list-items LIST i j)))
  LIST)
#+END_SRC

*** -f-join

#+BEGIN_SRC elisp
;;;###autoload
(defun -f-join (x path)
  "Reversed argument order for f-join"
  (f-join path x))
#+END_SRC

*** -f-tildify

#+BEGIN_SRC elisp
;;;###autoload
(defun f-tildify (path)
  "Replace the HOME directory in path"
  (s-replace-regexp (t! "^<<(getenv \"HOME\")>>") "~" path))
#+END_SRC
*** plist

#+begin_src elisp
(defun -plist-get (plist prop)
  (plist-get prop plist))
#+end_src

** Tangling

#+begin_src elisp
(defvar my::config:literate-config-file
  (concat doom-private-dir "config.org")
  "The file path of your literate config file.")

(defvar my::config:literate-config-file-cache
  (concat doom-cache-dir "literate-last-compile")
  "The file path that `my::config:literate-config-file' will be tangled to, then
byte-compiled from.")

;;;###autoload
(defun my::config/tangle-literate-config (&optional force-p file)
  "Tangles the current buffer FILE if it has changed."
  (let* ((default-directory doom-private-dir)
         (src-file (expand-file-name (or file buffer-file-name)))
         (dst-file (concat (file-name-sans-extension src-file) ".el")))
    (when (or (file-newer-than-file-p src-file
                                      dst-file)
              force-p)
      (message "Compiling your literate config...")
      (start-process
       "org-tangle" nil "emacs"
       "-q" "--batch"
       "-l" "ob-tangle"
       "--eval" (format "(org-babel-tangle-file %S %S)"
                        src-file dst-file)))))

;;;###autoload
(defalias 'my::config/reload-litarate-config-file #'doom/reload)

;;;###autoload
(defun my::config/recompile-literate-config-maybe ()
  "Recompile config.org if we're editing an org file in our DOOMDIR.

We assume any org file in `doom-private-dir' is connected to your literate
config, and should trigger a recompile if changed."
  (when (and (eq major-mode 'org-mode)
             (file-in-directory-p buffer-file-name doom-private-dir))
    (my::config/tangle-literate-config 'force)))

;; Recompile our literate config if we modify it
;;;###autoload
(after! org (add-hook 'after-save-hook #'my::config/recompile-literate-config-maybe))

;;;###autoload
(defun my::config|tangle ()
  "Tangle the current org buffer."
  (interactive)
  (my::config/tangle-literate-config t))
#+end_src

* Custom Packages
** TODO Jumpy - Custom Bookmarks

*** Config
**** Disable Emacs bookmarks

#+BEGIN_SRC elisp
(setq bookmark-save-flag nil)

;; Can't set to nil as bookmarks are still set up to hooks
;; Instead I'll keep it in this file which will be trashed on every reboot
(setq bookmark-file "/tmp/emacs-bookmarks-file")
#+END_SRC
**** Main Bookmarks

#+begin_src elisp
(setq
 my::jumpy:main
 '(((file . "~/.config/doom/modules/private/work/config.org")
    (name . "Config: Work")
    (goto . "* Configuration")
    (goto-bol . t)
    (disable-relocation . t))
   ((file . "~/.config/dotfiles/config/xmonad/xmonad.hs")
    (name . "Xmonad"))
   ((file . "~/.config/doom/autoload.org")
    (name . "Config: Autoloads"))
   ((file . "~/.config/doom/modules/private/org/config.org")
    (name . "Config: Org"))
   ((fn . (lambda () (find-file my::jumpy:local-bookmarks-file)))
    (name . "Bookmarks: Local"))
   ((file . "~/.config/doom/config.org")
    (name . "Bookmarks: Main")
    (goto . "*** Main Bookmarks")
    (goto-bol . t))
   ((fn . (lambda () (find-file (getenv "HISTFILE"))))
    (name . "Shell History")
    (goto-bol . t))
   ((file . "~/.config/doom/modules/private/work/config.org")
    (name . "Bookmarks: Work")
    (goto . "*** Bookmarks")
    (goto-bol . t))
   ((file . "/etc/dotfiles/modules/desktop/common.nix")
    (name . "Mimeapps")
    (goto . "### Mimeapps")
    (goto-bol . t))
   ((file . "~/.config/weechat/xfer")
    (name . "Weechat Xfer"))
   ((file . "/run/media/floscr/tolino")
    (name . "Tolino"))
   ((org . "[[orgit:/ssh:mm-web-vagrant:/home/vagrant/mindmeister/][/ssh:mm-web-vagrant:/home/vagrant/mindmeister/ (magit-status)]]")
    (name . "Vagrant: mindmeister magit status"))
   ((org . "[[orgit:/ssh:mm-web-vagrant:/home/vagrant/mindmeister-web/][/ssh:mm-web-vagrant:/home/vagrant/mindmeister-web/ (magit-status)]]")
    (name . "Vagrant: mindmeister-web magit status"))
   ((file . "~/Media/Scans/Scans.org")
    (name . "Scans"))
   ((fn . org-capture-goto-last-stored)
    (name . "Capture: Last Stored Marker"))))
#+end_src
*** Functions

#+BEGIN_SRC elisp
(defun my::jumpy|main ()
  (interactive)
  (my::jumpy|launch (-concat my::jumpy:main (my::jumpy/local-list))))
#+END_SRC

Bookmarks for projects with using a [[file:bookmarks.json][bookmarks.json]] file at the project root.

#+BEGIN_SRC elisp
(defvar my::jumpy:local-bookmarks-file nil)
(setq my::jumpy:local-bookmarks-file (f-join doom-local-dir "bookmarks.json"))

(defun my::jumpy/goto-bookmark-dwim (x &optional &key other-window?)
  "Jump to a X relative to the project root, go to character POS."
  (require 'link-hint)
  (-when-let* ((find-fn (if other-window? 'find-file-other-window 'find-file))
               (item (car x)))
    (let* ((file (-some->> (alist-get 'file item)
                   (--when (alist-get 'relative item)
                           (f-join (my::file/project-root) it))))
           (buffer-is-open (when file (get-file-buffer file))))
      (when file
        (funcall find-fn file)
        (+workspaces-add-current-buffer-h))
      (when-let ((fn (alist-get 'fn item)))
        (funcall fn))

      ;; org item
      (-some--> (alist-get 'org item)
        (link-hint--open-org-link it)
        ((lambda ()
           (when (alist-get 'narrow item)
             (org-narrow-to-element)))))

      ;; goto, disable-relocation
      ;; Go to a location matched by regex
      ;; Unless disable-relocation is enabled and the file is already visited
      (-some--> (alist-get 'goto item)
        (--id-when (or (not buffer-is-open)
                       (not (alist-get 'disable-relocation item))) it)
        (--tap (progn
                 (goto-char (point-min))
                 (cond
                  ((eq 'integer (type-of it))
                   (goto-line it))
                  ((eq 'string (type-of it))
                   (search-forward it))))
               it))
      ;; action
      ;; Execute a function after find file
      (-some--> (alist-get 'action item)
        (call-interactively it))
      ;; goto-bol
      ;; Go to the beginning, since the regex search
      ;; will leave the cursor at the end of the search
      (-some--> (alist-get 'goto-bol item)
        (evil-first-non-blank)))))

(cl-defun my::jumpy/local-list (&optional file my::jumpy:local-bookmarks-file)
  (-some->> file
    (-id-when #'f-exists?)
    (json-read-file)
    (-map 'identity)))

(cl-defun my::jumpy/local-save (xs &optional (file my::jumpy:local-bookmarks-file))
  "Save an alist as json to the file"
  (let ((json (with-temp-buffer
                (insert (json-encode xs))
                (json-pretty-print (point-min) (point-max))
                (buffer-substring-no-properties (point-min) (point-max)))))
       (f-write json 'utf-8 file)))

(cl-defun my::jumpy/local-remove (x &optional (file my::jumpy:local-bookmarks-file))
  (->>
   (--remove (cl-equalp (car (cdr x)) it) (my::jumpy/local-list))
   ((lambda (xs) (my::jumpy/local-save xs file)))))

(cl-defun my::jumpy/local-rename (x &optional (file my::jumpy:local-bookmarks-file))
  (require 'a)
  (-log x)
  (-let ((item (car (cdr x))))
    (-log (a-get (cdr item) :name))
    (->>
     (my::jumpy/local-list file)
     (--map-first (cl-equalp item it) (a-update it 'name (lambda (x) (read-string "Rename Bookmark: " x))))
     ((lambda (xs) (my::jumpy/local-save xs file))))))

(cl-defun my::jumpy|local-save (&optional (file my::jumpy:local-bookmarks-file))
  (interactive)
  (let ((entry `((file . ,(buffer-file-name))
                 (goto . ,(line-number-at-pos))
                 (name . ,(read-string "Bookmark Name: ")))))
    (->> (my::jumpy/local-list file)
      (-append entry)
      ((lambda (xs) (my::jumpy/local-save xs file))))))

(defun my::jumpy/goto-bookmark-dwim-other-window (x)
  "Open bookmark X in other window, used with ivy action 'j'."
  (my::jumpy/goto-bookmark-dwim (cdr x) :other-window? t))

(defun my::jumpy::project/file-path ()
  (f-join (my::file/git-root) "bookmarks.json"))

(defun my::jumpy::project|save ()
  (interactive)
  (let ((file (my::jumpy::project/file-path))
        (entry `((file . ,(buffer-file-name))
                 (goto . ,(line-number-at-pos))
                 (name . ,(read-string "Bookmark Name: ")))))
    (->> (my::jumpy/local-list file)
      (-append entry)
      ((lambda (xs) (my::jumpy/local-save xs file))))))

(defun my::jumpy::project|launch ()
  (interactive)
  (my::jumpy|launch (my::jumpy/local-list (my::jumpy::project/file-path)) #'my::jumpy::project|launch))

;;;###autoload
(cl-defun my::jumpy|launch (&optional bookmarks-list (caller #'my::jumpy|launch))
  "Either take alist BOOKMARKS-LIST or look for bookmarks.json in project root.
If found, show an ivy window with the bookmarks"
  (interactive)
  (-if-let*
      ((bookmarks
        (or bookmarks-list
            (my::jumpy/local-list)))
       (bookmarks (--map (list (alist-get 'name it) it) bookmarks)))
      (ivy-read "Bookmark: " bookmarks
                :action (lambda (x) (my::jumpy/goto-bookmark-dwim (cdr x)))
                :caller caller)
    (user-error "No bookmarks file found.")))

(after! ivy
  (ivy-set-actions
   'my::jumpy|launch
   '(("j" my::jumpy/goto-bookmark-dwim-other-window "open in other window")
     ("k" my::jumpy/local-remove "Remove")
     ("r" my::jumpy/local-rename "Rename"))))

(after! ivy
  (ivy-set-actions
   'my::jumpy::project|launch
   '(("j" my::jumpy/goto-bookmark-dwim-other-window "open in other window")
     ("k" (lambda (x) (my::jumpy/local-remove x (my::jumpy::project/file-path))) "Remove")
     ("r" (lambda (x) (my::jumpy/local-rename x (my::jumpy::project/file-path))) "Rename"))))
#+END_SRC
*** Bindings

#+begin_src elisp
(map!
 :leader
 (:prefix-map ("j" . "jumpy")
  :desc "Project"  "j" #'my::jumpy|main
  :desc "Project"  "p" #'my::jumpy::project|launch))
#+end_src

** TODO LY: Evil Lisp Navigation

A navigation system for lisp languages that I'm comfortable with,
like evil but with a more =sexp= based navigation.

Alternatives I've used:

- [[https://github.com/countvajhula/symex.el][countvajhula/symex.el]]
  My main inspiration.
  Too tree based for my taste, I after have to think about the code structure before I can execute actions.

*** Minor Mode

#+BEGIN_SRC elisp
(set-frame-parameter nil 'internal-border-width 15)
(defvar +ly-mode-map (make-sparse-keymap))

(define-minor-mode +ly-mode
  "Open org headlines in an indirect window buffer."
  :keymap +ly-mode-map)

(map! :map +ly-mode-map
      :n "gj"     #'evil-next-line
      :n "gk"     #'evil-previous-line
      :n "M-j"    #'+ly|forward-line
      :n "M-k"    #'+ly|backward-line
      :n "M-u"    #'+ly|up-atom
      :n "M-f"    #'+ly|forward-atom
      :n "M-b"    #'+ly|backward-atom
      :n "M-l"    #'+ly|forward-brace
      :n "M-h"    #'+ly|backward-brace
      :n "M-,"    #' symex-shift-backward
      :n "M-."    #'symex-shift-forward
      :n "M-o"    #'symex-open-line-after
      :ni "<C-return>" #'+ly|add-atom
      :n "M-RET" (cmd!
                  (parinfer-toggle-mode)
                  (parinfer-lispy:newline)
                  (parinfer-toggle-mode))
      :n "M-Y" (cmd!
                (symex-yank)
                (symex-paste-after)
                (symex-insert-newline)))

;; HACK: map not working intially
(defun +ly/activate-mode-hook ()
  (require 'symex)
  (evil-insert-state)
  (evil-normal-state))

;; Mappings only get applied after reinserting normal mode
(add-hook '+ly-mode-hook #'+ly/activate-mode-hook)
#+END_SRC

*** Utils
**** Sexp Navigation

#+BEGIN_SRC elisp
(setq +ly:brace-regexp "([^() ]")
(setq +ly:atom-regexp "[^() ]")

(defun +ly|forward-atom ()
  "Go to next atom."
  (interactive)
  (require 'symex)
  (symex-traverse-forward)
  (while (or (eq ?\( (char-after)))
    (symex-traverse-forward)))

(defun +ly|backward-atom ()
  "Go to next atom."
  (interactive)
  (require 'symex)
  (symex-traverse-backward)
  (while (or (eq ?\( (char-after)))
    (symex-traverse-backward)))

(defun +ly|forward-brace ()
  "Go to next sexp brace."
  (interactive)
  (require 'symex)
  (symex-go-up)
  (search-forward-regexp +ly:brace-regexp nil t)
  (backward-char 2))

(defun +ly|backward-brace ()
  "Go to previous sexp brace."
  (interactive)
  (require 'symex)
  (unless (eq ?\( (char-after))
    (symex-go-down))
  (search-backward-regexp +ly:brace-regexp nil t))

(defun +ly|up-atom ()
  "Go up the tree"
  (interactive)
  (require 'symex)
  (symex-go-down))
#+END_SRC

**** Line Navigation

#+BEGIN_SRC elisp
(defun +ly|forward-line ()
  "Function docstring"
  (interactive)
  (next-line 1)
  (goto-char (point-at-bol))
  (search-forward-regexp "\s*[^\s]" nil t)
  (backward-char 1))

(defun +ly|backward-line ()
  "Function docstring"
  (interactive)
  (previous-line 1)
  (goto-char (point-at-bol))
  (search-forward-regexp "\s*[^\s]" nil t)
  (backward-char 1))
#+END_SRC
**** List Modification

***** Add to list

#+BEGIN_SRC elisp
(defun +ly/inside-string? ()
  "Returns non-nil if inside string, else nil.
Result depends on syntax table's string quote character."
  (nth 3 (syntax-ppss)))

(defun +ly|add-atom (&optional same-line?)
  "Add atom in the current sexp. If the cursor is under a string match the type and insert another string."
  (interactive "P")
  (let ((was-parinfer-list-mode (eq 'paren parinfer--mode)))
    (up-list 1 t)
    (unless same-line?
      (parinfer-lispy:newline))
    (when same-line? (insert " "))
    (cond ((+ly/inside-string?)
           (insert (t! "\"\""))
           (backward-char 1)))
    (evil-insert-state)))
#+END_SRC

*** Hydra

#+BEGIN_SRC elisp
(defhydra +ly|hydra ()
   "Ly Navigation"
   ("f" (+ly|forward-brace) "Forward ()" :column "Navigate")
   ("b" (+ly|backward-brace) "Backward ()")
   ("f" (+ly|forward-brace) "forward ()" :column "Navigate")
   ("b" (+ly|backward-brace) "Backward ()")
   ("j" (+ly|forward-line) "Next Line")
   ("k" (+ly|backward-line) "Backward Line"))
#+END_SRC

** TODO Indirect Indent Mode

Adds minor mode for editing indented source code in an indirect buffer,
with the indentation reset to 0.
Saving and committing keeps the indentation in the source buffer.

#+BEGIN_SRC elisp
(defvar-local +indirect-indent 0)

(defvar +indirect-indent-mode-map (make-sparse-keymap))

(define-minor-mode +indirect-indent-mode
  "Editing indented source code without the indent in an indirect buffer."
  :keymap +indirect-indent-mode-map)

(map! :map +indirect-indent-mode-map
      :gni "s-s" #'edit-indirect-save)

(add-hook! +indirect-indent-mode
           (defun +indirect-indent/init-hook ()
             (setq header-line-format
                   "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")))

(advice-add #'edit-indirect-commit :before #'+indirect-indent/restore-indentation)
(advice-add #'edit-indirect-save :after #'+indirect-indent/remove-indentation)
(advice-add #'edit-indirect-save :before #'+indirect-indent/restore-indentation)

(defun +indirect-indent/restore-indentation ()
  (when (and (bound-and-true-p +indirect-indent-mode)
             (not (eq +indirect-indent 0)))
    (my/without-undo
      (indent-rigidly (point-min) (point-max) (+ +indirect-indent)))))

(defun +indirect-indent/remove-indentation ()
  (when (and (bound-and-true-p +indirect-indent-mode)
             (not (eq +indirect-indent 0)))
    (my/without-undo
      (indent-rigidly (point-min) (point-max) (- +indirect-indent)))))

(defun +indirect-indent|edit (beg end &optional with-mode)
  "Edit script in an indirect buffer."
  (interactive)
  (edit-indirect-region beg end t)
  (let ((indent (indent-rigidly--current-indentation (point-min) (point-max))))
    (unless (eq indent 0)
      (my/without-undo
       (indent-rigidly (point-min) (point-max) (- indent)))
      ;; Local variables get undone when calling a mode
      ;; So we have to define the major mode before
      (funcall with-mode)
      (+indirect-indent-mode 1)
      (setq +indirect-indent indent))))
#+END_SRC

** TODO Evil edit register

Edit registers with ~+evil-edit-register|counsel~.
Mostly used to edit the macro registers ~q~.

#+BEGIN_SRC elisp
(defvar +evil-edit-register:register "")
(defvar +evil-edit-register-mode-map (make-sparse-keymap))

(define-minor-mode +evil-edit-register-mode
  "Edit evil register and save it back to the register."
  :keymap +evil-edit-register-mode-map)

(map! :map +evil-edit-register-mode-map
      "C-c C-c" #'+evil-edit-register|save-and-exit
      "C-c C-k" #'kill-buffer-and-window)

(defun +evil-edit-register|save-and-exit (&optional arg)
  "Save the buffer content back to the register register"
  (interactive)
  (evil-set-register
   (string-to-char +evil-edit-register:register)
   (buffer-substring-no-properties (point-min) (point-max)))
  (kill-buffer-and-window))

(defun +evil-edit-register|counsel (register-string)
  "Edit evil register in register"
  (require 'noflet)
  (interactive (noflet ((counsel-evil-registers-action (x) x))
                 (list (counsel-evil-registers))))
  (-when-let* ((register-string (substring-no-properties register-string))
               (buffer (generate-new-buffer (t! "*Evil Register Edit: <<register-string>>*")))
               ((_ reg register) (s-match "^\\[\\(.\\)\\]: \\(.*\\)$" register-string)))
    (pop-to-buffer buffer)
    (with-current-buffer buffer
      (+evil-edit-register-mode 1)
      (setq-local +evil-edit-register:register reg)
      (setq header-line-format "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")
      (save-excursion
        (insert register)))))
#+END_SRC
** TODO Scan Management

#+begin_src elisp
(defun my::scan|dired-file-document ()
  (interactive)
  (let* ((files (->> (dired-get-marked-files)
                     (-sort #'string<)
                     (-map #'shell-quote-argument)
                     (s-join " ")))
         (bin (f-expand "~/Code/Projects/org_print_scan/result/bin/org_print_scan"))
         (headline (read-string "Headline: "))
         (command (t! "<<bin>> copy <<files>> --headline \"<<headline>>\"")))
    (-log command)
    (shell-command-to-string command)
    (find-file "~/Media/Scans/Scans.org")
    (goto-char (max-char))
    (+org|counsel-org-tag)))
#+end_src

** Window Management
*** Window Listing

#+BEGIN_SRC elisp
(defvar my::wm:window-list-re nil "Regex to parse wmctrl list output.
Example output:
0x014000fb  0 brave-browser.Brave-browser  thinknixx1 The Borrowed by Chan Ho-Kei :: www.goodreads.com/ - Brave")

(setq my::wm:window-list-re
      (rx (seq
           bol
           ;; window id (0x014000fb)
           (submatch "0x" (+ (any digit "a-f"))) "  "
           ;; index
           (submatch (+ (any digit))) " "
           ;; title (brave-browser.Brave-browser)
           (submatch (+ nonl)) "." (submatch (+ (not (any " "))))
           ;; right aligned column for username
           " " (+ " ")
           ;; username (thinknixx1)
           (submatch (literal (system-name))) " "
           ;; Window title
           (submatch (* nonl)) eol)))

(defun my::wm/match-wm-string (x)
  (-let* ((xs (-drop 1 (s-match my::wm:window-list-re x)))
          (pid (downcase (nth 0 xs)))
          (monitor (nth 1 xs))
          (process (nth 2 xs))
          (process-title (nth 3 xs))
          (user (nth 4 xs))
          (title (nth 5 xs)))
    (list
     :pid pid
     :monitor monitor
     :process process
     :process-title process-title
     :user user
     :title title)))

(defun my::wm/list-windows ()
  "List X windows"
  (->> (shell-command-to-string "wmctrl -lx")
       (s-split "\n")
       (-drop-last 1)
       (-map #'my::wm/match-wm-string)))

(defun my::wm/-process-eq? (id x)
  (string= id (plist-get x ':process)))

(defun my::wm/-pid-eq? (id x)
  (string= id (plist-get x ':pid)))
#+END_SRC

*** Browser Window Listing

#+BEGIN_SRC elisp
(defvar my::wm:browser-title-delimiter-char " ​::​ "
  "The delimiter inserted by the tab title formating extension to seperate the url from the title.
To make sure it is our own delimiter the characters are prefixed and suffixed with zero-width space characters.")

(setq my::wm:browser-url-suffixes '(" - Chromium"
                                    " - Brave"))
(defun my::wm/browser-chop-suffix (url)
  (s-chop-suffixes my::wm:browser-url-suffixes url))

(defun my::wm/is-browser? (x)
  (or
   (my::wm/-process-eq? "chromium-browser" x)
   (my::wm/-process-eq? "brave-browser" x)))

(defun my::wm/list-browser-windows ()
  (->> (my::wm/list-windows)
       (-filter #'my::wm/is-browser?)))

(defun my::wm/prev-browser-window ()
  "Try either current or previous window to get the chrome id
Everything further down the line would have to be parsed from bspc history,
and most of the time it's not worth it.
If the current or previous windows are not chrome, just get the first one from the list."
  (--> (my::wm/list-browser-windows)
       (car it)))

(defun my::wm/browser-split-url (x)
  (pcase (s-split my::wm:browser-title-delimiter-char x)
     (`(,title ,url) (list title (my::wm/browser-chop-suffix url)))
     (`(,title) (list title ""))))

(defun my::wm/last-browser-window ()
  (-when-let*
      ((window (my::wm/prev-browser-window))
       ((title url) (-some->> (plist-get window ':title)
                      my::wm/browser-split-url)))
    (list
     title
     (if (s-blank? url) nil url))))

(defun my::wm/last-browser-url ()
  (-let* (((title url) (my::wm/last-browser-window)))
    url))

(defun my::wm/last-browser-url-org-link ()
  (let ((data (my::wm/last-browser-window)))
    (-if-let* (((description link) data))
        (org-make-link-string link description)
      (user-error "Error: Could not get browser url %s" data))))

(defun my::wm/last-browser-url-org-link-formatted ()
  (-if-let* (((title url) (my::wm/last-browser-window))
             (title-formatted
                (cond
                 ;; Custom Pull request Formatting
                  ((s-matches? "^https://github.com.*/pull/[0-9]+.*$" url)
                   (let* ((match (s-match "\\(.+\\) by \\(.+\\) · Pull Request \\(#[0-9]+\\).*$" title))
                          (pr-title (nth 1 match))
                          (pr-user (nth 2 match))
                          (pr-id (nth 3 match)))
                     (template "PR <<pr-id>>: <<pr-title>> by @<<pr-user>>")))
                  (t title))))
      (template "[[<<url>>][<<title-formatted>>]]")
    (user-error "Error: Could not get browser url %s" data)))
#+END_SRC
** Shopping list management

#+begin_src elisp :tangle no
(defun my::org-db/get-db ()
  ""
  (let* (($headlines (->> (org-ml-parse-headlines 'all)))
         (keywords (->> $headlines
                        (--reject (or (eq (org-ml-get-property :level it) 1)
                                      (org-ml-get-children it)
                                      (string= (org-ml-get-property :raw-value (org-ml--get-parent it)) "Incoming")))
                        (--map (org-ml-get-property :raw-value it)))))
    keywords))

(save-window-excursion
  (with-current-buffer (find-file (+org/expand-org-file-name "Db/Shopping.org"))
    (-log (my::org-db/get-db))))
#+end_src

* Default Configuration
** Temp

Include colons as delimiters for now

#+begin_src elisp
(modify-syntax-entry ?: "w" emacs-lisp-mode-syntax-table)
(after! org-mode
  (modify-syntax-entry ?: "w" org-mode-syntax-table))
(after! grep-mode
  (modify-syntax-entry ?: "w" grep-mode-syntax-table))
#+end_src

** Secrets

Config files that I don't want to share with the world.
They will be stored in here:

#+BEGIN_SRC elisp
(defvar my::secrets:config-file nil
  "My private config file.")
(setq my::secrets:config-file "~/.config/secrets.el")
#+END_SRC

And I will load them on system start:

#+BEGIN_SRC elisp
(defun my::secrets/load-config-file ()
  (-some->> my::secrets:config-file
    (-id-when 'file-exists-p)
    (load-library)))

(my::secrets/load-config-file)
#+END_SRC
** Custom Variables
*** Directories
**** Downloads

#+BEGIN_SRC elisp
(defcustom my::directories:downloads-dir "~/Downloads"
  "Downloads Directory"
  :type 'string)
#+END_SRC

**** Repositories

#+BEGIN_SRC elisp
(defcustom my::directories:repositories-dir "~/Code/Repositories"
  "Downloads Directory"
  :type 'string)
#+END_SRC

** Emacs
*** User Name

#+begin_src elisp
(setq user-full-name "Florian Schrödl")
#+end_src

*** Move items to trash on delete

#+BEGIN_SRC elisp
(setq
 trash-directory "~/.Trash/"
 delete-by-moving-to-trash t)
#+END_SRC

*** Automatically reload tags files

#+BEGIN_SRC elisp
(setq tags-revert-without-query 1)
#+END_SRC

*** Disable blinking cursor

#+BEGIN_SRC elisp
(blink-cursor-mode -1)
(setq blink-matching-paren nil)
(setq visible-cursor nil)
#+END_SRC
*** Safe local variables

Variables that I want to safely set from ~.dir-locals~ files.

#+BEGIN_SRC elisp
(put '+file-templates-dir 'safe-local-variable #'stringp)
#+END_SRC

*** Buffer naming

#+BEGIN_SRC elisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

*** Load ~.authinfo.gpg~ for authentication :AUTH:

#+BEGIN_SRC elisp
(add-to-list 'auth-sources "~/.config/gnupg/.authinfo.gpg")
#+END_SRC

*** Disable ~dcl~ mode for password files :AUTH:FIX:

Since it has the regex matching ~.com~ it's enabled for all my password files,
which I name after the matching url.

#+BEGIN_SRC elisp
(setq auto-mode-alist (rassq-delete-all 'dcl-mode auto-mode-alist))
#+END_SRC

** Doom
*** Init

#+BEGIN_SRC emacs-lisp :tangle "init.el" :comments no
(doom!
 :completion
 (company
  +childframe)
 (ivy
  +childframe)

 :ui
 doom
 modeline
 doom-quit
 hl-todo
 (popup +all +defaults)
 vc-gutter
 vi-tilde-fringe
 window-select
 workspaces
 zen

 :email
 (mu4e +gmail)

 :editor
 (evil +everywhere)
 file-templates
 fold
 rotate-text
 multiple-cursors
 (parinfer +rust)
 snippets

 :term
 eshell
 term
 ;; vterm

 :emacs
 (dired +icons)
 electric
 vc
 (undo +tree)

 :checkers
 (syntax +childframe)
 grammar
 spell

 :tools
 direnv
 (lookup
  +devdocs
  +docsets
  +dictionary
  +offline)
 eval
 editorconfig
 (magit +forge)
 rgb
 pdf
 pass
 docker
 lsp

 :lang
 lua
 nix
 rust
 (ruby +rails)
 rest
 data
 (haskell +lsp)
 emacs-lisp
 markdown
 ocaml
 nim
 (clojure +lsp)
 (javascript +lsp)
 (org
  +roam2
  +dragndrop
  +pretty
  +present)
 sh
 yaml
 (web +css)

 :app
 irc
 calendar
 (rss +org)

 :config
 (default +bindings +snippets +evil-commands)

 :private
 system
 (org
  +org-reading-list
  +org-tags
  +org-pinboard))
#+END_SRC

*** Garbage collection

Set it to =32 MiB=.

#+BEGIN_SRC elisp
(setq doom-gc-cons-threshold 33554432)
#+END_SRC

** UI
*** Functions
**** Toggle window split style
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/46664/switch-between-horizontal-and-vertical-splitting][Switch between horizontal and vertical splitting? - Emacs Stack Exchange]]
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defun my::ui|toggle-window-split-direction ()
  "Toggle current window split between horizontal and vertical."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

**** Toggle window dedicated
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/2189/how-can-i-prevent-a-command-from-using-specific-windows][buffers - How can I prevent a command from using specific windows? - Emacs Stack Exchange]]
:END:

Lock a window so the buffer can't be changed or it cant be deleted.

#+BEGIN_SRC elisp
;;;###autoload
(defun my::ui|toggle-window-dedicated ()
  "Control whether or not Emacs is allowed to display another
buffer in current window."
  (interactive)
  (let* ((window (get-buffer-window (current-buffer)))
         (is-locked (window-dedicated-p window))
         (txt (if is-locked "Window unlocked" "Window locked")))
    (set-window-dedicated-p window (not is-locked))
    (message (template "<<(current-buffer)>>: <<txt>>!"))))
#+END_SRC
**** Adjust font to display

#+BEGIN_SRC elisp
;;;###autoload
(defun my::ui/adjust-font (size line-space &optional font-family weight)
  (let* ((font-family (or font-family)))
    (setq-default line-spacing line-space)
    (setq-default doom-font (font-spec :family font-family :size size :weight weight))
    (setq-default doom--font-scale nil)
    (set-frame-font doom-font 'keep-size t)
    (doom/reload-font)
    (run-hooks 'after-setting-font-hook)))

;;;###autoload
(defun my::ui/get-x-screen ()
  "Get a list of all connected screens."
  (-> "xrandr | grep ' connected ' | cut -d ' ' -f 1"
      (shell-command-to-string)
      (split-string "\n")
      (reverse)
      (cdr)
      (reverse)
      (cl-sort (lambda (a b)
                 (cond ((string-match-p "^eDP" a) t)
                       ((string-match-p "^eDP" b) nil)
                       (t nil))))))

;;;###autoload
(defun my::ui/has-display-connected? (screen)
  "Check if SCREEN is connected."
  (-contains? (my::ui/get-x-screen) screen))

;;;###autoload
(defun my::ui|adjust-ui-to-display ()
  "Adjust the UI to the current attached display."
  (interactive)
  (cond
   ((string= (system-name) "mbair")
    ;; Not actually a retina display, but this looks best
    (my::ui/adjust-font 13 5 "Fira Code"))
   ((string= (system-name) "Florians-iMac.local")
    (my::ui/adjust-font 14 10 "Menlo"))
   ((string= (system-name) "thinknix")
    (if (my::ui/has-display-connected? "DP2")
        (my::ui/adjust-font 18 7 "Fira Code" 'medium)
      (my::ui/adjust-font 15 4 "Fira Code" 'medium)))
   ((string= (system-name) "thinknixx1")
    (if (my::ui/has-display-connected? "DP-3")
        (my::ui/adjust-font 18 7 "Fira Code" 'medium)
      (my::ui/adjust-font 15 4 "Fira Code" 'medium)))
   ((string= (system-name) "Florians-MacBook-Air.local")
    (my::ui/adjust-font 14 10 "Menlo"))))
#+END_SRC
**** Line spacing hydra :HYDRA:

Change and reset line-spacing for all buffers.

#+BEGIN_SRC elisp
(defvar my::ui:default-line-spacing line-spacing)
(defvar my::ui:default-line-spacing-increment-step 1)
(defvar my::ui:default-big-line-spacing-increment-step 10)

(defun my::ui/set-line-spacing (&optional increment)
  "Set the line spacing
When no line spacing is given is the default-line-spacing"
  (setq-default line-spacing (+ (or increment my::ui:default-line-spacing-increment-step) line-spacing)))

(defun my::ui|reset-line-spacing ()
  (interactive)
  (setq-default line-spacing my::ui:default-line-spacing))

(defun my::ui|increase-line-spacing ()
  (interactive)
  (my::ui/set-line-spacing))

(defun my::ui|decrease-line-spacing ()
  (interactive)
  (my::ui/set-line-spacing (- my::ui:default-line-spacing-increment-step)))

(defun my::ui|increase-line-spacing-big ()
  (interactive)
  (my::ui/set-line-spacing my::ui:default-big-line-spacing-increment-step))

(defun my::ui|decrease-line-spacing-big ()
  (interactive)
  (my::ui/set-line-spacing (- my::ui:default-big-line-spacing-increment-step)))

(evil-define-key 'normal 'global (kbd "]z") #'my::ui/line-spacing-hydra/body)

;;;###autoload (autoload '+common-lisp/macrostep/body "lang/common-lisp/autoload/hydras" nil nil)
(defhydra my::ui/line-spacing-hydra (:exit nil :hint nil :foreign-keys run :color pink)
  "
Macro Expansion
^^Definitions                           ^^Compiler Notes             ^^Stickers
^^^^^^─────────────────────────────────────────────────────────────────────────────────────
[_r_] Reset
[_]_] Expand
[_[_] Collapse
[_}_] Expand Big
[_{_] Collapse Big
"
  ("r" my::ui|reset-line-spacing)
  ("]" my::ui|increase-line-spacing)
  ("[" my::ui|decrease-line-spacing)
  ("}" my::ui|increase-line-spacing-big)
  ("{" my::ui|decrease-line-spacing-big)
  ("q" nil "cancel" :color blue))
#+END_SRC

**** TODO Theme Toggle

Toggle between a light and a dark theme.
Bound to ~SPC t t~.

#+BEGIN_SRC elisp
(defun my::ui|toggle-theme ()
  "Toggle between light and dark themes."
  (interactive)
  (-when-let* ((theme (pcase doom-theme
                        (`doom-one 'doom-one-light)
                        (`doom-one-light 'doom-one))))
    (message (t! "Toggling to theme: <<theme>>"))
    (setq doom-theme theme)
    (load-theme theme)))
#+END_SRC

*** Configuration
**** Zen mode & variable pitch fonts

#+BEGIN_SRC elisp
(setq +zen-text-scale 1.5)

(let ((height 140)
      (size 23))
  (setq doom-variable-pitch-font (font-spec :family "IBM Plex Sans" :size size)
        doom-serif-font (font-spec :family "IBM Plex Sans" :size size)))
#+END_SRC
**** Add frame padding

#+BEGIN_SRC elisp
(add-hook! '(window-setup-hook after-make-frame-functions)
  (defun my::ui/init-frame-ui (&optional frame)
    (interactive)
    "Re-enable menu-bar-lines in GUI frames."
    (when-let (frame (or frame (selected-frame)))
      (when (display-graphic-p frame)
        (set-frame-parameter frame 'internal-border-width 15)))))
#+END_SRC

**** Theme Modifications
***** General

#+BEGIN_SRC elisp
(add-hook 'doom-load-theme-hook #'*doom-themes-custom-set-faces)
#+END_SRC

****** Function Start

#+BEGIN_SRC elisp
(defun *doom-themes-custom-set-faces ()
  (set-face-attribute 'fringe nil
                      :foreground (face-background 'default)
                      :background (face-background 'default))
  (custom-set-faces!
#+END_SRC

****** Bookmarks

#+BEGIN_SRC elisp
'(bookmark-face :background nil)
#+END_SRC

****** Dired Output

Remove the rainbow colors from dired.

#+BEGIN_SRC elisp
'(diredfl-read-priv :foreground "#80899E")
'(diredfl-write-priv :foreground "#80899E")
'(diredfl-exec-priv :foreground "#80899E")
'(diredfl-other-priv :foreground "#80899E")

'(all-the-icons-dired-dir-face :foreground "#80899E")

'(diredfl-dir-priv :foreground "#282C34")
'(diredfl-k-modified :foreground "#FF8E90")

'(diredfl-number :foreground "#80899E")
'(diredfl-date-time :foreground "#49505F")
`(diredfl-dir-name :foreground "#2DADF2")
#+END_SRC

****** Mu4E

Switch the highlight.

#+BEGIN_SRC elisp
'(mu4e-highlight-face :inherit mu4e-unread-face)
#+END_SRC

****** Org Mode

Remove the ugly grey background

#+BEGIN_SRC elisp
'(org-column :background nil)
#+END_SRC

****** Function End

#+BEGIN_SRC elisp
))
#+END_SRC
***** Hooks
****** Diff Highlighting

#+BEGIN_SRC elisp
(add-hook! '(diff-hl-margin-minor-mode-hook)
  (progn
    (set-face-attribute 'smerge-refined-added nil
                        :foreground (doom-blend "#98be65" "#3e493d" 0.15)
                        :background (doom-lighten "#98bb5d" 0.2))
    (set-face-attribute 'smerge-refined-removed nil
                        :foreground (doom-blend "#ff6c6b" "#4f343a" 0.2)
                        :background (doom-lighten "#ff6c6b" 0.1))))

(add-hook! '(magit-status-mode-hook magit-diff-mode-hook)
           (progn
                   (set-face-attribute 'diff-refine-added nil
                                       :foreground (doom-blend "#98be65" "#3e493d" 0.15)
                                       :background (doom-lighten "#98bb5d" 0.2))
                   (set-face-attribute 'diff-refine-removed nil
                                       :foreground (doom-blend "#ff6c6b" "#4f343a" 0.2)
                                       :background (doom-lighten "#ff6c6b" 0.1))))
#+END_SRC
**** Adjust UI

Resize the window font size etc according to the system.
This will be disabled in terminal mode.

#+BEGIN_SRC elisp
(add-hook! '(doom-init-ui-hook after-make-frame-functions)
  (defun my::ui*after-make-frame (&rest _)
    (when (display-graphic-p) (my::ui|adjust-ui-to-display))))
#+END_SRC
**** Scrolloff

Start scrolling X lines before the end of a screen.
Disable for certain modes (terminal & ivy) where the window is to small.

#+BEGIN_SRC elisp
(setq scroll-conservatively 10)
(setq scroll-margin 10)

(add-hook 'term-mode-hook (cmd! (setq-local scroll-margin 0)))
(add-hook 'ivy-mode-hook (cmd! (setq-local scroll-margin 0)))
#+END_SRC

**** (Visual) Fill Column

#+BEGIN_SRC elisp :tangle no
(setq-default fill-column 110)
(setq fill-column 110)
(setq visual-fill-column-width fill-column)

(setq visual-fill-column-center-text t
      visual-fill-column-width fill-column)
#+END_SRC

**** Disable trailing whitespace warning

#+BEGIN_SRC elisp :tangle no
(setq-hook! 'prog-mode-hook show-trailing-whitespace nil)
#+END_SRC

**** Fix underline

Draw the underline at the bottom of the text, not at the end of line-spacing.

#+BEGIN_SRC elisp
(setq x-underline-at-descent-line nil)
#+END_SRC

** Text
*** Functions
**** Expand region hydra :HYDRA:
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/also27/second_trial_for_a_weekly_tipstricksetc_thread/efi7pbj/
:END:

Expand visual region using a hydra.
Double press ~v~ to enable.

#+BEGIN_SRC elisp
(defhydra my::text/expand-region-hydra ()
   "region: "
   ("f" er/mark-defun "defun")
   ("v" er/expand-region "expand")
   ("V" er/contract-region "contract"))

(evil-define-key 'visual 'global (kbd "v") #'my::text/expand-region-hydra/body)
#+END_SRC
**** Unfill Paragraph

Fix a paragraph that was formatted to a fill column.

#+BEGIN_SRC elisp
(defun my::text|unfill-paragraph ()
  "Fix a paragraph that was formatted to a fill column."
  (interactive)
  (let ((fill-column (point-max)))
    (fill-paragraph nil)))
#+END_SRC

* Package Configuration
** Package Overrides / Disabling / Pinning

Packages that I haven't yet moved to their structure.

*** Doom Snippets

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! doom-snippets :ignore t)
(package! my-doom-snippets
  :recipe (:host github
           :repo "floscr/doom-snippets"
           :files ("*.el" "*")))
#+END_SRC

*** Posframe

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! flycheck-posframe :pin "6eea204138721f511051af5138326fecaad237b7")
#+END_SRC

*** Calfw
Continuous events are broken in the current calfw source,
also it seems it isn't maintained anymore.
[[https://github.com/floscr/emacs-calfw/commit/3d17649c545423d919fd3bb9de2efe6dfff210fe][This Commit]] fixes the behavior.

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! calfw :recipe (:host github :repo "floscr/emacs-calfw") :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-org :recipe (:host github :repo "floscr/emacs-calfw") :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-ical :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-cal :disable t)
(package! org-gcal :disable t)
#+END_SRC

*** json-proces-client

This package is originally hosted on https://gitea.petton.fr/nico/json-process-client.git/
But this private repository host went down a few times, so I'll stick to github.

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! json-process-client
  :recipe (:host github :repo "emacsmirror/json-process-client")
  :pin "373b2cc7e3d26dc00594e0b2c1bb66815aad2826")
#+END_SRC

*** Remove those annoying LSP interface plugins

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! lsp-ui :disable t)
#+END_SRC

*** merlin

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! merlin :pin "e4791e22986993c36c3f5c91e8dff93494cc232e")
(package! merlin-eldoc :disable t)
#+END_SRC

** Emacs :EMACS:
*** Libraries

Packages that enhance or fix ~emacs-lisp~.

**** [[https://github.com/nicferrier/emacs-noflet][noflet]] :FIX:

Override functions like variables with using ~(flet ((#'my-fn)))~

Since ~flet~ was deprecated, I'm using this for now.
Pretty much only used in [[*Expand snippet by name][Expand snippet by name]].

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! noflet)
#+END_SRC

** Doom :DOOM:
*** Popups

**** Defaults

These will be written to ~init.el~ so it overwrites the doom standard values.

#+BEGIN_SRC emacs-lisp :tangle "init.el" :comments no
(setq +popup-defaults
  (list :side   'bottom
        :height 0.45
        :width  40
        :quit   t
        :select t
        :ttl    5))
#+END_SRC

**** Rules

#+BEGIN_SRC elisp
(set-popup-rules!
  '(("^\\*Org Agenda" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*Org Src" :ignore t)
    ("^\\*Org QL View: \\(Work \\)?Projects*" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*PDF-Occur*" :side right :size 0.5 :select t :modeline t)
    ("^\\*WoMan " :side right :size 0.5 :select t :modeline t :ttl nil :quit nil)
    ("^\\*helm" :vslot -100 :size 0.32 :ttl nil)
    ("^\\*helpful command" :side right :size 0.5 :select t :modeline t :ttl nil :quit nil)
    ("^\\*nodejs" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*projectile-files-errors" :ignore t)
    ("^\\*elfeed-entry" :modeline t :ttl nil)
    ("^\\*Flycheck checker" :size 0.2 :select nil)))
#+END_SRC
*** Themes
**** Custom doom themes package

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! doom-themes
  :recipe (:host github :repo "floscr/emacs-doom-themes" :files ("*.el" "themes/*.el"))
  :pin nil)
#+END_SRC

*** Workspaces
**** Functions
***** Switch to

Enhancement of the default ~+workspace/switch-to~.
This allows quick deletion of workspaces from ivy with ~CTRL + BACKSPACE~.

#+BEGIN_SRC elisp
(defvar counsel-workspace-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-<backspace>") #'my::workspaces|switch-to-delete-space)
    map))

(defun my::workspaces/switch-to-delete-space (workspace)
  (let* ((current-workspace-name (+workspace-current-name))
         (new-workspace-name
            (or (--first (string= current-workspace-name it) (+workspace-list-names)) "main")))
    (+workspace/delete workspace)
    (+workspace-switch new-workspace-name)
    (my::workspaces/switch-to)))

(defun my::workspaces|switch-to-delete-space ()
  (interactive)
  (ivy-set-action #'my::workspaces/switch-to-delete-space)
  (ivy-done))

(defun my::workspaces/switch-to ()
  (interactive)
  (ivy-read "Switch to workspace: "
            (+workspace-list-names)
            :keymap counsel-workspace-map
            :action #'+workspace/switch-to))
#+END_SRC

***** Close others

#+BEGIN_SRC elisp
(defun my::workspaces|close-others ()
  "Close all other workspaces."
  (interactive)
  (--> (+workspace-list-names)
       (--reject (string= (+workspace-current-name) it) it)
       (-each it #'+workspace-delete))) ;
#+END_SRC

***** Find workspace file

Most of the time you create workspaces from a project.
But when the CWD has changed in that workspace, you would have to relocate to
the projects cwd to find a file.

#+BEGIN_SRC elisp
(defun my::workspaces/workspace-project-root (&optional arg)
  "Gets the root dir for the current workspace"
  (--find (s-match (concat (+workspace-current-name) "/$") it) projectile-known-projects))

(defun my::workspaces|find-workspace-project-file ()
  "Projectile find file for the project named after the current workspace."
  (interactive)
  (cl-letf (((symbol-function 'projectile-project-root) #'my::workspaces/workspace-project-root))
    (projectile-find-file)))

(defun my::workspaces|workspace-project-vc ()
  "Projectile find file for the project named after the current workspace."
  (interactive)
  (let ((default-directory
          (or (my::workspaces/workspace-project-root)
              (my::file/project-root))))
    (magit-status)))
#+END_SRC

***** New named workspace

#+BEGIN_SRC elisp
(defun +workspace/new-named ()
  "Create a new named workspace."
  (interactive)
  (let ((name (read-string "New workspace name: ")))
    (if name (+workspace/new name))))
#+END_SRC

***** Cleanup

#+BEGIN_SRC elisp
(defun my::workspaces/remove-other-buffers (&optional keep-alive?)
  "Kill or remove all other buffers from current workspace."
  (interactive)
  (--> (+workspace-buffer-list)
       (--reject (eq (current-buffer) it) it)
       (if keep-alive?
           (persp-remove-buffer it)
         (kill-buffer it))))

(defun my::workspaces|hide-other-buffers ()
  "Hide all inactive buffers from the current workspace."
  (interactive)
  (my::workspaces/remove-other-buffers t))

(defun my::workspaces|kill-other-buffers ()
  "Kill all interactive buffers from the current workspace."
  (interactive)
  (my::workspaces/remove-other-buffers))

(defun my::workspaces|hide-non-project-buffers ()
  "Hide all file buffers that don't belong to the project workspace."
  (interactive)
  (let ((project-path (or (expand-file-name (my::workspaces/workspace-project-root))
                          (projectile-project-root))))
    (-some--> (+workspace-buffer-list)
         ;; Dont remove non-remove buffers
         (--filter (buffer-file-name it) it)
         (--reject (s-contains? project-path (buffer-file-name it)) it)
         (--each (persp-remove-buffer it) it))))
#+END_SRC

**** Config
***** Always add buffers to current workspace

Doom per default adds buffers to the current workspace on ~find-file~.
I want buffers added whenever I visit a buffer.

#+BEGIN_SRC elisp
(after! persp-mode
  (defun my::workspaces*add-special-buffer ()
    (if-let* ((name (buffer-name))
              (add-buffer? (or
                            ;; Always add files to workspaces
                            (buffer-file-name)
                            ;; Add src buffer
                            (s-matches? "\\*Org Src.*" name))))
      (persp-add-buffer (current-buffer) (get-current-persp))))

  (add-hook 'doom-switch-buffer-hook #'my::workspaces*add-special-buffer))
#+END_SRC
** Evil :EVIL:
*** Packages
**** [[https://github.com/tarao/evil-plugins][tarao/evil-plugins]]

Used for [[*Little Word Motion][evil-little-word]].

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! evil-plugin :recipe (:host github :repo "tarao/evil-plugins"))
#+END_SRC

**** [[https://github.com/emacsmirror/evil-replace-with-register][evil-replace-with-register: Replace with register motion]]

Replace the current selection with a register.
Press =gr= with a following motion character like =w=.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! evil-replace-with-register)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! evil-replace-with-register
  :config
  (setq evil-replace-with-register-key (kbd "gr"))
  (define-key evil-normal-state-map
    evil-replace-with-register-key 'evil-replace-with-register)
  (define-key evil-visual-state-map
    evil-replace-with-register-key 'evil-replace-with-register))
#+END_SRC
**** [[https://github.com/urbint/evil-text-objects-javascript][evil-text-objects-javascript: Javascript motions]]

- "f" - function
- "c" - single-line comment
- "C" - multi-line comment

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! evil-text-objects-javascript :recipe (:host github :repo "urbint/evil-text-objects-javascript"))
#+END_SRC

**** [[https://github.com/hlissner/evil-snipe][evil-snipe: 2-char searching ala vim-sneak & vim-seek, for evil-mode]]
***** Config
****** Repeat snipe after further key press

#+BEGIN_SRC elisp
(after! evil-snipe
  (setq evil-snipe-repeat-keys t))
#+END_SRC
*** Config
**** Enable fine undo

Whether evil actions like =cw= are undone in several steps.
This is sometimes annoying, as it might need you to press =u= multiple times.
But I prefer the fine grained control, as I'm often staying longer in insert mode,
and don't want one single undo action for the whole "session".

#+BEGIN_SRC elisp
(setq evil-want-fine-undo t)
#+END_SRC
** Text Editing :TEXT:
*** Packages
**** [[https://github.com/sulami/literate-calc-mode.el][literate-calc-mode]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! literate-calc-mode)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! literate-calc-mode
  :commands (literate-calc-mode literate-calc-minor-mode))
#+END_SRC

**** [[https://github.com/joostkremers/writeroom-mode][writeroom-mode]]

Distraction free writing

***** Config

****** Custom Design :FIX:

#+BEGIN_SRC elisp
(defun my::writeroom/setup ()
  (if writeroom-mode
      (my::writeroom/load)
    (my::writeroom/unload)))

(defun my::writeroom/load ()
  (setq-local line-spacing 0.4)
  (setq-local +writeroom:faceremaps
              (list
               (face-remap-add-relative
                'org-link `(:foreground ,(face-attribute 'default :foreground)
                            :underline ,(face-attribute 'default :foreground)
                            :weight normal))
               (face-remap-add-relative
                'default `(:foreground ,(doom-blend
                                         (face-attribute 'default :background)
                                         (face-attribute 'default :foreground)
                                         0.1))))))

(defun my::writeroom/unload ()
  (kill-local-variable 'line-spacing)
  (mapc #'face-remap-remove-relative +writeroom:faceremaps)
  (kill-local-variable '+writeroom:faceremaps))

(add-hook! 'writeroom-mode-hook #'my::writeroom/setup)
#+END_SRC
**** [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]]

Centered buffers, doom does not support this anymore.

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! visual-fill-column)
#+END_SRC
**** [[https://www.emacswiki.org/emacs/NarrowIndirect][narrow-indirect]]

When narrowing to region or defun, make it in an indirect other window.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! narrow-indirect :recipe (:host github :repo "emacsmirror/narrow-indirect"))
#+END_SRC

***** Bindings

#+BEGIN_SRC elisp
(use-package! narrow-indirect
  :init
  (global-set-key (kbd "C-x n n") 'ni-narrow-to-region-indirect-other-window)
  (global-set-key (kbd "C-x n d") 'ni-narrow-to-defun-indirect-other-window))
#+END_SRC
*** Functions

** UI :UI:
*** Higlight indent guides

**** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! highlight-indent-guides :pin "cf352c85cd15dd18aa096ba9d9ab9b7ab493e8f6")
#+END_SRC

**** Config

#+BEGIN_SRC elisp
(use-package! highlight-indent-guides
  :hook ((stylus-mode) . highlight-indent-guides-mode)
  :init
  (setq highlight-indent-guides-method 'character
        highlight-indent-guides-suppress-auto-error t)
  :config
  (defun +indent-guides-init-faces-h (&rest _)
    (when (display-graphic-p)
      (highlight-indent-guides-auto-set-faces)))

  ;; HACK `highlight-indent-guides' calculates its faces from the current theme,
  ;;      but is unable to do so properly in terminal Emacs, where it only has
  ;;      access to 256 colors. So if the user uses a daemon we must wait for
  ;;      the first graphical frame to be available to do.
  (add-hook 'doom-load-theme-hook #'+indent-guides-init-faces-h)
  (when doom-theme
    (+indent-guides-init-faces-h)))
#+END_SRC

** Programming :PROGRAMMING:
*** General Purpose
**** INACTIVE [[https://github.com/emacs-tree-sitter/elisp-tree-sitter][tree-sitter]] :EMACS:

***** Package

#+BEGIN_SRC emacs-lisp :tangle no
(package! tree-sitter)
(package! tree-sitter-langs)
#+end_src

***** Config

#+begin_src emacs-lisp :tangle no
(use-package! tree-sitter
  :config
  (require 'tree-sitter-langs)
  ;; (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src
**** [[https://github.com/chubin/cheat.sh][cheat-sh]] :CLI:

Community collection of snippets for command line tools.

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! cheat-sh)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package cheat-sh
  :commands (cheat-sh)
  :config
  (setq cheat-sh-topic-mode-map
        '((awk-mode . "awk")
          (c++-mode . "cpp")
          (c-mode . "c")
          (clojure-mode . "clojure")
          (clojurescript-mode . "clojure")
          (dockerfile-mode . "docker")
          (emacs-lisp-mode . "elisp")
          (fish-mode . "fish")
          (go-mode . "go")
          (haskell-mode . "haskell")
          (hy-mode . "hy")
          (java-mode . "java")
          (js-jsx-mode . "javascript")
          (js-mode . "javascript")
          (js-mode . "js")
          (lisp-interaction-mode . "elisp")
          (lisp-mode . "lisp")
          (objc-mode . "objectivec")
          (pike-mode . "pike")
          (powershell-mode . "powershell")
          (python-mode . "python")
          (rust-mode . "rust")
          (sh-mode . "bash")
          (nim-mode . "nim"))))
#+END_SRC
**** [[https://github.com/smihica/emmet-mode][emmet-mode]] :CSS:


***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! emmet-mode)
#+end_src

***** Functions
****** Indent or Yase Emmet Expand

Source: [[file:~/.emacs.d/modules/lang/web/autoload/html.el::defun +web/indent-or-yas-or-emmet-expand (][Doom: modules/lang/web/autoload/html.el]]

#+begin_src emacs-lisp
(defun my:emmet/indent-or-yas-or-emmet-expand ()
  "Do-what-I-mean on TAB.

Invokes `indent-for-tab-command' if at or before text bol, `yas-expand' if on a
snippet, or `emmet-expand-yas'/`emmet-expand-line', depending on whether
`yas-minor-mode' is enabled or not."
  (interactive)
  (call-interactively
   (cond ((or (<= (current-column) (current-indentation))
              (not (eolp))
              (not (or (memq (char-after) (list ?\n ?\s ?\t))
                       (eobp))))
          #'indent-for-tab-command)
         ((featurep! :editor snippets)
          (require 'yasnippet)
          (if (yas--templates-for-key-at-point)
              #'yas-expand
            #'emmet-expand-yas))
         (#'emmet-expand-line))))
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! emmet-mode
  :preface (defvar emmet-mode-keymap (make-sparse-keymap))
  :hook (css-mode web-mode html-mode haml-mode nxml-mode)
  :config
  (when (require 'yasnippet nil t)
    (add-hook 'emmet-mode-hook #'yas-minor-mode-on))
  (setq emmet-move-cursor-between-quotes t)
  (map! :map emmet-mode-keymap
        :v [tab] #'emmet-wrap-with-markup
        [tab] #'my:emmet/indent-or-yas-or-emmet-expand
        "M-E" #'emmet-expand-line))
#+END_SRC
**** [[https://elpa.gnu.org/packages/rainbow-mode.html][rainbow-mode]] :UI:

Pretty print colors string with the color as the background.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! rainbow-mode)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package rainbow-mode
  :commands (rainbow-mode)
  :config
  ;; Always enable rgb, etc colors
  (setq rainbow-html-colors t))
#+END_SRC
**** [[https://github.com/skeeto/impatient-mode][impatient-mode]] :BROWSER:

A live reload server directly in emacs for quickly editing css.
Launch using [[*Launch][my::impatient-mode|launch]].

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! impatient-mode)
#+END_SRC

***** Functions

****** Launch

#+begin_src emacs-lisp
(defun my::impatient-mode|launch ()
  "Launch server with impatient mode and open the browser."
  (interactive)
  (httpd-start)
  (impatient-mode)
  (let ((file-name (f-filename (+yank/buffer-filename))))
    (browse-url (t! "http://localhost:8080/imp/live/<<file-name>>"))))

(defun my::impatient-mode|stop ()
  "Launch server with impatient mode and open the browser."
  (interactive)
  (httpd-stop)
  (impatient-mode -1))
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! impatient-mode
  :commands impatient-mode)
#+END_SRC

*** Database :DATABASE:
**** Packages
***** TODO [[https://github.com/kiwanami/emacs-edbi][edbi]]

Emacs database layer interface

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! edbi)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! package)
#+END_SRC

****** Bridge

Add nix-shell headers to the bridge

Use with header ~:tangle "edbi-bridge.pl"~

#+BEGIN_SRC perl :tangle no
#! /usr/bin/env nix-shell
#! nix-shell -i perl -p mysql -p perlPackages.DBDmysql perlPackages.RPCEPCService perlPackages.DBDPg perlPackages.DBI

use strict;
use RPC::EPC::Service;
use Data::Dumper;
use DBI;

our $dbh = undef;
our $sth = undef;

sub edbi_connect {
  my ($args) = @_;
  my ($data_source,$username,$auth) = @$args;

  # No input _probably_ means "no password" rather than empty string
  $auth = undef if($auth eq "");

  if ($dbh) {
    eval {
      $dbh->disconnect();
    }
  }

  our $dbh = DBI->connect($data_source, $username, $auth)
      or die("Could not connect to database:
Data Source ($data_source)
User Name: ($username):
DBI error: ($DBI::errstr)
");

  return $dbh->get_info(18);
}

sub edbi_do {
  return undef unless $dbh;
  my ($args) = @_;
  my ($sql, $params) = @$args;
  my $rows = $dbh->do($sql, undef, @$params);
  return $rows;
}

sub edbi_select_all {
  return undef unless $dbh;
  my ($args) = @_;
  my ($sql, $params) = @$args;
  my $rows = $dbh->selectall_arrayref($sql, undef, @$params);  return $rows;
}

sub edbi_prepare {
  return undef unless $dbh;
  $sth->finish() if $sth;
  my ($sql) = @_;
  our $sth = $dbh->prepare($sql) or return undef;
  return 'sth';
}

sub edbi_execute {
  return undef unless $sth;
  my ($params) = @_;
  return $sth->execute(@$params) or return undef;
}

sub edbi_fetch_columns {
  return undef unless $sth;
  return $sth->{NAME};
}

sub edbi_fetch {
  return undef unless $sth;
  my ($num) = @_;
  if ($num eq undef) {
    return $sth->fetchall_arrayref();
  } else {
    my $ret = [];
    for (my $i = 0; $i < $num; $i++) {
      my $row = $sth->fetchrow_arrayref();
      last if $row eq undef;
      push @$ret, [@$row];
    }
    return $ret;
  }
}

sub edbi_auto_commit {
  return undef unless $dbh;
  my ($flag) = @_;
  if ($flag eq "true") {
    $dbh->{AutoCommit} = 1;
    return 1;
  } else {
    $dbh->{AutoCommit} = 0;
    return 0;
  }
}

sub edbi_commit {
  return undef unless $dbh;
  $dbh->commit();
  return 1;
}


sub edbi_rollback {
  return undef unless $dbh;
  $dbh->rollback();
  return 1;
}

sub edbi_disconnect {
  return undef unless $dbh;
  $dbh->disconnect();
  return 1;
}

sub edbi_status {
  return undef unless $dbh;
  return [$dbh->err, $dbh->errstr, $dbh->state];
}

sub edbi_type_info_all {
  return undef unless $dbh;
  my $ret = $dbh->type_info_all;
  print STDERR Dumper $ret;
  return $dbh->type_info_all;
}

sub edbi_table_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table, $type) = @$args;
  $sth = $dbh->table_info( $catalog, $schema, $table, $type );
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_column_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table, $column) = @$args;
  $sth = $dbh->column_info( $catalog, $schema, $table, $column );
  return [[],[]] unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_primary_key_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table) = @$args;
  $sth = $dbh->primary_key_info( $catalog, $schema, $table );
  return undef unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_foreign_key_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($pkcatalog, $pkschema, $pktable, $fkcatalog, $fkschema, $fktable) = @$args;
  $sth = $dbh->foreign_key_info( $pkcatalog, $pkschema, $pktable,
                                 $fkcatalog, $fkschema, $fktable );
  return undef unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub main {
  my $methods =
    {
     'connect' => [\&edbi_connect,"data_source, username, auth", ""],
     'do' => [\&edbi_do, "sql, params", ""],
     'select-all' => [\&edbi_select_all, "sql, params", ""],
     'prepare' => [\&edbi_prepare, "sql", ""],
     'execute' => [\&edbi_execute, "params", ""],
     'fetch-columns' => [\&edbi_fetch_columns, "", ""],
     'fetch' => [\&edbi_fetch, "[number]", ""],
     'auto-commit' => [\&edbi_auto_commit, "false/true", ""],
     'commit' => [\&edbi_commit, "", ""],
     'rollback' => [\&edbi_rollback, "", ""],
     'disconnect' => [\&edbi_disconnect, "", ""],
     'status' => [\&edbi_status, "", ""],
     'type-info-all' => [\&edbi_type_info_all, "", ""],
     'table-info' => [\&edbi_table_info, "catalog, schema, table, type", ""],
     'column-info' => [\&edbi_column_info, "catalog, schema, table, column", ""],
     'primary-key-info' => [\&edbi_primary_key_info, "catalog, schema, table", ""],
     'foreign-key-info' => [\&edbi_foreign_key_info, "pk_catalog, pk_schema, pk_table, fk_catalog, fk_schema, fk_table", ""],
    };
    my $server = RPC::EPC::Service->new(0, $methods);
    $server->start;
}

main;

#+END_SRC

#+BEGIN_SRC elisp
(after! edbi
  (setq edbi:driver-info
        (list
         "nix-shell" "-p"
         "perl"
         "-p" "perlPackages.DBI"
         "-p" "perlPackages.RPCEPCService"
         "-p" "perlPackages.DBDPg"
         "-p" "perlPackages.DBDmysql"
         "--run"
         (f-join doom-private-dir "edbi-bridge.pl"))))
#+END_SRC

*** Javascript :JAVASCRIPT:
**** Packages :PACKAGE:
***** [[https://github.com/aaronjensen/eslintd-fix][eslintd-fix]] :LINTING:AUTOFIX:

A javascript auto-fixer that isn't slow.
Needs [[https://www.npmjs.com/package/eslint_d][eslint_d]] binary in ~$PATH~.

****** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! eslintd-fix)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! eslintd-fix
  :after js2-mode
  :config
  (setq
   flycheck-javascript-eslint-executable (executable-find "eslint_d")
   flycheck-disabled-checkers '(javascript-jshint javascript)))
#+END_SRC

****** Functions
******* Enable eslintd for writable buffers

#+begin_src elisp
(defun my:js/start-eslint ()
  "Start eslint on writable buffers.

When enabling on read-only buffers it will throw an error."
  (unless buffer-read-only
    (eslintd-fix-mode)))

(add-hook 'js2-mode-hook #'my:js/start-eslint)
#+end_src
***** [[https://github.com/floscr/js-import][floscr/js-import]] :AUTOFIX:FORK:

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! js-import :recipe (:host github :repo "floscr/js-import"))
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(put 'js-import-alias-map 'safe-local-variable (lambda (x) t))
#+END_SRC
***** [[https://github.com/Emiller88/emacs-jest][jest]] :FORK::UNIT_TESTING:

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! jest :recipe (:host github :repo "floscr/emacs-jest"))
#+END_SRC

****** Config

#+begin_src emacs-lisp
(use-package! jest
  :after (js2-mode)
  :hook (js2-mode . jest-minor-mode)
  :config
  (set-popup-rule! "^\\*jest\\*"
    :side 'right
    :size 0.5
    :select nil :quit 'current :ttl nil))
#+end_src

***** [[https://github.com/NicolasPetton/Indium][indium]]

A JavaScript development environment for Emacs.

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! indium)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! indium
  :commands (indium-connect indium-launch)
  :init
  (setq indium-chrome-use-temporary-profile t)
  (setq indium-chrome--default-data-dir (f-join (getenv "XDG_CACHE_HOME") "inidum-chrome-profile"))
  (setq indium-chrome-data-dir (f-join (getenv "XDG_CACHE_HOME") "inidum-chrome-profile"))
  (map! :map (js2-mode-map rjsx-mode-map)
        :localleader
        (:prefix ("i" . "Indium")
          :desc "Console"                   "c" #'indium-switch-to-repl-buffer
          :desc "Launch"                    "l" #'indium-launch
          :desc "Launch"                    "q" #'indium-quit
          :desc "Add breakpoint"            "r" #'indium-reload
          (:prefix ("b" . "breakpoint")
            :desc "Add"                     "b" #'indium-add-breakpoint
            :desc "Conditional"             "c" #'indium-add-conditional-breakpoint
            :desc "Conditional"             "e" #'indium-edit-breakpoint-condition
            :desc "Conditional"             "l" #'indium-list-breakpoints
            :desc "Conditional"             "0" #'indium-deactivate-breakpoints
            :desc "Conditional"             "1" #'indium-activate-breakpoints
            :desc "Delete"                  "d" #'indium-remove-breakpoint
            :desc "Delete all from buffer"  "D" #'indium-remove-all-breakpoints-from-buffer
            :desc "Edit Condition"          "e" #'indium-toggle-breakpoint
            :desc "Toggle"                  "t" #'indium-toggle-breakpoint)))
  (map!
        :map indium-inspector-mode-map
        :n "-" #'indium-inspector-pop)
  (map! :map indium-debugger-mode-map
        :n "gr" #'indium-debugger-resume
        :n "gi" #'indium-debugger-step-into
        :n "go" #'indium-debugger-step-over
        :n "ge" #'indium-debugger-evaluate
        :n "gl" #'indium-debugger-locals)
  :config
  (set-popup-rule! "^\\*JS REPL*" :size 0.3)
  (set-popup-rule! "^\\*JS Debugger Locals*" :size 0.3))
#+END_SRC
***** [[https://github.com/mojochao/npm-mode][npm]]

****** Functions
******* Add CI command

No namespace here, so it matches the other commmands

#+BEGIN_SRC elisp
(defun npm-mode-npm-ci ()
  "Run the 'npm install' command."
  (interactive)
  (npm-mode--exec-process "npm ci"))
#+END_SRC
***** [[https://github.com/vermiculus/graphql.el][graphql]]
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! graphql)
#+END_SRC

**** Functions
***** Match const function name

#+BEGIN_SRC elisp
(defun my::javascript/match-const-function-name (line)
  "Matches a line to the word after the declaration"
  (nth 2 (s-match
          "\\(const\\|let\\|class\\)\s\\(.+?\\)\s"
          line)))

(defun my::javascript/const-function-at-point ()
  "Returns the current function name at the current line"
  (my::javascript/match-const-function-name (thing-at-point 'line t)))
#+END_SRC

*** Emacs Lisp (Elisp) :ELISP:
**** Packages
***** [[https://github.com/countvajhula/symex.el][symex]]

An evil way to edit Lisp symbolic expressions (symexes) as trees in Emacs

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! symex)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! symex
  :commands (symex-mode symex-mode-interface))
#+END_SRC
**** Config

***** Remove Rainbow Delimiters

I don't need them with parinfer and lispyville, they're just distracting.

#+begin_src elisp
(remove-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
#+end_src

*** Json :JSON:
**** Functions
***** Is Last JSON key at point

#+BEGIN_SRC elisp
(defun my::json/is-last-key? ()
  "Is the next line the last json key."
  (save-excursion
    (forward-line)
    (my::buffer/line-contains "}")))
#+END_SRC

***** Insert JSON Key

Insert JSON key in a JSON document
This functions is dependant on the yasnippet: [[file:snippets/json-mode/key::# --][key]]

#+BEGIN_SRC elisp
(defun my::json/insert-key (&optional above?)
  "Adds a new JSON key pair."
  (let ((last-line? (my::buffer/line-contains ",$")))
    ;; Insert comma
    (if (and (not last-line?) (not above?))
        (replace-regexp "$" "," nil (point-at-bol) (point-at-eol)))
    (end-of-line)
    (if above?
        (evil-insert-newline-above)
      (evil-insert-newline-below))
    (indent-according-to-mode)
    (my::snippets/insert-by-name "key")))

(defun my::json|insert-key-above ()
  "Function docstring"
  (interactive)
  (my::json/insert-key t))

(defun my::json|insert-key-below ()
  "Function docstring"
  (interactive)
  (my::json/insert-key nil))
#+END_SRC

***** Autofix JSON

Uses [[https://www.npmjs.com/package/json-fix][json-fix]] to autofix JSON files.

#+BEGIN_SRC bash :tangle no
npm i -g json-fix
#+END_SRC

#+BEGIN_SRC elisp
(defun my::json|autofix-buffer ()
  "Autofix json buffer"
  (interactive)
  (let ((b (if mark-active (min (point) (mark)) (point-min)))
        (e (if mark-active (max (point) (mark)) (point-max))))
    (shell-command-on-region b e
     (template "json-fix --no-sort --spaces <<tab-width>>") (current-buffer) t)))
#+END_SRC
**** Bindings

#+BEGIN_SRC elisp
(map!
 :after json-mode
 :map json-mode-map
 :gni "<C-return>" #'my::json|insert-key-below
 :gni "<C-S-return>" #'my::json|insert-key-above)
#+END_SRC
***** Functions
***** Export default variable

#+BEGIN_SRC elisp
(defun js2r-export-default ()
  "Exports the current declaration at the end of the file"
  (interactive)
  (save-excursion
    (let* ((name (my::javascript/const-function-at-point)))
      (goto-char (point-max))
      (insert "\n")
      (insert (template "export default <<name>>;")))))
#+END_SRC

***** Extract constant to file

Extract the ~const~ under the cursor into a new file.

#+BEGIN_SRC elisp
(defun js2r-extract-const-to-file ()
  "Extracts function to external file"
  (interactive)
  (let* ((name (my::javascript/const-function-at-point))
         (path (concat "./" name ".js")))
    (evil-digit-argument-or-evil-beginning-of-line)
    (js2r-kill)
    (f-write-text "" 'utf-8 path)
    (find-file path)
    (yank)))
#+END_SRC

***** Generate ~index.js~ file index

Generate a file index in the current file for every other file in the current directory.

#+BEGIN_SRC elisp
(defun +js/index-file-names (&optional dir)
  "Get filenames from current buffers directory."
  (let ((fs (directory-files (or dir default-directory) nil ".*\\.js")))
    (mapcar 'f-no-ext
            (remove "index.js" fs))))

(defun +js|generate-index (&optional dir ignore-list is-old-es-style)
  "Generate an index import file for files in directory.
Pass DIR for directory, falls back to default-directory
Pass IGNORE-LIST for a list of files
Pass IS-OLD-ES-STYLE for using the non-esm style exports"
  (interactive)
  (erase-buffer)
  (let* ((dir (or dir default-directory))
         (fs (->>
              (+js/index-file-names dir)
              (-log)
              (--reject (s-ends-with-p ".test" it))
              (--when ignore-list (--remove (-contains? ignore-list it) it)))))
    (message "%s" fs)
    (cond (is-old-es-style
           (progn
             (mapc (lambda (f) (insert "import " f " from './" f "';\n")) fs)
             (insert "\n")
             (insert "export default {\n")
             (mapc (lambda (f) (insert "    " f ",\n")) fs)
             (insert "};")))
          (t
           (mapc (lambda (f) (insert "export { default as " f " } from './" f "';\n")) fs)))))
#+END_SRC

***** Convert expression into template string

Converts an expression into a template string.

Example:
When you would call the function on the ~foo~ inside the console.log,
It would wrap it like this ~console.log(`${foo}`)~.

#+BEGIN_SRC elisp
(defun +js|convert-sexp-to-template-string ()
  "Wrap sexp into a template string"
  (interactive)
  (kill-sexp)
  (insert (concat "`${" (substring-no-properties (car kill-ring)) "}`"))
  (pop kill-ring))
#+END_SRC

***** Split / Join JSX Tag Node

Stolen from the vscode extension: [[https://github.com/dannyconnell/vscode-split-html-attributes][dannyconnell/vscode-split-html-attributes]]
I don't want to translate this to elisp, and js works as well.

Split/Joins a JSX tags by seperating the attributes

#+BEGIN_SRC js :tangle "./.cache/split-join-tag.js"
const useSpacesForTabs = true;
const tabSize = 4;
const sortOrder = [];
const closingBracketOnNewLine = true;

let input = process.argv[2]

// count the number of lines initally selected
let lineCount = input.split('\n').length
let lineText = input

// get the initial white space at the start of the line
let initialWhitespaceRegex = /\s*/i
let initialWhitespace = lineText.match(initialWhitespaceRegex)[0]

// get the opening tag
let openingTagRegex = /^[^\s]+/
let openingTag = input.match(openingTagRegex)[0]

// remove opening tag and trim
input = input.replace(openingTagRegex, '')
input = input.trim()

// get the ending bracket (if it's a "/>")
let endingBracket = ''
if (input.endsWith('/>')) {
    endingBracket = '/>'
}
else {
    endingBracket = '>'
}

// remove ending bracket and trim
if (endingBracket == '/>') {
    input = input.replace('/>', '')
}
else {
    input = input.substring(0, input.length - 1)
}
input = input.trim()

// create the indentation string
let indentationString
if (useSpacesForTabs == false) {
    indentationString = '\t'
}
else {
    indentationString = ' '.repeat(tabSize)
}

// regex to select all spaces that aren't within quotes
let spacesRegex = /\s+(?=([^"]*"[^"]*")*[^"]*$)/g

// get attributes into an array
let attributesString = input.replace(spacesRegex, '\n')
let attributesArray = attributesString.split('\n')

// sort the attributes array
let sortedAttributesArray = []
if (sortOrder.length) {

    // loop through sortOrder array
    sortOrder.forEach(search => {
        // loop through attributesArray
        let itemsToMove = []
        attributesArray.forEach((item, index) => {
            if (item.match(search)) {
                itemsToMove.push(index)
                // attributesArray.splice(index, 1)
            }
        })
        // move matched items from attributesArray to sortedAttributesArray (and sort them)
        let tempMatchedItems = []
        itemsToMove.forEach(indexItem => {
            tempMatchedItems.push(attributesArray[indexItem])
        })
        tempMatchedItems.sort()
        sortedAttributesArray.push(...tempMatchedItems)

        // remove matched items from attributesArray
        for (var i = itemsToMove.length - 1; i >= 0; --i) {
            attributesArray.splice(itemsToMove[i], 1)
        }
    })

    // sort remaining attributes and add to sortedAttributesArray
    attributesArray.sort()
    sortedAttributesArray.push(...attributesArray)
}
else {
    sortedAttributesArray = attributesArray
}

// add the opening tag
let result = openingTag

// set the join character based on number of lines initially selected
// (newLine if one line, space if more)
let joinCharacter = lineCount > 1 ? ' ' : '\n'

// if there are no attributes, set joinCharacter to ''
if (sortedAttributesArray.length == 1 && sortedAttributesArray[0] == '') {
    joinCharacter = ''
}

// add the sorted attributes to the textSplit string
if (lineCount > 1) {
    sortedAttributesArray.forEach(item => {
        result += joinCharacter + item
    })
}
else {
    sortedAttributesArray.forEach(item => {
        result += joinCharacter + initialWhitespace + indentationString + item
    })
}

// configure ending bracket (new line or not new line)
if (lineCount > 1) {
    if (endingBracket == '/>') {
        endingBracket = ' ' + endingBracket
    }
}
else {
    if (closingBracketOnNewLine) {
        endingBracket = '\n' + initialWhitespace + endingBracket
    }
    else if (endingBracket == '/>') {
        endingBracket = ' ' + endingBracket
    }
}

// add the ending bracket
result = result + endingBracket

console.log(result)
#+END_SRC

#+BEGIN_SRC elisp
(defun +rjsx/find-opening-closing-tag ()
  "Return the opening and closing carent character positions for a tag under the cursor."
  (save-excursion
    (let* ((is-evil-normal-state (evil-normal-state-p))
           (opening
            (or (-some->> (rjsx--tag-at-point)
                  (js2-node-abs-pos))
                ;; Fallback when js2-node-abs-pos parser fails
                (save-excursion (search-backward "<"))))
           (closing (progn
                      (when is-evil-normal-state
                        (evil-insert-state))
                      (while (and
                              (re-search-forward "[^=]>" (point-max) t nil)
                              (progn (backward-char 1) t)
                              (rjsx--tag-at-point)
                              (not (eq (js2-node-abs-pos (rjsx--tag-at-point)) opening))
                              (progn (forward-char 1) t)))
                      (when is-evil-normal-state
                        (evil-normal-state))
                      (forward-char 2)
                      (point))))
      (cons opening closing))))

(defun +rjsx/split-join ()
  "Function docstring"
  (interactive)
  (when (eq ?> (char-after))
    (backward-char 1))
  (-let* ((bounds (cond
                   ((use-region-p) (cons (region-beginning) (region-end)))
                   (t (+rjsx/find-opening-closing-tag))))
          ((beg . end) bounds)
          (input (->> (buffer-substring-no-properties beg end)
                   (s-replace "\n" "\\n")
                   (s-replace "'" "\\'")))
          (output (->> (shell-command-to-string (t! "node <<doom-private-dir>>/.cache/split-join-tag.js  $'<<input>>'"))
                    (s-trim-right))))
    (delete-region beg end)
    (insert output)
    (indent-region beg
                   ;; End position might be filled by whitespace, so we search again for the ending carent
                   (save-excursion (progn
                                     (goto-char (cdr (+rjsx/find-opening-closing-tag))))))))
#+END_SRC

***** Expand self closing tag

Converts self closing JSX tags to closing tags.
~<Foo />~ -> ~<Foo>|</Foo>~

#+BEGIN_SRC elisp
(defun +rjsx|expand-insert-self-closing-tag ()
  "Opens the current tag at any position of the cursor and starts insert mode"
  (interactive)
  (search-forward "/>")
  (evil-backward-char)
  (call-interactively #'delete-backward-char)
  (call-interactively #'rjsx-electric-gt)
  (newline)
  (call-interactively #'evil-indent-line)
  (call-interactively #'evil-open-above))
#+END_SRC

***** Extract Props from function arguments to body

#+BEGIN_SRC elisp
(defun +js|extract-props ()
  "Extract props object under the cursor."
  (interactive)
  (save-excursion
    (let* ((point-start (search-backward "{"))
           (point-end (search-forward "}"))
           (text (buffer-substring-no-properties point-start point-end)))
      (delete-region point-start point-end)
      (insert "props")
      (evil-open-below 1)
      (insert (template "const <<text>> = props;"))
      (search-backward "}")
      (js2r-expand-node-at-point)))
  (evil-normal-state))
#+END_SRC

***** Company Files

Remove the ~js~ extension for ~company-files~.

#+BEGIN_SRC elisp :tangle no
(defun company-js-files (command &optional arg &rest ignored)
  "Company complete path. Remove extension after completion"
  (interactive (list 'interactive))
  (require 'company)
  (cl-case command
    (interactive (company-begin-backend 'company-js-files))
    (prefix (company-files--grab-existing-name))
    (candidates (company-files--complete arg))
    (location (cons (dired-noselect
                     (file-name-directory (directory-file-name arg))) 1))
    (post-completion (when (s-matches? "\.js$" arg) (delete-backward-char 3)))
    (sorted t)
    (no-cache t)))

(map! :map js2-mode-map
      :i "C-x C-f" #'company-js-files)
#+END_SRC

***** Import JS File

#+BEGIN_SRC elisp :tangle no
(defun +js/import-file (file)
  (let ((cursor-postion (point))
        (filename (f-no-ext file)))
    (insert (template "import  from '<<filename>>';"))
    (goto-char cursor-postion)
    (forward-char 7)
    (evil-insert-state)))

(defun +js|ivy-import-file (&optional action)
  (interactive)
  (let* ((local-files
          (-->
           (-concat (list find-program) counsel-file-jump-args)
           (string-join it " ")
           shell-command-to-string
           split-string))
         (node-packages
          (-->
           (concat "jq -r '.dependencies | keys | .[]' " (concat (projectile-project-root) "package.json"))
           shell-command-to-string
           split-string))
         (imports (append local-files node-packages)))
    (ivy-read "Import file " imports :action (or action '+js/import-file))))
 #+END_SRC

***** Switch Ternary

#+BEGIN_SRC elisp
(defun js2r-ternary-switch-statements ()
  "Switch expressions in a ternary."
  (interactive)
  (js2r--guard)
  (js2r--wait-for-parse
   (save-excursion
     (let* ((ternary (js2r--closest 'js2-cond-node-p))
            (test-expr (js2-node-string (js2-cond-node-test-expr ternary)))
            (true-expr (js2-node-string (js2-cond-node-true-expr ternary)))
            (false-expr (js2-node-string (js2-cond-node-false-expr ternary)))
            (stmt (js2-node-parent-stmt ternary))
            (stmt-pre (buffer-substring (js2-node-abs-pos stmt) (js2-node-abs-pos ternary)))
            (stmt-post (s-trim (buffer-substring (js2-node-abs-end ternary) (js2-node-abs-end stmt))))
            (beg (js2-node-abs-pos stmt)))
       (goto-char beg)
       (delete-char (js2-node-len stmt))
       (insert "return " test-expr)
       (newline)
       (insert "? " false-expr)
       (newline)
       (insert ": " true-expr ";")
       (indent-region beg (point))))))
#+END_SRC

***** Ignore Flycheck error on line

#+BEGIN_SRC elisp
(defun +js|eslint-fix-ignore-error ()
  "Adds an ignore with the current flycheck error."
  (interactive)
  (if-let ((error-id (flycheck-copy-errors-as-kill (point) #'flycheck-error-id)))
    (save-excursion
      (previous-line)
      (end-of-line)
      (newline-and-indent)
      (insert (template "// eslint-disable-next-line <<error-id>>")))))
#+END_SRC
***** Find file from package.json root

#+BEGIN_SRC elisp
(defun +javscript|package-root-files ()
  "Find any file relative to the upmost package.json,
useful for repos that contain multiple packages."
  (interactive)
  (let ((default-directory
          (f--traverse-upwards (f-exists? (f-expand "package.json" it)))))
    (+default/find-file-under-here)))
#+END_SRC


***** Find node_modules package

Go to a package from the node_modules directory.

#+BEGIN_SRC elisp
(defun +javascript/find-npm-package-goto (package)
  "Go to directory by package name"
  (-some->> (f-join (projectile-project-root) "node_modules")
    (-id-when #'f-exists?)
    (-f-join package)
    (find-file)))

(defun +javascript|find-npm-package ()
  "Find package in node_modules directory."
  (interactive)
  (-when-let* ((json (-some->> (f-join (projectile-project-root) "package.json")
                       (-id-when #'f-exists?)
                       (json-read-file)))
               ((&alist 'dependencies dependencies
                        'devDependencies devDependencies) json)
               (packages (->> (-concat dependencies devDependencies)
                              (-map #'car))))
    (ivy-read "Go to package directory: " packages
              :action #'+javascript/find-npm-package-goto)))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after js2-mode
 :map js2-mode-map
 :desc "Goto parent function" :n "gh" (cmd! (js2-beginning-of-defun))
 :localleader
 :desc "Goto NPM Package" "m" #'+javascript|find-npm-package
 :desc "Package Root Files" "SPC" #'+javscript|package-root-files
 (:prefix-map ("c" . "Create")
  :desc "Import File" "i" #'js-import))

(map!
 :after rjsx-mode
 :map rjsx-mode-map
 :localleader
 (:desc "Open Self-Closing Tag" :n ">" #'+rjsx|expand-insert-self-closing-tag)
 (:desc "Rename Tag" :n "," #'rjsx-rename-tag-at-point)
 (:desc "Collapse/Expand Tag" :n "<" #'+rjsx/split-join))
#+END_SRC

***** Evil Function Text Object Motion

Adds text objects for functions in javascript.
So you can press ~daf~ to delete a function.

#+BEGIN_SRC elisp
(add-hook! js-mode
  (require 'evil-text-objects-javascript)
  (evil-text-objects-javascript/install))
#+END_SRC

***** Evil Method Text Object Motion

Overwrite ~evil-text-objects-javascript~ to also accepts methods.

I mainly changed the function marking helper.

#+BEGIN_SRC diff :tangle no
- (call-interactively #'mark-defun)
+ (call-interactively #'js2-mark-defun)
#+END_SRC

#+BEGIN_SRC elisp
(after! evil-text-objects-javascript
  (evil-define-text-object
    evil-inner-javascript-function (count &optional beg end type)
    "inner text object for all javascript functions."
    (call-interactively #'js2-mark-defun)
    (narrow-to-region (region-beginning) (region-end))
    (goto-char (point-min))
    (let* ((beg (save-excursion
                  (search-forward "(")
                  (backward-char)
                  (evil-jump-item)
                  (search-forward-regexp "[({]")
                  (point)))
           (end (save-excursion
                  (goto-char beg)
                  (evil-jump-item)
                  (point))))
      (evil-range beg end type)))

  (evil-define-text-object
    evil-outer-javascript-function (count &optional beg end type)
    "Outer text object for all Javascript functions."
    (call-interactively #'js2-mark-defun)
    (narrow-to-region (region-beginning) (region-end))
    (goto-char (point-min))
    (let* ((beg (save-excursion
                  (when (looking-at "[[:space:]]")
                    (evil-forward-word-begin))
                  (point)))
           (end (save-excursion
                  (goto-char beg)
                  (search-forward "(")
                  (backward-char)
                  (evil-jump-item)
                  (search-forward-regexp "[({]")
                  (evil-jump-item)
                  (forward-char)
                  (if (save-excursion
                        (progn
                          (forward-char)
                          (when (looking-at ",") (point))))
                    (point)))))
      (evil-range beg end type))))
#+END_SRC
*** Nix :NIXOS:NIX:
**** Packages
***** Nixpkgs Fmt :AUTOFIX:
****** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! nixpkgs-fmt)
#+END_SRC

****** Config

#+begin_src elisp
(use-package nixpkgs-fmt
  :after nix-mode
  :config
  (setq nixpkgs-fmt-on-save-mode t)
  :init
  (add-hook! nix-mode #'nixpkgs-fmt-on-save-mode))
#+end_src
**** Functions
***** Edit indirect

Edit nix script regions in an indirect buffer just like ~org-edit-special~.

#+BEGIN_SRC elisp
(defun my::nixos/edit-indirect ()
  "Edit script in an indirect buffer."
  (interactive)
  (and-let* ((beg (save-excursion
                    (search-backward "''\n" nil t)
                    (forward-char 3)
                    (point)))
             (end (save-excursion
                    (re-search-forward "''" nil t)
                    (previous-line 1)
                    (goto-char (point-at-eol))
                    (point))))
    (+indirect-indent|edit beg end #'sh-mode)))

(map! :map nix-mode-map "C-c '" 'my::nixos/edit-indirect)

(set-popup-rule! "^\\*edit-indirect" :ignore t)
#+END_SRC

*** Haskell :HASKELL:
***** Functions
****** Autofix with [[https://hackage.haskell.org/package/brittany][brittany]] :AUTOFIX:

#+begin_src elisp
(defun my::haskell|autofix ()
  "Function formats haskell buffer with brittany on save."
  (interactive)
  (when (eq major-mode 'haskell-mode)
    (shell-command-to-string (format "brittany --config-file .brittany.yaml --write-mode inplace %s" buffer-file-name))
    (revert-buffer :ignore-auto :noconfirm)
    (haskell-mode-stylish-buffer)
    (save-buffer)))
#+end_src
*** Markdown :MARKDOWN:
**** Config

#+BEGIN_SRC elisp
(use-package! markdown-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.mdx\\'" . markdown-mode))
  (setq markdown-fontify-code-blocks-natively t)
  :config
  (add-hook! markdown-mode
    (hl-line-mode -1)
    (visual-line-mode)
    (visual-fill-column-mode)
    (outline-minor-mode)
    (setq visual-fill-column-width 90
          display-line-numbers nil)
    (setq line-spacing 2
          fill-column 80)))
#+END_SRC
**** Bindings

#+begin_src elisp
(map! (:map markdown-mode-map
       :n "<"    #'markdown-promote
       :n ">"    #'markdown-demote))
#+end_src
*** Nim :NIM:
**** Packages
***** [[https://github.com/SerialDev/inim-mode][inim-mode]]

Nim Repl Support.
Needs inim installed from nimble.

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! inim :recipe (:host github :repo "SerialDev/inim-mode"))
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! package)
#+END_SRC
**** Functions
***** Import Nim Package

Finds packages either from nims std lib or your nim packages.

- Requires evil for inserting
- Requires ~$NIM_UNWRAPPED_DIR~ to be set to nims source repository on your disk
- Searches for nimble dir in either ~$NIMBLE_DIR~ or your users home directory

To set a nimble directory via nix shell add this snippet:

#+begin_src nix :tangle no
{ pkgs, packages, nimpkgs, buildInputs }:

pkgs.mkShell {
  shellHook = ''
    export NIMBLE_DIR="$PWD/.nimble"
  '';
};
#+end_src

#+begin_src elisp
(defun my::nim|import/add-std-import-statement (import)
  "Insert stdlib import below last stdin statement."
  (goto-char (point-max))
  (cond ((search-backward-regexp "^import std/.+$" 0 t)
         (evil-insert-newline-below))
        ((goto-char (point-min)) (evil-insert-newline-above)))
  (insert (t! "import std/<<import>>")))

(defun my::nim|import/add-lib-import-statement (import)
  "Insert package import below all import statements."
  (goto-char (point-max))
  (cond ((search-backward-regexp "^import .+$" 0 t)
         (evil-insert-newline-below))
        ((goto-char (point-min)) (evil-insert-newline-above)))
  (insert (t! "import <<import>>")))

(defun my::nim|import ()
  "Add import from nims stdlib or your nimble packages."
  (interactive)
  (let* ((nim-src-dir (-some->> (getenv "NIM_UNWRAPPED_DIR")
                        (-f-join "nim/lib/pure")
                        (-id-when #'f-exists?)))
         (libs (->> (f-entries nim-src-dir (lambda (x) (f-ext? x "nim")) t)
                    (--map (->> (f-relative it nim-src-dir)
                                (f-no-ext)
                                ((lambda (x) (cons x 'libs)))))))
         (nim-deps-dir (-some->> (or (getenv "NIMBLE_DIR")
                                     (f-expand "~/.nimble"))
                         (-f-join "pkgs")
                         (-id-when #'f-exists?)))
         (deps (->> (f-directories nim-deps-dir)
                    (--map (-some->>
                               (f-files it (lambda (x) (f-ext? x "nim")))
                             (car)
                             (f-base)
                             (s-replace-regexp "-[0-9\\.]+$" "")
                             ((lambda (x) (cons x 'deps))))))))
    (ivy-read "Import: " (-concat libs deps)
              :action (lambda (import)
                        (save-excursion
                          (pcase import
                            (`(,x . deps) (my::nim|import/add-lib-import-statement x))
                            (`(,x . libs) (my::nim|import/add-std-import-statement x))))))))
#+end_src
***** Flycheck for ~v.1.6.0~

Nim has different output for v1.6.0 for linting, so this broke flycheck

The error output for 1.6.0 is

#+BEGIN_QUOTE
FILENAME:3:8 Hint: duplicate import of 'osproc'; previous import here: FILENAME:1:8 [DuplicateModuleImport]
FILENAME:73:14 Error: expression 'getCacheDir()' is of type 'string' and has to be used (or discarded)
#+END_QUOTE

#+begin_src elisp
(after! nim-mode
  (flycheck-define-checker nim-1-6-0
    "A syntax checker for the nim programming language.
v1.6.0 has a different output style than previously

See http://nim-lang.org"
    :command ("nim" "check"
              (option-flag "--experimental" flycheck-nim-experimental)
              (option-flag "--threads:on" flycheck-nim-threads)
              (option "--hints:" flycheck-nim-hints concat)
              (option "--warnings:" flycheck-nim-warnings concat)
              (eval (--map (format "--hint[%s]:%s" (car it) (cadr it))
                           flycheck-nim-specific-hints))
              (eval (--map (format "--warning[%s]:%s" (car it) (cadr it))
                           flycheck-nim-specific-warnings))
              (eval flycheck-nim-args)
              ;; Must use source-inplace so relative imports and
              ;; qualified references to local variables resolve correctly
              source-inplace)
    :error-patterns
    ((error line-start (file-name) ":" line ":"
            column " Error:"
            (message (one-or-more not-newline)
                     (optional
                      (and "\nbut expected one of:"
                           (minimal-match (one-or-more anything)) "\n\n"))))
     (warning line-start (file-name) ":" line ":"
              column " " (or "Hint:" "Warning:") (message) line-end))
    :error-filter
    (lambda (errors)
      (flycheck-sanitize-errors (flycheck-increment-error-columns errors)))
    :modes (nim-mode nimrod-mode)
    :predicate (lambda () (not org-src-mode)))

  (add-to-list 'flycheck-checkers 'nim-1-6-0))
#+end_src
***** TODO Nimpretty

#+begin_src elisp
(defcustom nimpretty-command "nimpretty"
  "The 'nimpretty' command."
  :type 'string
  :group 'nim)

(defcustom nimpretty-show-errors 'buffer
  "Where to display nimpretty error output.
It can either be displayed in its own buffer, in the echo area, or not at all.

Please note that Emacs outputs to the echo area when writing
files and will overwrite nimpretty's echo output if used from inside
a `before-save-hook'."
  :type '(choice
          (const :tag "Own buffer" buffer)
          (const :tag "Echo area" echo)
          (const :tag "None" nil))
  :group 'nim)

(defcustom nimpretty-args nil
  "Additional arguments to pass to nimpretty."
  :type '(repeat string)
  :group 'nim)

(defun nim--goto-line (line)
  (goto-char (point-min))
  (forward-line (1- line)))

(defalias 'nim--make-nearby-temp-file
  (if (fboundp 'make-nearby-temp-file) #'make-nearby-temp-file
    (lambda (prefix &optional dir-flag suffix)
      (let ((temporary-file-directory (nim--temporary-file-directory)))
        (make-temp-file prefix dir-flag suffix)))))

(defalias 'nim--temporary-file-directory
  (if (fboundp 'temporary-file-directory) #'temporary-file-directory
    (lambda ()
      (let ((remote (file-remote-p default-directory)))
        (if remote
            ;; Assume that /tmp is a temporary directory on the remote host.
            ;; This won’t work on Windows.
            (concat remote "/tmp")
          temporary-file-directory)))))

(defalias 'nim--file-local-name
  (if (fboundp 'file-local-name) #'file-local-name
    (lambda (file) (or (file-remote-p file 'localname) file))))

(defun nimpretty--kill-error-buffer (errbuf)
  (let ((win (get-buffer-window errbuf)))
    (if win
        (quit-window t win)
      (kill-buffer errbuf))))

(defun nimpretty--process-errors (filename tmpfile errbuf)
  (with-current-buffer errbuf
    (if (eq nimpretty-show-errors 'echo)
        (progn
          (message "%s" (buffer-string))
          (nimpretty--kill-error-buffer errbuf))
      ;; Convert the nimpretty stderr to something understood by the compilation mode.
      (goto-char (point-min))
      (insert "nimpretty errors:\n")
      (let ((truefile tmpfile))
        (while (search-forward-regexp
                (concat "^\\(" (regexp-quote (nim--file-local-name truefile))
                        "\\):")
                nil t)
          (replace-match (file-name-nondirectory filename) t t nil 1)))
      (compilation-mode)
      (display-buffer errbuf))))

(defun nim--delete-whole-line (&optional arg)
  "Delete the current line without putting it in the `kill-ring'.
Derived from function `kill-whole-line'.  ARG is defined as for that
function."
  (setq arg (or arg 1))
  (if (and (> arg 0)
           (eobp)
           (save-excursion (forward-visible-line 0) (eobp)))
      (signal 'end-of-buffer nil))
  (if (and (< arg 0)
           (bobp)
           (save-excursion (end-of-visible-line) (bobp)))
      (signal 'beginning-of-buffer nil))
  (cond ((zerop arg)
         (delete-region (progn (forward-visible-line 0) (point))
                        (progn (end-of-visible-line) (point))))
        ((< arg 0)
         (delete-region (progn (end-of-visible-line) (point))
                        (progn (forward-visible-line (1+ arg))
                               (unless (bobp)
                                 (backward-char))
                               (point))))
        (t
         (delete-region (progn (forward-visible-line 0) (point))
                        (progn (forward-visible-line arg) (point))))))

(defun nim--apply-rcs-patch (patch-buffer)
  "Apply an RCS-formatted diff from PATCH-BUFFER to the current buffer."
  (let ((target-buffer (current-buffer))
        ;; Relative offset between buffer line numbers and line numbers
        ;; in patch.
        ;;
        ;; Line numbers in the patch are based on the source file, so
        ;; we have to keep an offset when making changes to the
        ;; buffer.
        ;;
        ;; Appending lines decrements the offset (possibly making it
        ;; negative), deleting lines increments it. This order
        ;; simplifies the forward-line invocations.
        (line-offset 0)
        (column (current-column)))
    (save-excursion
      (with-current-buffer patch-buffer
        (goto-char (point-min))
        (while (not (eobp))
          (unless (looking-at "^\\([ad]\\)\\([0-9]+\\) \\([0-9]+\\)")
            (error "Invalid rcs patch or internal error in nim--apply-rcs-patch"))
          (forward-line)
          (let ((action (match-string 1))
                (from (string-to-number (match-string 2)))
                (len  (string-to-number (match-string 3))))
            (cond
             ((equal action "a")
              (let ((start (point)))
                (forward-line len)
                (let ((text (buffer-substring start (point))))
                  (with-current-buffer target-buffer
                    (cl-decf line-offset len)
                    (goto-char (point-min))
                    (forward-line (- from len line-offset))
                    (insert text)))))
             ((equal action "d")
              (with-current-buffer target-buffer
                (nim--goto-line (- from line-offset))
                (cl-incf line-offset len)
                (nim--delete-whole-line len)))
             (t
              (error "Invalid rcs patch or internal error in nim--apply-rcs-patch")))))))
    (move-to-column column)))

(defun nimpretty ()
  "Format the current buffer according to the formatting tool.

The tool used can be set via ‘nimpretty-command’ (default: nimpretty) and additional
arguments can be set as a list via ‘nimpretty-args’."
  (interactive)
  (let ((tmpfile (nim--make-nearby-temp-file "nimpretty" nil ".nim"))
        (patchbuf (get-buffer-create "*Nimpretty patch*"))
        (errbuf (if nimpretty-show-errors (get-buffer-create "*Nimpretty Errors*")))
        (coding-system-for-read 'utf-8)
        (coding-system-for-write 'utf-8)
        our-nimpretty-args)

    (unwind-protect
        (save-restriction
          (widen)
          (if errbuf
              (with-current-buffer errbuf
                (setq buffer-read-only nil)
                (erase-buffer)))
          (with-current-buffer patchbuf
            (erase-buffer))

          (write-region nil nil tmpfile)

          (setq our-nimpretty-args
                (append our-nimpretty-args nimpretty-args
                        (list (file-local-name tmpfile))))
          (message "Calling nimpretty: %s %s" nimpretty-command our-nimpretty-args)
          (if (zerop (apply #'process-file nimpretty-command nil errbuf nil our-nimpretty-args))
              (progn
                ;; There is no remote variant of ‘call-process-region’, but we
                ;; can invoke diff locally, and the results should be the same.
                (if (zerop (let ((local-copy (file-local-copy tmpfile)))
                             (unwind-protect
                                 (call-process-region
                                  (point-min) (point-max) "diff" nil patchbuf
                                  nil "-n" "-" (or local-copy tmpfile))
                               (when local-copy (delete-file local-copy)))))
                    (message "Buffer is already nimprettied")
                  (nim--apply-rcs-patch patchbuf)
                  (message "Applied nimpretty"))
                (if errbuf (nimpretty--kill-error-buffer errbuf)))
            (message "Could not apply nimpretty")
            (if errbuf (nimpretty--process-errors (buffer-file-name) tmpfile errbuf))))

      (kill-buffer patchbuf)
      (delete-file tmpfile))))

(use-package! nim-mode
  :config
  (map!
    :localleader
    :map nim-mode-map
    "p" #'nimpretty))
#+end_src
**** Config

#+begin_src elisp
(use-package nim-mode
  :ensure t
  :hook
  (nim-mode . lsp)
  :config
  (setq nim-compile-default-command '("c"
                                      "-r"
                                      "--verbosity:0"
                                      "--hint[Processing]:off"
                                      "--hint[XDeclaredButNotUsed]:off"
                                      "--hint[DuplicateModuleImport]:off"
                                      "--excessiveStackTrace:on"
                                      "--outdir:/tmp/nimbins")))
#+end_src

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after nim-mode
 :map nim-mode-map
 :localleader
 (:prefix-map ("c" . "Create")
  :desc "Import File" "i" #'my::nim|import))
#+END_SRC
*** ReasonMl / ReScript :REASON_ML:
**** Packages
***** [[https://github.com/ocaml/merlin][merlin]]
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! merlin)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package merlin
  :after (reason-mode)
  :init
  ;; Disable merlin's own error checking
  ;; We'll use flycheck-ocaml for that
  (add-hook! merlin-mode (flycheck-add-mode 'ocaml-merlin 'reason-mode))
  (setq
   merlin-error-after-save nil
   merlin-command (executable-find "ocamlmerlin"))
  :config
  (add-to-list 'company-backends 'merlin-company-backend))
#+END_SRC

***** [[https://github.com/flycheck/flycheck-ocaml][flycheck-ocaml]]
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! flycheck-ocaml)
#+END_SRC

****** Config

******* Enable for reason-mode

#+begin_src elisp
(use-package flycheck-ocaml
  :after (flycheck merlin)
  :commands
  (flycheck-ocaml-setup)
  :config
  (with-eval-after-load 'merlin
    (flycheck-ocaml-setup))
  (with-eval-after-load 'reason-mode
    (flycheck-ocaml-setup)))
#+end_src

***** [[https://github.com/reasonml-editor/reason-mode][reason-mode]]
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! reason-mode)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! reason-mode
  :mode "\\.rei?$"
  :commands (reason-mode)

  :init
  (set-lookup-handlers! 'reason-mode
    :definition #'merlin-locate
    :references #'merlin-occurrences
    :documentation #'merlin-document)

  ;; Don't use refmt indentation, it can be horribly slow
  ;; and files get autofixed on save anyway
  (setq-hook! reason-mode indent-region-function #'indent-region-line-by-line)
  (setq-hook! reason-mode indent-line-function #'indent-relative)

  ;; [|array|]
  (set-electric! 'some-mode :chars '(?|))

  (set-company-backend! 'reason-mode 'merlin-company-backend)

  (let* ((refmt-bin (executable-find "refmt"))
         (merlin-bin (executable-find "ocamlmerlin"))
         (merlin-base-dir (when merlin-bin
                            (replace-regexp-in-string "bin/ocamlmerlin$" "" merlin-bin))))
    (when merlin-bin
      (add-to-list 'load-path (concat merlin-base-dir "share/emacs/site-lisp/"))
      (setq merlin-command merlin-bin))
    (when refmt-bin
      (setq refmt-command refmt-bin))
    (add-hook! reason-mode
      (merlin-mode)
      (merlin-use-merlin-imenu)
      (add-hook 'before-save-hook #'refmt-before-save nil t)))

  :config
  (add-hook
   'reason-mode-hook
   (lambda ()
     (merlin-mode)
     (setq utop-command "opam config exec -- rtop -emacs")
     (add-hook 'before-save-hook 'refmt-before-save)
     (add-hook 'reason-mode-hook 'merlin-mode)
     (add-hook 'reason-mode-hook 'utop-minor-mode)
     (add-hook 'reason-mode-hook 'flycheck-mode)
     :delight "re")))
#+END_SRC

**** Functions

***** Convert between ReasonML and Ocaml in SRC blocks

#+begin_src elisp
(defun my::org-babel|org-src-block-refmt-reason-ocaml-toggle ()
  "Convert an Org SRC block from ocaml to reason and vice versa."
  (interactive)
  (save-excursion
    (let* ((old-block (org-element-at-point))
           (old-lang (org-element-property :language old-block))
           (new-lang (if (string= old-lang "ocaml") "reason" "ocaml"))
           (formatter (if (string= old-lang "ocaml") 'refmt-region-ocaml-to-reason 'refmt-region-reason-to-ocaml)))
      (org-edit-special)
      (funcall formatter (point-min) (point-max))
      (org-edit-src-exit)
      (let* ((new-block (org-element-at-point))
             (new-block-parsed (org-element-interpret-data (org-element-put-property (org-element-at-point) :language new-lang)))
             (from (org-element-property :begin new-block))
             (to (org-element-property :end new-block)))
        (delete-region from to)))))
#+end_src

***** Rtop

#+begin_src elisp
(defun my::reason|rtop ()
  "Launch reason version of utop."
  (interactive)
  (cl-letf ((utop-command "rtop -emacs"))
    (utop)))
#+end_src
*** Clojure / Clojurescript
**** Packages
***** [[https://github.com/noctuid/lispyville][lispyville]]

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! lispyville :recipe (:host github :repo "noctuid/lispyville"))
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! lispyville
  :init
  (add-hook! '(emacs-lisp-mode-hook lisp-mode-hook clojure-mode-hook cider-repl-mode-hook) #'lispyville-mode))

#+END_SRC

******* Set key theme

Initialize it via a hook, otherwise it clashes with [[*Little Word Motion][Little Word Motion]] and throws an error on launch if we would do it in an ~after!~.

#+begin_src elisp
(defun my::lispyville|load ()
  "Function docstring"
  (interactive)
  (lispyville-set-key-theme '(operators
                              text-objects
                              wrap
                              raise
                              slurp/barf-cp
                              additional
                              additional-motions
                              (additional-wrap normal visual insert)
                              additional-insert)))

(add-hook! lispyville-mode-hook #'my::lispyville|load)
#+end_src

******* Jumps

Define jump points for lispyville functions

#+begin_src elisp
(advice-add #'lispyville-beginning-of-defun :around #'doom-set-jump-a)
(advice-add #'lispyville-end-of-defun :around #'doom-set-jump-a)
(advice-add #'lispyville-backward-up-list :around #'doom-set-jump-a)
(advice-add #'lispyville-up-list :around #'doom-set-jump-a)
(advice-add #'lispyville-insert-at-beginning-of-list :around #'doom-set-jump-a)
(advice-add #'lispyville-insert-at-end-of-list :around #'doom-set-jump-a)
(advice-add #'lispyville-open-below-list :around #'doom-set-jump-a)
(advice-add #'lispyville-open-above-list :around #'doom-set-jump-a)
#+end_src

**** Config

#+begin_src elisp
(use-package! lsp-mode
  :commands lsp
  :hook ((clojurescript-mode . lsp)
         (clojure-mode . lsp))
  :config
  (remove-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
  (setq lsp-enable-file-watchers nil)
  (setq lsp-file-watch-ignored-directories
        (cl-union lsp-file-watch-ignored-directories
                  '("[/\\\\]build\\'"
                    "[/\\\\]deployment\\'"
                    "[/\\\\]public\\'"
                    "[/\\\\]resource\\'"
                    "[/\\\\]target\\'"
                    "[/\\\\]tmp\\'"
                    "[/\\\\].log\\'"
                    "[/\\\\].clj-kondo\\'"
                    "[/\\\\].git\\'"
                    "[/\\\\].shadow-cljs\\'"
                    "[/\\\\]src/js\\'"
                    "[/\\\\]src/less\\'"
                    "[/\\\\]src/tailwind\\'"
                    "[/\\\\]test/e2e/screenshots\\'"))))
#+end_src

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after lsp-mode
 :map lsp-mode-map
 :gni "M-<RET>" #'lsp-find-references)

(map!
 :map (clojure-mode-map clojurescript-mode-map)
 :desc "Goto parent function" :n "gh" (cmd! (lispyville-backward-function-begin))
 :desc "Goto parent function" :n "[[" (cmd! (lispyville-backward-function-begin))
 :desc "Goto parent function" :n "]]" (cmd! (lispyville-forward-function-begin))
 :localleader
 "s" #'clojure-sort-ns)

#+END_SRC

** Git / Magit :GIT:MAGIT:
*** Packages
**** [[https://github.com/floscr/browse-at-remote][browse-at-remote]] :FORK:

Package override that fixes multiple remotes:
[[https://github.com/floscr/browse-at-remote/commit/9294ed82398457d2af5fcbf9090132f4693e4068][Add option to define preferred remote [*] · floscr/browse-at-remote@9294ed8]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! browse-at-remote :pin "9294ed82398457d2af5fcbf9090132f4693e4068" :recipe (:host github :repo "floscr/browse-at-remote"))
#+end_src
**** [[https://github.com/freesteph/elescope][elescope: Search and clone Git repos directly within Emacs.]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! elescope)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package elescope
  :commands (elescope-checkout)
  :config
  (setq elescope-root-folder my::directories:repositories-dir)
  :init
  (defalias '+git|clone 'elescope-checkout))
#+END_SRC
**** [[https://github.com/emacsmirror/git-lens][git-lens: Show new, deleted or modified files in branch]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! git-lens)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! git-lens
  :commands (git-lens))
#+END_SRC
*** Functions
**** Create worktree workspace

Creates a new git workspace from a branch.
Automatically adds ~.projectfile~ and opens a new doom workspace.

#+BEGIN_SRC elisp
(defun my::magit|create-worktree-project-from-branch (branch start-point &optional force)
  "Create a new BRANCH and check it out in a new worktree at PATH in a new workspace."
  (interactive
   `(,@(butlast (magit-branch-read-args "Create and checkout branch"))
     ,current-prefix-arg))
  (let* ((worktree-path (f-join (projectile-project-root) ".worktrees"))
         (path (f-join (projectile-project-root) ".worktrees" branch)))
    (when (not (f-exists-p worktree-path))
      (mkdir worktree-path t))
    (magit-run-git "worktree" "add" (if force "-B" "-b")
                   branch (expand-file-name path) start-point)
    (f-touch (f-join path ".projectile"))
    (+workspace-new branch)
    (+workspace-switch branch)
    (magit-diff-visit-directory path)
    (projectile-add-known-project path)
    path))
#+END_SRC

***** Transient binding :TRANSIENT:

#+begin_src elisp
(after! magit
  (transient-append-suffix 'magit-worktree "b" '("c" "Create branch and worktree" my::magit|create-worktree-project-from-branch)))
#+end_src

**** Revision show original file

Show the original file when visiting a revision buffer.
E.g.: When showing a diff from a commit, you may want to edit that file.

#+BEGIN_SRC elisp
(defun my::magit|show-revision-original ()
  "Show the orginal file from a revision buffer
If possible also go to the pointing line"
  (interactive)
  (when magit-buffer-file-name
    (let ((file-name magit-buffer-file-name)
          (line-number (line-number-at-pos)))
      (if current-prefix-arg
          (delete-other-windows))
      (find-file file-name)
      (goto-line line-number))))
#+END_SRC

**** Changed files in branch

Show a list of the changed files in the current branch.
For now only works on branches that were directly forked from master.

#+BEGIN_SRC elisp
(defun my::magit/list-new-files ()
  "List of added files in the current branch."
  (my::shell/command-to-list "git ls-files -om --exclude-standard"))

(defun my::magit/list-modified-files (&optional branch)
  "Get a list of modified files from the BRANCH to head."
  (my::shell/command-to-list
   (t! "git --no-pager diff --no-renames --name-only --no-merges <<(magit-rev-parse \"HEAD\")>> <<branch>>;")))

(defun my::magit/list-branch-changed-files (branch)
  "Get a list of new and modified files from BRANCH to head."
  (->> (my::magit/list-modified-files branch)
       (-concat (my::magit/list-new-files))
       (-uniq)
       (-filter
        (lambda (x)
          (let ((default-directory (projectile-project-root)))
            (f-exists? x))))))

(defun my::magit|counsel-changed-files (&optional branch)
  (interactive)
  (let ((enable-recursive-minibuffers t))
    (ivy-read (template "Changed files for <<(or branch (magit-get-current-branch))>>:")
              (my::magit/list-branch-changed-files (or "origin/master"))
              :require-match t
              :history 'file-name-history
              :action counsel-projectile-find-file-action
              :caller 'my::magit|counsel-changed-files)))
#+END_SRC
**** Undo commit

#+BEGIN_SRC elisp
(defun my::magit|git-undo ()
  "Soft reset current git repo to HEAD~1."
  (interactive)
  (magit-reset-soft "HEAD~1"))
#+END_SRC

**** Push dated remote branch

For work I need remote branches with a date prefix.

#+BEGIN_SRC elisp
(defun my::magit|push-dated (&optional branch)
  "Pushes the given the current BRANCH with a dated prefix
my-branch-name -> 19-01-my-branch-name
When no BRANCH is given, take the current one."
  (interactive)
  (let* ((branch (or branch (magit-get-current-branch)))
         (date (format-time-string "%y-%m"))
         (remote (template "origin/<<date>>-<<branch>>")))
    (magit-git-push branch remote "--set-upstream")
    remote))
#+END_SRC

**** Diff range from current branch to ~magit-thing-at-point~

When I'm on the log view, I want to quickly diff it against the currently checked out branch.
The transient shortcut for this is ~d R~ define [[*Transient][here]].

#+BEGIN_SRC elisp
(defun my::magit|diff-range-from-current-branch ()
  "Ranged diff from the checked out branch to the commit at point."
  (interactive)
  (magit-diff-range (template "<<(magit-commit-at-point)>>..<<(magit-get-current-branch)>>")))
#+END_SRC

**** Diff range from current pull request

#+BEGIN_SRC elisp
(defun my::magit|diff-range-from-pullreq ()
  "Ranged diff from the pull request under point."
  (interactive)
  (-some->> (forge-current-topic)
    (forge--pullreq-range)
    (magit-diff-range)))
#+END_SRC

**** Review branch

#+BEGIN_SRC elisp
(defun my::magit|delete-review-branches ()
  "Delete all review branches that no longer have an upstream."
  (interactive)
  (->> (magit-list-branches)
       (--filter (s-starts-with? "refs/heads/REVIEW" it))
       (--map (magit-name-local-branch it))
       (--reject (magit-get-upstream-branch it))
       (--each (lambda (x) (magit-branch-delete x t)))))

(defun my::magit|checkout-review-branches (&optional branch start-point)
  "Create a branch with review prefix for easy cleanup afterwards."
  (interactive)
  (let* ((remotes (magit-list-remote-branch-names))
         (atpoint (magit-branch-at-point))
         (branch (magit-completing-read
                  "Checkout branch" remotes
                  nil nil nil 'magit-revision-history
                  (or (car (member atpoint remotes))
                      (and atpoint
                           (car (member (and (string-match "[^/]+/" atpoint)
                                             (substring atpoint (match-end 0)))
                                        remotes))))))
         (review-branch-name (s-replace "origin/" "REVIEW-" branch)))
    ;; HACK Workaround where the buffer cant be read
    (advice-remove 'magit-checkout #'+magit-revert-repo-buffers-deferred-a)
    (magit-checkout branch)
    (when (magit-anything-modified-p)
      (user-error "Cannot checkout when there are uncommitted changes"))
    (if (-contains? (magit-list-local-branch-names) review-branch-name)
        (magit-branch-checkout review-branch-name)
      (magit-branch-and-checkout (s-replace "origin/" "REVIEW-" branch) branch))))
#+END_SRC
**** Cleanup branches

Cleans up all merged and review branches

#+BEGIN_SRC elisp
(defun my::magit|cleanup-branches (&optional base-branch)
  "Remove all merged and review branches."
  (interactive)
  (my::magit|delete-review-branches)
  (let* ((base-branch (or base-branch "master")))
    (call-interactively #'my::magit|delete-review-branches)
    (deferred:$
      (deferred:process-shell (template "git branch --merged | egrep -v \"(^\\*|<<base-branch>>)\" | xargs git branch -d"))
      (deferred:nextc it
        (magit-status-maybe-update-revision-buffer)))))
#+END_SRC

**** Branches by user

#+BEGIN_SRC elisp
(defun my::magit|branches-by-user (&optional ignore-review?)
  "List all branches by user.
Universal argument to ignore review branches."
  (interactive "P")
  (let ((branches
         (->>
          (concat "git for-each-ref"
                  " --sort=-committerdate"
                  " --format='%(committerdate) %(authorname) %(refname)'"
                  " --sort=-committerdate"
                  ;; refs/remotes/origin/ for remote branches
                  " refs/heads"
                  " | grep -e 'Florian Schroedl'")
          (shell-command-to-string)
          (s-split "\n")
          (-butlast)
          (-map (lambda (x) (->> (s-match ".*Florian Schroedl refs\\/heads\\/\\(.*\\)" x)
                                 (-last-item))))
          ((lambda (xs)
             (if ignore-review?
                 (--reject (s-starts-with? "REVIEW" it) xs)
               xs))))))
    (ivy-read "Checkout: " branches :action #'magit-checkout)))
#+END_SRC

**** Commit Template

Loads commit template from ~./git/TEMPLATE~ if the file exist.

#+BEGIN_SRC elisp
(defun my::magit::commit-template/find-template-file (branch)
  (when-let* ((dir (my::magit/find-root-git-dir))
              (entries (f-entries dir (lambda (x) (s-starts-with? "TEMPLATE" (f-base x)))))
              (branch-template (template "TEMPLATE-<<branch>>")))
    (or
     (-find (lambda (x) (string= branch-template (f-base x))) entries)
     (-find (lambda (x) (string= "TEMPLATE" (f-base x))) entries))))

(defun my::magit::commit-template|remove-template-file ()
  "Open an existing template file or create a new one."
  (interactive)
  (-when-let* ((file (my::magit::commit-template/find-template-file (magit-get-current-branch))))
    (when (save-window-excursion
            (find-file file)
            (y-or-n-p "Delete commit template file?"))
      (f-delete file))))

(defun my::magit::commit-template|edit-template-file ()
  "Open an existing template file or create a new one."
  (interactive)
  (let ((file (or (my::magit::commit-template/find-template-file (magit-get-current-branch))
                  (f-join (my::magit/find-root-git-dir) "TEMPLATE"))))
    (find-file file)))

(defun my::magit::commit-template/insert-template (&rest _)
  "When a TEMPLATE file in the git directory exists, insert it as a commit template."
  (when (eq (point) (point-at-eol))
    (-some->> (my::magit::commit-template/find-template-file (magit-get-current-branch))
      (f-read)
      (s-trim)
      (s-append " ")
      (insert)))
  (evil-insert-state))
#+END_SRC

And the hook

#+BEGIN_SRC elisp
(add-hook! 'git-commit-setup-hook :append #'my::magit::commit-template/insert-template)
#+END_SRC

**** Find root directory

Find the root directory of a ~.git~ repository
This also works for worktrees that are in a nested directory.

#+BEGIN_SRC elisp
(defun my::magit/find-root-git-dir ()
  "Find the root directory of a repository."
    (-some->> (magit-toplevel)
      (-f-join ".git")
      (-id-when #'f-exists?)
      ((lambda (x)
         (if (f-file? x)
             (->> (magit-list-worktrees)
                  (car)
                  (car)
                  (-f-join ".git"))
           x)))))
#+END_SRC
**** Lock git buffer :ADVICE:

#+BEGIN_SRC elisp
(advice-add #'magit-toggle-buffer-lock :after (lambda () (my/bool-state-message 'magit-buffer-locked-p)))
#+END_SRC

**** Check for merge conflicts
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option][Is there a git-merge --dry-run option? - Stack Overflow]]
:END:

Try two merge two branches in memory, to determine if there would be merge conflicts.

#+BEGIN_SRC elisp
(defun my::magit/check-for-merge-conflicts (&optional source-branch target-branch)
  "Try to merge SOURCE-BRANCH into TARGET-BRANCH, return list of conflicting files when there are any.
This will try to merge in memory, so no index files will be created.
SOURCE-BRANCH defaults to the current branch.
TARGET-BRANCH defaults to origin/master."
  (interactive)
  (let* ((source-branch (or source-branch (magit-get-current-branch)))
         (target-branch (or target-branch "origin/master"))
         (merge-base (my::shell/command-to-list (t! "git merge-base <<target-branch>> <<source-branch>>"))))
    (my::shell/command-to-list (t! "git merge-tree <<(car merge-base)>> <<target-branch>> <<source-branch>>"))))
#+END_SRC
**** Copy over changes from diff

#+BEGIN_SRC elisp
(defun my::magit|diff-copy-file-changes ()
  "Copies over contents of diff at point to the curent file system."
  (interactive)
  (save-excursion
    (let ((buffer (call-interactively #'magit-diff-visit-file)))
      (with-current-buffer buffer
        (make-directory (f-dirname magit-buffer-file-name) t)
        (f-write (substring-no-properties (buffer-string)) 'utf-8 magit-buffer-file-name)))
    (kill-buffer)))
#+END_SRC
**** Smerge mode hydra
:PROPERTIES:
:SOURCE:   [[https://github.com/alphapapa/unpackaged.el#hydra][alphapapa/unpackaged.el: A collection of useful Emacs Lisp code that isn't substantial enough to be packaged]]
:END:

#+BEGIN_SRC elisp
(use-package smerge-mode
  :after hydra
  :config
  (defhydra unpackaged/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (flycheck-mode -1)
                                     (unpackaged/smerge-hydra/body)))))
#+END_SRC

*** Config

#+BEGIN_SRC elisp
(after! magit
  :config
  (setq
   magit-save-repository-buffers 'dontask
   magithub-clone-default-directory "~/Code/Repositories"
   git-commit-summary-max-length 120))

(after! forge
  :config
  (setq forge-database-file (f-join doom-local-dir "forge-database.sqlite")))
#+END_SRC

**** Fix smerge mode color

#+BEGIN_SRC elisp
(after! smerge-mode
  :config
  ;; TODO This is broken after switching the theme but works for now
  ;; This fixes the smerge diff color is really bright an ugly
  (set-face-attribute 'smerge-refined-added nil :foreground nil :background nil))
#+END_SRC

*** Bindings
**** Diff Navigation

My workflow for navigating diffs
Use ~z1~ to fold all diffs to their file headers and press's ~{~ or ~}~ to

1. Refold all sections
2. Go to the next section
3. Unfold everything in the current section

Then use ~]~ to navigate the sections

#+BEGIN_SRC elisp
(defun my::magit/jumpunfold-section (&optional forward)
  "Fold all section. Go to next section when FORWARD. Show all children"
  (interactive)
  (magit-section-show-level-1-all)
  (call-interactively (if forward #'magit-section-forward-sibling #'magit-section-backward-sibling))
  (call-interactively #'magit-section-show-children))

(map!
 (:map magit-diff-mode-map
  :nv "}" (cmd! (my::magit/jumpunfold-section 't))
  :nv "{" (cmd! (my::magit/jumpunfold-section))))
#+END_SRC

**** Time Machine Navigation

#+BEGIN_SRC elisp
(map!
 :after git-timemachine
 :map git-timemachine-mode-map
 :n "[" #'git-timemachine-show-previous-revision
 :n "]" #'git-timemachine-show-next-revision
 :n "b" #'git-timemachine-blame)
#+END_SRC

**** Disable quit for locked buffers

Disable accidentally quitting magit buffers with ~q~ when the buffer is locked.

#+BEGIN_SRC elisp
(defun my::magit/disable-locked-quit (orig-fn &rest args)
  (unless magit-buffer-locked-p
    (apply orig-fn args)))

(advice-add #'magit-mode-bury-buffer :around #'my::magit/disable-locked-quit)
#+END_SRC

**** Fix text mode

Restores functionality when editing magit buffers as text.
For now only the toggle functionality is needed.

#+BEGIN_SRC elisp
(defvar +magit-evil-edit-mode-map (make-sparse-keymap))

(define-minor-mode +magit-evil-edit-mode ""
  :keymap +magit-evil-edit-mode-map)

(map! :map +magit-evil-edit-mode-map
      :n [tab] #'magit-section-toggle)
#+END_SRC

*** Transient Bindings :TRANSIENT:

You can add flags or commands to the magit interface transient here.
To append something, just state the flag that you see in the transient popup as the 2nd argument.

#+BEGIN_SRC elisp
(after! magit
  (transient-append-suffix 'magit-log "-f" '("-0" "No merges" "--no-merges"))
  (transient-append-suffix 'magit-push "p" '("d" "dated" my::magit|push-dated))

  (transient-append-suffix 'magit-diff "d" '("R" "Diff range from current branch" my::magit|diff-range-from-current-branch))
  (transient-append-suffix 'magit-diff "d" '("P" "Pullrequest Range" my::magit|diff-range-from-pullreq))
  (transient-append-suffix 'magit-diff "d" '("f" "File" magit-diff-buffer-file))

  (transient-append-suffix 'magit-commit
    "-D" '("-D" "Override the author date" "--date=" transient-read-date))

  (transient-append-suffix 'magit-branch "l" '("R" "Create review branch" my::magit|checkout-review-branches))
  (transient-append-suffix 'magit-branch "l" '("U" "My Branches" my::magit|branches-by-user)))
#+END_SRC
** Dired :DIRED:ORGANIZATION:
*** Packages
**** [[https://github.com/Fuco1/dired-hacks#dired-filter][dired-hacks - dired-filter]]

Filter current dired buffer by query/extension etc.
Trigger with ~g/.~ in ~normal-mode~.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! dired-filter)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! dired-filter
  :after dired
  :config
  (setq dired-filter-saved-filters
        (quote (("images"
                 (extension "jpg" "png" "gif"))
                ("media"
                 (extension "mp3" "mp4" "MP3" "MP4" "avi" "mpg" "flv" "ogg" "wmv" "mkv" "mov" "wma"))
                ("archives"
                 (extension "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
                ("documents"
                 (extension "doc" "docx" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub")))))
  (dired-filter-define created-today
      "Show only files that are newer than today."
    (:description "created-today")
    (let ((case-fold-search nil))
      (time-less-p (time-subtract (current-time) (* 60 60 24))
                   (file-attribute-modification-time (file-attributes file-name))))))
#+END_SRC
**** [[https://github.com/Fuco1/dired-hacks#dired-subtree][dired-hacks/dired-subtree]]

***** Config

#+BEGIN_SRC elisp
(use-package! dired-subtree
  :after dired
  :config
  (evil-define-key 'normal dired-mode-map
    (kbd "<tab>") (cmd! () (dired-subtree-toggle)
                      ;; Fix for dired-all-the-icons not showing up
                      (dired-revert))
    (kbd "<backtab>") (cmd! () (dired-subtree-cycle)
                          (dired-revert))
    (kbd "gh") 'dired-subtree-up))
#+END_SRC
**** [[https://github.com/Fuco1/dired-hacks#dired-subtree][dired-hacks/dired-subtree]]

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! dired-subtree)
#+END_SRC

*** Config
**** Listing Switches / Sorting

#+BEGIN_SRC elisp
(defconst my::dired:default-listing-switches
  "-ahl -t --group-directories-first")

(setq dired-listing-switches my::dired:default-listing-switches)
#+END_SRC

**** Omit files types in dired

#+begin_src elisp
(use-package! dired
  :config
  (setq dired-omit-files
        (concat dired-omit-files
                ;; Apple files
                "\\|\\.com.apple.timemachine.donotpresent$"
                "\\|\\.Spotlight-V100$"
                "\\|\\.fseventsd$"
                "\\|\\.DocumentRevisions-V100$"
                "\\|\\.TemporaryItems$"
                ;; Windows files
                "\\|\\System Volume Information$")))
#+end_src

**** Automatically revert dired buffers
:PROPERTIES:
:SOURCE:   [[https://www.reddit.com/r/emacs/comments/1acg6q/how_to_configure_dired_to_update_instantly_when/][How to configure dired to update instantly when files/folders change? : emacs]]
:END:

#+BEGIN_SRC elisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

**** Automatically create directories when moving/copying items :ADVICE:
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/12994164/allow-dired-do-copy-and-dired-do-rename-to-create-new-dir-on-the-fly][emacs - Allow dired-do-copy and dired-do-rename to create new dir on the fly - Stack Overflow]]
:END:

#+BEGIN_SRC elisp
(after! dired
  (defadvice dired-mark-read-file-name (after rv:dired-create-dir-when-needed (prompt dir op-symbol arg files &optional default) activate)
    (when (member op-symbol '(copy move))
      (let ((directory-name (if (< 1 (length files))
                                ad-return-value
                              (file-name-directory ad-return-value))))
        (when (and (not (file-directory-p directory-name))
                   (y-or-n-p (format "directory %s doesn't exist, create it?" directory-name)))
          (make-directory directory-name t))))))
#+END_SRC
**** Enable Async Mode

#+BEGIN_SRC elisp
(after! async
  (dired-async-mode 1))
#+END_SRC
*** Functions
**** Kill all dired buffers

#+BEGIN_SRC elisp
(defun my::dired|kill-dired-buffers ()
  "Kills all dired buffers."
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))
#+END_SRC

**** Go to mounted drive :COUNSEL:

#+begin_src elisp
(defun my::dired|find-mounted-drive ()
  "Browse mounted disk.
When the mounted drive has only 1 partition, select this one otherwise show listing of disks."
  (interactive)
  (let ((dir (f-join "/run/media/" user-login-name)))
    (counsel-find-file
     (-some->> dir
       (f-directories)
       (--id-when (eq 1 (length it)))
       (car))
     (f-join "/run/media/" user-login-name))))
#+end_src

**** Unparent directory at point

#+BEGIN_SRC elisp
(defun my::dired|ungroup-directory ()
  "Move all files and directories to the current directory,
If everything goes well and the directory is empty, safely delete it.
It might not work out though, when any of the entries has the same name,
in that case throw a warning."
  (interactive)
  (->> (dired-get-marked-files)
       (-map (lambda (x)
               (let ((cmd (if (my::file/dir-has-hidden-entries x)
                              "mv -n ./* ./.* ../"
                            "mv -n ./* ../")))
                 (shell-command (t! "cd \"<<x>>\"; <<cmd>>"))
                 (when (f-empty? x)
                   (dired-delete-file x))))))
  (revert-buffer))
#+END_SRC
**** TODO Mouse navigation of the heading directory
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/13354/dired-heading-directory-with-text-properties-to-jump-to-parent-directories][breadcrumbs - Dired heading directory with text-properties to jump to parent directories - Emacs Stack Exchange]]
:END:

Allows to click on the header bar to got to navigate tree breadcrumbs in the dired header bar.

#+begin_src elisp
(defface dired-mouseover-face
  '((t (:foreground "green")))
  "Face for `dired-mouseover-face'."
  :group 'dired)

(defvar dired-mouse-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mouse-2] 'dired-follow-link)
    (define-key map [return] 'dired-follow-link)
    (define-key map [follow-link] 'mouse-face)
    map)
  "Keymap for mouse when in `dired-mode'.")

;; Author:  Drew Adams -- http://emacs.stackexchange.com/a/13411/2287
(defun dired-follow-link (event)
  "Follow the link in the dired directory heading, causing a new
dired buffer to be opened.
When clicking on the current directory always go one directory upwards."
  (interactive (list last-nonmenu-event))
  (run-hooks 'mouse-leave-buffer-hook)
  (with-current-buffer (window-buffer (posn-window (event-start event)))
    (let ((path  (get-text-property (posn-point (event-start event)) 'breadcrumb)))
      (if (f-equal? dired-directory path)
          (dired-up-directory)
        (dired path)))))

(defun dired-propertize-directory-heading ()
  (interactive)
  (unless (buffer-narrowed-p)
    (let* (
           p beg end path peol
           (inhibit-read-only t))
      (save-excursion
        (goto-char (point-min))
        (setq peol (point-at-eol))
        (set-text-properties (point) peol nil)
        (re-search-forward "\\([^/\\]+\\)[/\\]" peol t)
        (when (looking-back "\\(^ +\\)\\([a-zA-Z]:\\)?/")
          (setq p (match-end 1))
          (setq path (if (match-string 2) (concat (match-string 2) "/") "/"))
          (add-text-properties (point-min) (1- (match-end 0)) (list
                                                               'breadcrumb path
                                                               'mouse-face 'dired-mouseover-face
                                                               'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                                               'keymap dired-mouse-map)))
        (while (re-search-forward "\\([^/\\]+\\)[/\\]" peol t)
          (setq beg (match-beginning 1))
          (setq end (match-end 1))
          (setq path (buffer-substring-no-properties p end))
          (add-text-properties beg end (list
                                        'breadcrumb path
                                        'mouse-face 'dired-mouseover-face
                                        'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                        'keymap dired-mouse-map)))
        (setq path (buffer-substring-no-properties p (1- peol)))
        (add-text-properties (point) (1- peol) (list
                                                'breadcrumb path
                                                'mouse-face 'dired-mouseover-face
                                                'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                                'keymap dired-mouse-map))))))

(add-hook 'dired-after-readin-hook 'dired-propertize-directory-heading)
#+end_src
**** Get marked file size
:PROPERTIES:
:SOURCE:   https://www.emacswiki.org/emacs/DiredGetFileSize
:END:

#+BEGIN_SRC elisp
 (defun my::dired|get-marked-file-size ()
   "Get the file size of all marked dired entries."
   (interactive)
   (let ((files (dired-get-marked-files)))
     (with-temp-buffer
       (apply 'call-process "du" nil t nil "-sch" files)
       (message
        "Size of all marked files: %s"
        (progn (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$") (match-string 1))))))
#+END_SRC

**** Toggle sorting

When you toggle the sorting via ~dired-sort-toggle-or-edit~ the cursor stays at the current file, which is very disorienting.
With this function the cursor stays on the current line.
~save-excursion~ does not work in this function, it just throws to the top of the buffer.
The dired-line jumps at the end are used to jump the filename again.

#+BEGIN_SRC elisp
(defun my::dired|toggle-sorting (&optional arg)
  "Change sorting but stay on the same line."
  (interactive "P")
  (let ((pos (point)))
    (cond
     ((eq arg 3)
      (setq dired-listing-switches (symbol-value 'my::dired:default-listing-switches))
      (setq dired-actual-switches (symbol-value 'my::dired:default-listing-switches))
      (dired-sort-set-mode-line)
      (revert-buffer))
     ((eq arg 2)
      (setq dired-listing-switches
            (read-string "Global ls switches (must contain -l): " dired-listing-switches))
      (setq dired-actual-switches (symbol-value 'dired-listing-switches))
      (dired-sort-set-mode-line)
      (revert-buffer))
     (arg
      (setq dired-actual-switches
            (read-string "Buffer ls switches (must contain -l): " dired-actual-switches)))
     (t (dired-sort-toggle-or-edit)))
    (goto-char pos)
    (dired-next-line 1)
    (dired-previous-line 1)))
#+END_SRC
**** Open file externally
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/cgbpvl/opening_media_files_straight_from_gnu_emacs_dired/eufxc9j/
:END:

***** Config

#+begin_src elisp
(defvar my::dired::open-external:extensions nil
  "Which files to open externally by default when pressing enter.")

(setq my::dired::open-external:extensions
      '(
        ;; Video
        "mov" "mpv" "mkv" "webm"
        ;; Audio
        "mp4" "mp3" "ogg"))
#+end_src

***** Function

#+BEGIN_SRC elisp
(defun my::dired::open-external/mouse-open (event)
  "Open marked dired file(s) at point with an external application. Open directories normally"
  (interactive "e")
  (my::dired::open-external/mouse-open event))

(defun my::dired::open-external/mouse-open (event &optional find-file-func find-dir-func)
  "In Dired, visit the file or directory name you click on.
The optional arguments FIND-FILE-FUNC and FIND-DIR-FUNC specify
functions to visit the file and directory, respectively.  If
omitted or nil, these arguments default to `find-file' and `dired',
respectively."
  (interactive "e")
  (or find-file-func (setq find-file-func 'my::dired::open-external/xdg-open))
  (or find-dir-func (setq find-dir-func 'dired))
  (let (window pos file)
    (save-excursion
      (setq window (posn-window (event-end event))
            pos (posn-point (event-end event)))
      (if (not (windowp window))
          (error "No file chosen"))
      (set-buffer (window-buffer window))
      (goto-char pos)
      (setq file (dired-get-file-for-visit))
      (if (file-directory-p file)
          (or (and (cdr dired-subdir-alist)
                   (dired-goto-subdir file))
              (progn
                (select-window window (funcall find-dir-func file))))
        (select-window window)
        (funcall find-file-func)))))

(defun my::dired::open-external/xdg-open (&optional file)
  "Open marked dired file(s) at point with an external application."
  (let ((file-list (or file (dired-get-marked-files)))
        (process-connection-type nil))
    (--map (my::shell/no-exit-command "xdg-open" (s-wrap (expand-file-name it) "\"")) file-list)))

(defun my::dired::open-external|open-dwim (&optional file)
  (interactive)
  (let ((file-list (or file (dired-get-marked-files)))
        (process-connection-type nil))
    (-each file-list (lambda (x)
                       (message "%s" x)
                       (let* ((path (expand-file-name x))
                              (ext (f-ext path)))
                         (if (-contains? my::dired::open-external:extensions ext)
                             (my::shell/no-exit-command "xdg-open" (s-wrap path "\""))
                           (dired-find-file)))))))
#+END_SRC
**** Convert Images
:PROPERTIES:
:SOURCE:   [[http://xenodium.com/enrich-your-dired-batching-toolbox/index.html][Enrich Emacs direds batching toolbox]]
:END:

#+BEGIN_SRC elisp
(defun my::dired|convert-image (&optional arg)
  "Convert image files to other formats."
  (interactive "P")
  (assert (executable-find "convert") nil "Install imagemagick")
  (let* ((dst-fpath)
         (src-fpath)
         (src-ext)
         (last-ext)
         (dst-ext))
    (mapc
     (lambda (fpath)
       (setq src-fpath fpath)
       (setq src-ext (downcase (file-name-extension src-fpath)))
       (when (or (null dst-ext)
                 (not (string-equal dst-ext last-ext)))
         (setq dst-ext (completing-read "to format: "
                                        (seq-remove (lambda (format)
                                                      (string-equal format src-ext))
                                                    '("jpg" "png")))))
       (setq last-ext dst-ext)
       (setq dst-fpath (format "%s.%s" (file-name-sans-extension src-fpath) dst-ext))
       (message "convert %s to %s ..." (file-name-nondirectory dst-fpath) dst-ext)
       (set-process-sentinel
        (start-process "convert"
                         (generate-new-buffer (format "*convert %s*" (file-name-nondirectory src-fpath)))
                         "convert" src-fpath dst-fpath)
        (lambda (process state)
          (if (= (process-exit-status process) 0)
              (message "convert %s ✔" (file-name-nondirectory dst-fpath))
            (message "convert %s ❌" (file-name-nondirectory dst-fpath))
            (message (with-current-buffer (process-buffer process)
                       (buffer-string))))
          (kill-buffer (process-buffer process)))))
     (dired-map-over-marks (dired-get-filename) arg))))
#+END_SRC
**** Shred File

#+begin_src elisp
(defun my::dired|do-shred ()
  "Run shred on marked files.
This will erase them."
  (interactive)
  (yes-or-no-p "Do you REALLY want to shred these files forever? ")
  (save-window-excursion
    (dired-do-async-shell-command "shred -zu" nil (dired-get-marked-files))))
#+end_src

*** Bindings

#+BEGIN_SRC elisp
(map! :after dired
      :map dired-mode-map
      ;; Mouse controls
      :ng (kbd "<mouse-2>") 'my::dired::open-external|open-dwim
      :ng (kbd "<mouse-8>") 'dired-up-directory


      :n "q" (cmd! (kill-buffer))
      :n "Q" #'my::dired|kill-dired-buffers

      :ng "RET" 'my::dired::open-external|open-dwim
      :gn "o" 'my::dired|toggle-sorting
      :n "gg" 'my::dired|goto-top
      :localleader
      (:prefix ("s" . "search")
       "i"  #'dired-goto-subdir))

(define-key dired-mode-map (kbd "<down-mouse-1>") 'dired-mouse-find-file)
#+END_SRC

**** Go to top =gg= evil fix :EVIL:

When I do =gg= in dired, I mostly want to go to the first entry.
This function first goes to the first entry and then to the top of the buffer.

#+BEGIN_SRC elisp
(defun my::dired|goto-top ()
  "Go to first directory, when already there go to first line."
  (interactive)
  (if (<= (line-number-at-pos) 3)
      (goto-char (point-min))
    (goto-line 3)
    (dired-next-dirline 1)
    (dired-prev-dirline 1)))
#+END_SRC
**** Wdired mode evil fix :EVIL:

Stay in normal mode when switching to wdired

#+BEGIN_SRC elisp
(defun my::dired|evil-wdired-mode ()
  "Stay in normal mode when switching to wdired."
  (interactive)
  (wdired-change-to-wdired-mode)
  (evil-normal-state))

(map! :after dired
      :map dired-mode-map
      :n "\\" #'my::dired|evil-wdired-mode)
#+END_SRC

**** Use same window for copying/renaming with prefix

I've set ~dired-dwim-target~ to ~t~, so it uses the other window as the target destination.
I undo this option with the interactive prefix argument, which can be accessed via ~SPC ucopy R/U~.

#+BEGIN_SRC elisp
(defun my::dired/dired-target-from-prefix (fn)
  (let ((dired-dwim-target (if (eq (prefix-numeric-value current-prefix-arg) 4) ;; Single C-u
                              nil
                            dired-dwim-target)))
      (call-interactively fn)))

(map! :after dired
      :map dired-mode-map
      :n "R" (cmd! (my::dired/dired-target-from-prefix #'dired-do-rename))
      :n "C" (cmd! (my::dired/dired-target-from-prefix #'dired-do-copy)))
#+END_SRC

**** Dired Paste DWIM

#+BEGIN_SRC elisp
(defun my::dired|paste-dwim ()
  "Paste data in the current directory."
  (interactive)
  (let ((file (read-string "Filename: "))
        (last-clip-type (->> (shell-command-to-string "greenclip print")
                             (s-split "\n")
                             (-first-item))))
    (unless (string= "" file)
      (cond
       ((s-matches? "^image\\/png" last-clip-type)
        (shell-command-to-string (template "xclip -selection clipboard -t image/png -o > <<file>>")))))
    (dired-revert)))

(map! :after dired
      :map dired-mode-map
      :n "p" 'my::dired|paste-dwim)
#+END_SRC
** System :SYSTEM:
*** Packages
**** [[https://github.com/emacs-straight/disk-usage][disk-usage]]

Explore disk usage in emacs

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! disk-usage)
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! disk-usage
  :commands (disk-usage)
  :config
  (map! :map disk-usage-mode-map
        :n "-" #'disk-usage-up))
#+END_SRC
**** [[https://github.com/alpha22jp/atomic-chrome][atomic-chrome]] :BROWSER:

Edit browser input fields with emacs.

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! atomic-chrome)
#+END_SRC
***** Config

#+begin_src elisp
(use-package! atomic-chrome
  :commands (atomic-chrome-start-server)
  :config
  (setq
   atomic-chrome-url-major-mode-alist
   '(("github\\.com" . gfm-mode))))
#+end_src

**** [[https://github.com/cbowdon/daemons.el][cbowdon/daemons.el Systemd UI]] :LINUX:

Manage systemd from emacs

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! daemons)
#+END_SRC
***** Config

#+begin_src elisp
(use-package! daemons
  :commands (daemons))
#+end_src
**** [[https://doc.endlessparentheses.com/Fun/proced-mode.html][proced]] :UNIX:
***** Packages

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! proced-narrow)
#+END_SRC

***** Functions
****** Shorten nixos path names in proced

Nixos paths can be very long, which is distracting in proced.
This shortens the nixos paths to ~{nix}~.

#+BEGIN_SRC elisp
(defun my::proced/remove-nixos-path-name (oldformat &rest xs)
  (let ((xs (--map (->> it
                        (s-replace-regexp "/nix/store/[^/]+" "{nix}")
                        (s-replace-regexp (template "^/home/<<(user-login-name)>>") "~")
                        ((lambda (x) (if (s-contains? "chromium" x) "{chromium}" x))))
                  xs)))
    (apply oldformat xs)))

(advice-add #'proced-format-args :around #'my::proced/remove-nixos-path-name)
#+END_SRC

***** Bindings

#+begin_src elisp
(map! :map proced-mode-map
      :n "/" #'proced-narrow
      :n "gr" #'proced)

(map! :map process-menu-mode-map
      :n "gr" #'list-processes)
#+end_src
** Projectile :PROJECTILE:
*** Config
**** Ignored Projects

Dont add packages inside ~~.emacs.d~ to projectile, as I often browse the source for a package,
but I dont want them added to my ~projectile-known-projects~.

#+BEGIN_SRC elisp
(use-package! projectile
  :init
  (setq projectile-ignored-projects '("~/"
                                      "/tmp"
                                      "~/.emacs.d/.local/straight/repos/")))
#+END_SRC

**** Scan directory for repositories

#+BEGIN_SRC elisp
(use-package! projectile
  :init
  (setq projectile-project-search-path '("~/Code/Dotfiles"
                                         "~/Code/Repositories"
                                         "~/Code/Projects"
                                         "~/Code/Tools"
                                         "~/Code/Meisterlabs"
                                         "~/Code/Meisterlabs/mindmeister-web/.worktrees"))
  :config
  ;; Auto discover when running switch project for the first time
  (add-transient-hook! 'counsel-projectile-switch-project
    (projectile-cleanup-known-projects)
    (projectile-discover-projects-in-search-path)))
#+END_SRC
** Documents :DOCUMENTS:
*** Pdf :PDF:
**** Config

***** TODO Fix midnight colors for doom-one theme

#+BEGIN_SRC elisp
;; Fix midnight colors for doom-one theme
(setq pdf-view-midnight-colors '("#BBC2CD" . "#282C34"))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map!
 :map pdf-occur-buffer-mode-map
 :gn [tab] (cmd! (pdf-occur-goto-occurrence t)))
#+END_SRC
*** Ebook :EBOOK:
**** Packages
***** [[https://depp.brause.cc/nov.el/][nov]]

Major mode for reading EPUBs in Emacs

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! nov)
#+END_SRC

****** Functions
******* Setup function

#+begin_src elisp
(defun my::nov/setup ()
  (setq line-spacing 5)
  (face-remap-add-relative 'variable-pitch :family "Liberation Serif" :height 1.4)
  (setq visual-fill-column-center-text t)
  (setq visual-fill-column-width (+ nov-text-width 25))
  (visual-fill-column-mode t))
#+end_src

****** Config

#+BEGIN_SRC elisp
(use-package! nov
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (setq nov-text-width 75)
  (setq nov-save-place-file (f-join doom-local-dir "nov-places"))
  :config
  (add-hook 'nov-mode-hook 'my::nov/setup))
#+END_SRC

** Spell Checking
*** Packages
**** [[https://github.com/btford/write-good][btford/write-good]] :LINTING:DOOM:

Naive linter for english prose.

***** Config
****** Disable doom defined hooks for writegood mode

#+BEGIN_SRC elisp
(use-package! writegood-mode
  :hook 'nil)
#+END_SRC

****** Disable ~writegood-mode~ with ~spell-fu~ mode

#+BEGIN_SRC elisp
(defun +spell-fu/activate-writegood-mode-hook ()
  "Toggle writegood mode with spell-fu mode."
  (cond
   (spell-fu-mode (writegood-mode 1))
   (t (writegood-mode -1))))

(add-hook! 'spell-fu-mode-hook :after #'+spell-fu/activate-writegood-mode-hook)
#+END_SRC
**** Flyspell
***** Defer flyspell until first ~evil-insert-state~

Flyspell most of the time is an annoyance when opening a file just for reading.
I mostly only need it when writing text (sometimes when reviewing, but then I can toggle it manually).

So I defer it until the first text change has been done (or the first insert state).
I've tried it on the ~first-change-hook~, but that is also affected by changing todo states for example in ~org-mode~.

#+begin_src elisp
(defun +flyspell/load-after-first-insert--activate ()
  "Turns on flyspell after the first buffer change or evil-insert state."
  (remove-hook! '(first-change-hook evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert)
  (remove-hook! '(first-change-hook evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert--activate)
  (spell-fu-mode 1))

(defun +flyspell/load-after-first-insert ()
  "Turns on flyspell after the first buffer evil-insert state.
Exception for org mode when the header property \"DISABLE_SPELLCHECKER\" is set."
  (cond ((and (equal major-mode 'org-mode) (+org/get-global-property "DISABLE_SPELLCHECKER")) nil)
        (t (add-hook! '(evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert--activate))))

(defmacro my::spelling@remove-doom-spell-hooks (package mode)
  `(use-package! ,package
     :init
     (remove-hook! '(org-mode-hook
                     markdown-mode-hook
                     TeX-mode-hook
                     rst-mode-hook
                     mu4e-compose-mode-hook
                     message-mode-hook
                     text-mode-hook
                     git-commit-mode-hook)
       ,mode)))

(my::spelling@remove-doom-spell-hooks spell-fu #'spell-fu-mode)
(my::spelling@remove-doom-spell-hooks flyspell #'flyspell-mode)
(my::spelling@remove-doom-spell-hooks writegood-mode #'writegood-mode)

(add-hook! '(org-mode-hook markdown-mode-hook) :local #'+flyspell/load-after-first-insert)
#+end_src
** Flycheck :LINTING:
*** Config
**** Disabled Checkers
***** Elisp

#+BEGIN_SRC elisp
(add-hook! 'emacs-lisp-mode-hook :append
  (setq flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC

***** Nim

#+BEGIN_SRC elisp
(add-hook! 'nim-mode-hook :append
  (setq flycheck-disabled-checkers '(nim-nimsuggest))
  (flycheck-select-checker 'nim-1-6-0))
#+END_SRC
** Completion :COMPLETION:
*** Packages
**** [[https://github.com/abo-abo/swiper][ivy / counsel]]
***** Actions
****** Search from ~counsel-find-file~

#+begin_src elisp
(defun my::counsel/search-from-find-file-counsel (x)
  "Function docstring"
  (let ((default-directory (if (f-dir? x) x (f-dirname x))))
    (+default/search-cwd)))

(after! ivy
 (setq my::counsel::action:search-from-find-file
  '(("s" my::counsel/search-from-find-file-counsel "Search in directory")))
 (ivy-add-actions 'counsel-find-file my::counsel::action:search-from-find-file))
#+end_src
***** Functions
****** Project File Jump

#+BEGIN_SRC elisp
(defun my::counsel|project-file-jump (x)
  "Jump to file in project"
  (interactive)
  (counsel-file-jump nil (f-join (projectile-project-root) x)))
#+END_SRC

****** External Drives

#+BEGIN_SRC elisp
(defun my::counsel|mounted-drives ()
  "Counsel of mounted drives."
  (interactive)
  (let* ((path (f-join "/run/media/" (user-login-name)))
         (entries (f-entries path)))
    (pcase (length entries)
      (0 (user-error "Error: No mounted devices!"))
      (1 (counsel-find-file (car entries)))
      (_ (counsel-find-file path)))))
#+END_SRC

****** Search project for symbol at point :FIX:ADVICE:

Doom doesn't double escape ~|~ which is needed for ~rg~.
Original [[file:~/.emacs.d/modules/config/default/autoload/search.el::defun +default/search-project-for-symbol-at-point][+default/search-project-for-symbol-at-point]]

I've also removed the feature checking, since I ony use ~ivy~.

#+begin_src elisp
(defun my::ivy|search-project-for-symbol-at-point (symbol dir)
  "Search current project for symbol at point.
If prefix ARG is set, prompt for a known project to search from."
  (interactive
   (list (->> (or (doom-thing-at-point-or-region) "")
              (rxt-quote-pcre)
              (s-replace-all '(("|" . "\\|"))))
         (let ((projectile-project-root nil))
           (if current-prefix-arg
               (if-let (projects (projectile-relevant-known-projects))
                   (completing-read "Search project: " projects nil t)
                 (user-error "There are no known projects"))
             (doom-project-root default-directory)))))
  (+ivy/project-search nil symbol dir))

(advice-add #'+default/search-project-for-symbol-at-point :override #'my::ivy|search-project-for-symbol-at-point)
#+end_src

***** Config
****** Always show actions in hydra.

#+BEGIN_SRC elisp
(setq ivy-read-action-function #'ivy-hydra-read-action)
#+END_SRC

****** Banish mouse cursor :HACK:

The cursor will steal the focus from ivy-posframe, breaking ivy completely...

This option moves the mouse cursor to 0x0,
which is really unacceptable, but works for now.

#+BEGIN_SRC elisp
(setq posframe-mouse-banish t)
#+END_SRC

***** Bindings

Adds general bindings to ivy.
~MOD + ↩~ will insert the current item and continue with a new instance of the same ivy buffer.
~CTRL + ↩~ will abort completion and insert the inserted text.

#+BEGIN_SRC elisp
(map!
 :after ivy
 :map ivy-minibuffer-map
  "<s-return>" 'ivy-call
  "<C-tab>" 'minibuffer-complete
  "<C-return>" 'ivy-immediate-done
  "M-m" 'ivy-mark)
#+END_SRC

Find file on enter press for ~ivy-occur-mode~

#+BEGIN_SRC elisp
(map! :map ivy-occur-mode-map
      :gni "RET" #'ivy-occur-press-and-switch)
#+END_SRC
**** [[https://github.com/raxod502/prescient.el][company-prescient]]

Better sorting for company

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! prescient)
(package! company-prescient)
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! prescient
  :config
  (prescient-persist-mode 1))

(use-package! company-prescient
  :after company
  :config
  (company-prescient-mode 1))
#+END_SRC
**** [[https://company-mode.github.io/][company]]
***** Functions
****** Complete line for all buffers

Complete a whole line with all lines from buffers matching the current major-mode.

#+BEGIN_SRC elisp
(defun my::company/list-buffers-with-mode (modes)
  "Get all buffers that match MODES"
  (--filter
   (with-current-buffer it (-contains? (doom-enlist modes) major-mode))
   (buffer-list)))

(defun my::company/list-buffers-with-major-mode ()
  "Get all buffers matching the current major-mode
Has built in aliases"
  (let ((javascript-modes (list 'rjsx-mode 'js2-mode)))
    (pcase major-mode
      ('rjsx-mode
       (my::company/list-buffers-with-mode javascript-modes))
      ('js2-mode
       (my::company/list-buffers-with-mode javascript-modes))
      (_
       (my::company/list-buffers-with-mode major-mode)))))

(defun my::company/complete-line-all-buffers (command &optional arg &rest ignored)
  "`company-mode' completion backend that completes whole-lines, akin to vim's
C-x C-l."
  (interactive (list 'interactive))
  (require 'company)
  (pcase command
    (`interactive (company-begin-backend 'my::company/complete-line-all-buffers))
    (`prefix      (company-grab-line "^[\t\s]*\\(.+\\)" 1))
    (`candidates
     (all-completions
      arg
      (funcall (-compose
                #'-uniq
                #'-flatten
                (lambda (xs)
                  (--map (with-current-buffer it
                           (split-string
                            (replace-regexp-in-string
                             "^[\t\s]+" ""
                             (buffer-substring-no-properties (point-min) (point-max)))
                            "\\(\r\n\\|[\n\r]\\)" t)) xs)))
               (my::company/list-buffers-with-major-mode))))))
#+END_SRC

Bindings

#+BEGIN_SRC elisp
(map!
 (:prefix "C-x"
   :i "C-l" #'my::company/complete-line-all-buffers
   :i "C-." #'+company/whole-lines))
#+END_SRC

***** Config
****** Sort company by occurrence
:PROPERTIES:
:SOURCE:   [[https://github.com/company-mode/company-mode/issues/52][{Proposal} Improve company-dabbrev candidate ordering · Issue #52 · company-mode/company-mode]]
:END:

#+BEGIN_SRC elisp
(setq company-transformers '(company-sort-by-occurrence)
      company-idle-delay 0.5)
#+END_SRC

** LSP
*** Config
**** Guess root

When working in nested git worktrees, lsp should infer the root by using projectile, by finding the closest ~.projectile~ file.
This file is always created when [[*Create worktree workspace][creating a worktree]].

#+begin_src elisp
(setq lsp-auto-guess-root t)
#+end_src

**** Disable presets

All are these are distracting and not helpful.

- Removes all popup UIs
- Remove signature message
- Remove lsp flycheck

#+BEGIN_SRC elisp
(use-package! lsp
  :config
  (setq lsp-eldoc-render-all nil
        lsp-eldoc-enable-hover nil
        lsp-eldoc-enable-signature-help nil
        lsp-eldoc-prefer-signature-help nil
        lsp-inhibit-message t

        lsp-enable-file-watchers nil

        lsp-eldoc-enable-hover nil
        lsp-signature-auto-activate nil
        lsp-signature-render-documentation nil
        lsp-signature-doc-lines 1

        lsp-diagnostics-provider :none
        lsp-modeline-diagnostics-enable nil
        lsp-modeline-code-actions-enable nil

        lsp-highlight-symbol-at-point nil
        lsp-prefer-flymake nil

        lsp-on-idle-hook nil))
#+END_SRC

**** Fix flycheck for js buffers :FIX:

LSP manually disables all checkers and chooses it's own.
This way you can't add checkers after your regular hooks like ~js2-hook~.
So I fix the checker manually for each mode after lsp was loaded.

#+BEGIN_SRC elisp
(after! lsp-mode
  (remove-hook 'lsp-mode-hook #'+lsp-init-flycheck-or-flymake-h))

(defun +js/fix-checker ()
  "Fix LSP overwritten checkers."
  (interactive)
  (when (-contains? '(js2-mode rjsx-mode) major-mode)
    (flycheck-select-checker 'javascript-eslint)))

(add-hook 'lsp-mode-hook #'+js/fix-checker)
#+END_SRC
** Snippets :SNIPPETS:
*** Functions
**** Expand snippet by name
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/10211730/insert-yasnippet-by-name][emacs - Insert yasnippet by name - Stack Overflow]]
:END:

#+BEGIN_SRC elisp
(defun my::snippets/insert-by-name (name)
  (require 'noflet)
  (noflet ((dummy-prompt
            (prompt choices &optional display-fn)
            (declare (ignore prompt))
            (or (cl-find name choices :key display-fn :test #'string=)
                (throw 'notfound nil))))
    (let ((yas-prompt-functions '(dummy-prompt)))
      (catch 'notfound
        (yas-insert-snippet t)))))
#+END_SRC

**** Use last src language
:PROPERTIES:
:SOURCE:   [[https://github.com/tecosaur/emacs-config/blob/0c50e2a651e8903a922a60acf701d4a6ba0e1d29/config.org][emacs-config/config.org at 0c50e2a651e8903a922a60acf701d4a6ba0e1d29 · tecosaur/emacs-config]]
:END:

Used with [[file:snippets/org-mode/src::`%`$0][src snippet]] to auto fill the language from the previously used src language.

#+BEGIN_SRC elisp
(defun my::snippets/org-src-lang ()
  "Try to find the current language of the src/header at point.
Return nil otherwise."
  (save-excursion
    (pcase
        (downcase
         (buffer-substring-no-properties
          (goto-char (line-beginning-position))
          (or (ignore-errors (1- (search-forward " " (line-end-position))))
              (1+ (point)))))
      ("#+property:"
       (when (re-search-forward "header-args:")
         (buffer-substring-no-properties
          (point)
          (or (and (forward-symbol 1) (point))
              (1+ (point))))))
      ("#+begin_src"
       (buffer-substring-no-properties
        (point)
        (or (and (forward-symbol 1) (point))
            (1+ (point)))))
      ("#+header:"
       (search-forward "#+begin_src")
       (my::snippets/org-src-lang))
      (_ nil))))

(defun my::snippets/org-last-src-lang ()
  (save-excursion
    (beginning-of-line)
    (when (search-backward "#+begin_src" nil t)
      (my::snippets/org-src-lang))))
#+END_SRC
*** Config

**** Disable doom snippets / load custom snippets

#+BEGIN_SRC elisp
(use-package! yasnippet
  :init
  (require 'doom-snippets nil t))
#+END_SRC
** Search (Grep) :SEARCH:

*** Bindings

**** Wgrep Mode

#+begin_src elisp
(map!
 :map (wgrep-mode-map ivy-occur-grep-mode-map)
 :n [return] #'compile-goto-error

 :localleader
 :desc "Remove line" "d" (cmd! (let ((inhibit-read-only t))
                                 (my::buffer/delete-current-line))))
#+end_src

** Web :WEB:
*** [[https://github.com/skeeto/elfeed][Elfeed]] :DOOM:
**** Packages
***** DISABLED [[https://github.com/algernon/elfeed-goodies][algernon/elfeed-goodies: Various goodies for Elfeed]] :DISABLED:

No need, screws with entry buffer position and header display...

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! elfeed-goodies :disable t)
#+end_src

**** Functions
***** Open elfeed

#+BEGIN_SRC elisp
(defun my::elfeed|open ()
  (interactive)
  (unless (get-buffer "*elfeed-search*")
    (setq elfeed-search-filter +rss:default-search-filter))
  (elfeed)
  (my::rss|hydra/body))
#+END_SRC

***** Filter by unread

#+BEGIN_SRC elisp
(defun my::rss/filter-by-unread ()
  "Show elfeed articles tagged with unread"
  (interactive)
  (elfeed-search-set-filter "@6-months-ago +unread"))
#+END_SRC

***** Visit entry DWIM

Open the current entry:
- With the browser
- Or if it's a youtube feed, open with [[*Elfeed MPV][mpv]]

#+BEGIN_SRC elisp
(defun my::rss|visit-entry-dwim ()
  "Either open the current entry in eww or play it in mpv."
  (interactive)
  (message "")
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (patterns my::rss:visit-entry-mpv-pattern))
    (while (and patterns (not (string-match (car my::rss:visit-entry-mpv-pattern) (elfeed-entry-link entry))))
      (setq patterns (cdr patterns)))
    (if patterns
        (my::rss:play-entry-with-mpv)
      (if (eq major-mode 'elfeed-search-mode)
          (elfeed-search-browse-url)
        (elfeed-show-visit)))))
#+END_SRC

***** Visit entry with MPV

#+BEGIN_SRC elisp
(defvar my::rss:visit-entry-mpv-pattern
  '("youtu\\.?be")
  "List of regexp to match against elfeed entry link to know
whether to use mpv to visit the link.")

(defun my::rss:play-entry-with-mpv ()
  "Play entry link with mpv."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (url (elfeed-entry-link entry)))
    (my::shell/mpv-youtube-url url)))
#+END_SRC

***** Visit entry with EWW

#+BEGIN_SRC elisp
(defun my::rss::visit-entry-eww ()
  "Open the current entry with eww."
  (interactive)
  (add-hook 'eww-after-render-hook 'eww-readable nil t)
  (let ((buffer (save-window-excursion
                  (eww (elfeed-entry-link elfeed-show-entry))
                  (current-buffer))))
    (switch-to-buffer buffer)))
#+END_SRC

***** Pretty elfeed

#+BEGIN_SRC elisp
(defun my::rss/wrap-entry ()
  "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
  (let ((inhibit-read-only t)
        (inhibit-modification-hooks t))
    (setq-local truncate-lines nil)
    (setq-local shr-width 100)
    (setq-local +zen-text-scale 0.9)
    (mixed-pitch-mode)
    (writeroom-mode)
    (set-buffer-modified-p nil)))

(add-hook 'elfeed-show-mode-hook #'my::rss/wrap-entry)
#+END_SRC

***** Update feeds when saving org-elfeed file :ORG_MODE:

When I save the elfeed org-mode file I want to automatically update the feed list.
Update function taken from [[file:~/.emacs.d/.local/straight/repos/elfeed-org/elfeed-org.el::rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id)][elfeed package]].

#+BEGIN_SRC elisp
(defun my::rss/update-feeds-on-save ()
  (when (and (eq major-mode 'org-mode)
             (string= buffer-file-name (car rmh-elfeed-org-files))))
  (require 'elfeed)
  (rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id))

(add-hook! 'after-save-hook #'my::rss/update-feeds-on-save)
#+END_SRC
***** Capture entry :ORG_MODE:

#+BEGIN_SRC elisp
(defun my::rss::capture/stringify-entry (entry)
  (let ((title (->> (elfeed-entry-title entry)
                    ;; Remove braces, they're just confusing to org links
                    (s-replace "[" "")
                    (s-replace "]" "")))
        (url (elfeed-entry-link entry))
        (author (->> (elfeed-meta entry :authors)
                     car
                     ((lambda (x) (plist-get x :name)))))
        (tags (-some--> (elfeed-entry-tags entry)
                (-remove-item 'unread it)
                (-map #'symbol-name it)
                (s-join ":" it)
                (s-wrap it ":" ":"))))
    (template "[[<<url>>][<<author>> - <<title>>]] <<(when tags tags)>>")))

(defun my::rss::capture|capture ()
  "Capture current entry of elfeed."
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                   elfeed-show-entry
                 (elfeed-search-selected :single)))
         (org-entry (my::rss::capture/stringify-entry entry)))
       (kill-new org-entry)
       (if (s-contains? org-entry "youtube.com")
           (org-capture nil "ew")
        (org-capture nil "er"))))
#+END_SRC

***** Hydra

#+BEGIN_SRC elisp
(defun my::rss/toggle-filter (tag)
  "Toggle elfeed filter TAG or append to filters if non-existent."
  (->> (or (-when-let* (((_ modi) (s-match (t! "\\_<\\([+-]\\)<<tag>>\\_>") elfeed-search-filter))
                        (new-modi (if (string= modi "+") "-" "+")))
             (s-replace-regexp (t! "\\_<\\<<modi>><<tag>>\\_>") (t! "<<new-modi>><<tag>>") elfeed-search-filter))
           (s-append (t! " +<<tag>>") elfeed-search-filter))
       (--tap (progn (setq elfeed-search-filter it)
                     (elfeed-search-update--force)
                     (-log (t! "Filter changed to: <<it>>"))))))

(defun my::rss|counsel-toggle-filter (&optional arg)
  "Toggles a filter in elfeed."
  (interactive "P")
  (ivy-read (t! "Filter: <<elfeed-search-filter>>") (elfeed-db-get-all-tags)
            :action #'my::rss/toggle-filter
            :caller #'my::rss|counsel-toggle-filter))

(defhydra my::rss|hydra ()
   "Elfeed"
   ("j" (evil-next-line) "Next item" :column "Navigate")
   ("k" (evil-previous-line) "Previous item")
   ("t" (my::rss|counsel-toggle-filter) "Tags" :column "Filter")
   ("0" (elfeed-search-set-filter "@2-weeksago +unread") "Unread" :column "Favorites")
   ("f" (elfeed-search-set-filter "@2-weeksago +unread -YOUTUBE -REDDIT") "Feeds")
   ("y" (elfeed-search-set-filter "@2-weeksago +unread +YOUTUBE") "Youtube")
   ("e" (elfeed-search-set-filter "@2-weeksago +unread +REDDIT =emacs") "Reddit: Emacs")
   ("n" (elfeed-search-set-filter "@2-weeksago +unread +REDDIT =nixos") "Reddit: Nixos")
   ("U" (elfeed-update) "Update" :column "actions")
   ("u" (elfeed-search-untag-all-unread) "Mark as unread")
   ("s" (elfeed-db-save) "Save DB")
   ("v" (my::rss|visit-entry-dwim) "Visit")
   ("q" nil "Quit" :color blue))
#+END_SRC
**** Config
***** elfeed-org file

#+BEGIN_SRC elisp
(setq rmh-elfeed-org-files (list (+org/expand-org-file-name "Elfeed/Elfeed.org")))
#+END_SRC

***** Disable sliced images

These don't work if you have a big line-height.

#+BEGIN_SRC elisp
(setq +rss-enable-sliced-images nil)
#+END_SRC

***** Default search

#+BEGIN_SRC elisp
(setq +rss:default-search-filter "@2-week-ago +unread -YOUTUBE")
(setq-default elfeed-search-filter +rss:default-search-filter)
#+END_SRC

**** Bindings
***** Search Mode Bindings

#+BEGIN_SRC elisp
(map!
 :after elfeed
 :map elfeed-search-mode-map
 :gn "r" #'elfeed-update
 (:prefix-map ("g" . "Go")
  :desc "Youtube" :gn "y" (cmd! (elfeed-search-set-filter "@2-week-ago +YOUTUBE +unread"))
  :desc "Normal"  :gn "n" (cmd! (elfeed-search-set-filter "@2-week-ago -YOUTUBE +unread"))
  :desc "Month"   :gn "m" (cmd! (elfeed-search-set-filter "@1-month-ago +unread"))))
#+END_SRC

***** Show Mode Bindings

#+BEGIN_SRC elisp
(map!
 :after elfeed
 :map elfeed-search-mode-map
 :gn "r" #'elfeed-update)
#+END_SRC

***** LocalLeader

#+BEGIN_SRC elisp
(map! :map (elfeed-search-mode-map elfeed-show-mode-map)
      :localleader
      :desc "Filter Hydra" "f" #'my::rss|hydra/body
      :desc "Capture"      "c" #'my::rss::capture|capture
      :desc "Open Eww"     "o" #'my::rss::visit-entry-eww
      :desc "Visit"        "v" #'my::rss|visit-entry-dwim
      (:prefix-map ("s" . "Search")
       :desc "Unread" "u" #'my::rss/filter-by-unread))
#+END_SRC
*** DISABLED IRC :DOOM:

**** Config

#+BEGIN_SRC elisp :tangle no
(after! circe
  (set-irc-server! "chat.freenode.net"
    `(:tls t
      :port 6697
      :nick "floscr"
      :sasl-username ,(+pass-get-user "Irc/freenode.net")
      :sasl-password (lambda (&rest _) (+pass-get-secret "Irc/freenode.net"))
      :channels ("#emacs" "#nixos"))))
#+End_SRC
*** [[https://www.gnu.org/software/emacs/manual/html_mono/eww.html][EWW web browser]]
**** Config
***** Pretty buffer setup

#+begin_src elisp
(defun my::eww*pretty-buffer-setup ()
  "Function docstring"
  (setq-local truncate-lines t)
  (setq-local shr-width 120)
  (setq fill-column 120)
  (setq-local visual-fill-column-center-text t)
  (visual-line-mode 1)
  (visual-fill-column-mode 1))

(add-hook! 'eww-mode-hook #'my::eww*pretty-buffer-setup)
#+end_src

***** Set the max page width

#+BEGIN_SRC elisp
(setq shr-width 100)
#+END_SRC

** Calendar :ORGANIZATION:DOOM:
*** Functions
**** Filtered Calendars
***** Personal (Without Work)

#+BEGIN_SRC elisp
(defun my::calendar::filtered|personal (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "-WORK")))
      (call-interactively #'=calendar)))
#+END_SRC

***** Personal (Just Family)

#+BEGIN_SRC elisp
(defun my::calendar::filtered|just-family (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "+FAMILY|+BIRTHDAY")))
      (call-interactively #'=calendar)))
#+END_SRC

***** Personal (Just Birthdays)

#+BEGIN_SRC elisp
(defun my::calendar::filtered|birthdays (&rest args)
  (interactive)
  (let ((org-agenda-files `(,(+org/expand-org-file-name "Main/contacts.org")))
        (org-agenda-skip-function '(+org/agenda-skip-without-match "+BIRTHDAY")))
      (call-interactively #'=calendar)))
#+END_SRC

***** Personal (Without Family)

#+BEGIN_SRC elisp
(defun my::calendar::filtered|no-family (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "-FAMILY-WORK")))
      (call-interactively #'=calendar)))
#+END_SRC

***** Work

#+BEGIN_SRC elisp
(defun my::calendar::filtered|work (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "+WORK")))
      (call-interactively #'=calendar)))
#+END_SRC
*** Config
**** Custom Holidays (Austrian)

Emacs comes with a lot of custom calendars that I don't want.
This is mostly copied from [[https://thenybble.de/projects/german-emacs-calendar.html][How to set up a german emacs calendar]].

#+begin_src elisp
(use-package! calfw
  :config
  (setq my::calendar::holidays:general
        '((holiday-fixed 1 1 "New Years")
          (holiday-fixed 5 1 "1st Mai")))
  (setq my::calendar::holidays:austria
        `((holiday-fixed 1 6 "Heilige drei Könige")
          (holiday-fixed 5 1 "Staatsfeiertag")
          (holiday-fixed 8 15 "Mariä Himmelfahrt")
          (holiday-fixed 10 26 "Nationalfeiertag")
          (holiday-fixed 11 1 "Allerheiligen")
          (holiday-fixed 12 8 "Mariä Empfängnis")
          (holiday-fixed 12 24 "Weihnachten")
          (holiday-fixed 12 25 "Christtag")
          (holiday-fixed 12 26 "Stefanitag")
          (holiday-easter-etc -2 "Karfreitag")
          (holiday-easter-etc 0 "Ostersonntag")
          (holiday-easter-etc 1 "Ostermontag")
          (holiday-easter-etc 39 "Christi Himmelfahrt")
          (holiday-easter-etc 49 "Pfingstsonntag")
          (holiday-easter-etc 50 "Pfingstmontag")
          (holiday-easter-etc 60 "Fronleichnam")))
  (setq calendar-holidays (append
                           my::calendar::holidays:general
                           my::calendar::holidays:austria
                           holiday-solar-holidays)))
#+end_src



***** General Holidays

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq general-holidays
        '((holiday-fixed 1 1 "New Years")
          (holiday-fixed 5 1 "1st Mai"))))
#+END_SRC

***** Austrian Holidays

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq austrian-holidays
        `((holiday-fixed 1 6 "Heilige drei Könige")
          (holiday-fixed 5 1 "Staatsfeiertag")
          (holiday-fixed 8 15 "Mariä Himmelfahrt")
          (holiday-fixed 10 26 "Nationalfeiertag")
          (holiday-fixed 11 1 "Allerheiligen")
          (holiday-fixed 12 8 "Mariä Empfängnis")
          (holiday-fixed 12 24 "Weihnachten")
          (holiday-fixed 12 25 "Christtag")
          (holiday-fixed 12 26 "Stefanitag")
          ;; variable
          (holiday-easter-etc -2 "Karfreitag")
          (holiday-easter-etc 0 "Ostersonntag")
          (holiday-easter-etc 1 "Ostermontag")
          (holiday-easter-etc 39 "Christi Himmelfahrt")
          (holiday-easter-etc 49 "Pfingstsonntag")
          (holiday-easter-etc 50 "Pfingstmontag")
          (holiday-easter-etc 60 "Fronleichnam"))))
#+END_SRC

***** Set calendars

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq calendar-holidays
        (append
          general-holidays
          austrian-holidays
          holiday-solar-holidays)))
#+END_SRC

**** General

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq calendar-week-start-day 1)
  (setq calendar-time-display-form
        '(24-hours ":" minutes (and time-zone (concat " (" time-zone ")"))))
  (setq calendar-abbrev-length 2))
#+END_SRC
** Calc
*** Config
**** Additional Units

#+BEGIN_SRC elisp
(setq math-additional-units '((GB "1024 * MiB" "Giga Byte")
                              (MB "1024 * KiB" "Mega Byte")
                              (KB "1024 * B" "Kilo Byte")
                              (B nil "Byte")))
#+END_SRC
** Terminal
*** [[https://www.emacswiki.org/emacs/ComintMode][Comint]]
**** Bindings
***** Allow evil enter anywhere :FIX:

Fix for comint mode, throwing an error when pressing enter in the middle of the line.

#+BEGIN_EXAMPLE
error in process filter: End of buffer
#+END_EXAMPLE

#+BEGIN_SRC elisp
(map!
 :after comint
 :map comint-mode-map
 :ni "RET" (cmd! (comint-send-input nil t))
 :n "<C-backspace>" #'comint-clear-buffer)
#+END_SRC
*** [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]]
**** Functions
***** Syntax highlighted cat

#+BEGIN_SRC elisp
(defun my::eshell/colorized-cat (file)
  "Like `cat' but output with Emacs syntax highlighting."
  (with-temp-buffer
    (insert-file-contents file)
    (let ((buffer-file-name file))
      (delay-mode-hooks
        (set-auto-mode)
        (if (fboundp 'font-lock-ensure)
            (font-lock-ensure)
          (with-no-warnings
            (font-lock-fontify-buffer)))))
    (buffer-string)))
#+END_SRC

**** Config
***** COMMENT Custom Aliases

#+BEGIN_SRC elisp
(setq +eshell-aliases
  '(("q"      "exit")
    ("cat"    "my::eshell/colorized-cat $1")
    ("f"      "find-file $1")
    ("bd"     "eshell-up $1")
    ("rg"     "rg --color=always $*")
    ("ag"     "ag --color=always $*")
    ("l"      "ls -lh")
    ("ll"     "ls -lah")
    ("gs"     "git status")
    ("groot"  "cd (projectile-project-root)")
    ("gc"     "git commit")
    ("grha"   "git reset --hard; git clean -f -d")
    ("clear"  "clear-scrollback")))
#+END_SRC

** Org Mode
*** Packages
**** [[https://github.com/astahlman/ob-async][ob-aysnc]] :DOOM:

ob-async enables asynchronous execution of org-babel src blocks via the ~:async~ property.

***** Config

#+BEGIN_SRC elisp
(use-package! ob-async
  :after org-babel)
#+END_SRC
**** [[https://github.com/org-roam/org-roam][org-roam]]

***** Configuration

****** Directories

#+BEGIN_SRC elisp
(setq org-roam-directory (+org/expand-org-file-name "Roam"))
(setq org-roam-db-location (+org/expand-org-file-name "org-roam.db"))
#+END_SRC
**** org-protocol

#+begin_src elisp
(use-package! org-protocol)
#+end_src

*** Functions
**** Jump to definition for tangled files

Take me to the literate source file when using ~find-function~ etc.

#+BEGIN_SRC elisp
(defadvice! +org|try-org-babel-tangle-jump-to-org (&optional arg1)
  :after '(find-function
           find-variable)
  (ignore-errors
    (org-babel-tangle-jump-to-org)))
#+END_SRC
**** Fetch link title

Fetches the link title for the current link using the ~get_url_title~ command from [[https://github.com/floscr/nim-utils#get_url_title][floscr/nim-utils: A bunch of simple tools to use with my nixos setup written in nim.]]

#+begin_src elisp
(defun my::org|fetch-this-org-link-title ()
  "Fetches the title for the plain link under the cursor.
Needs get_url_title script"
  (interactive)
  (require 'org-ml)
  (-when-let* ((el (->> (org-ml-parse-this-object)
                        (--id-when (and (org-ml-is-type 'link it)
                                        (eq (org-ml-get-property :format it) 'plain)))))
               (url (org-ml-get-property :raw-link el))
               (title (->> (shell-command-to-string (t! "get_url_title \"<<url>>\""))
                           (s-trim)))
               (from (org-element-property :begin el))
               (to (org-element-property :end el)))
    (delete-region from to)
    (insert (t! "[[<<url>>][<<title>>]]"))))

(defun my::org-agenda|fetch-this-org-link-title ()
  "Fetches the title for the plain link under the cursor.
Needs get_url_title script"
  (interactive)
  (require 'org-ml)
  (save-window-excursion
    (org-agenda-switch-to)
    (-when-let* ((link-pos (-some->> (org-ml-parse-this-headline)
                             (org-ml-get-property :title)
                             (--find (org-ml-is-type 'link it))
                             (org-ml-get-property :begin))))
      (goto-char link-pos)
      (my::org|fetch-this-org-link-title)))
  (org-agenda-redo))
#+end_src
**** Read timestamp to string

Use the interactive timestamp interface to read an org string

#+begin_src elisp
(defun my::org/read-timestamp-inactive-str ()
  (with-temp-buffer
    (org-time-stamp-inactive)
    (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

** Hydras

* Bindings
** General

#+BEGIN_SRC elisp
(map! :g "C-±" #'+popup/raise)
#+END_SRC

*** Disable emacs-state-toggle

#+BEGIN_SRC elisp
(map! :nm "C-z" nil)
#+END_SRC

*** Auto indent bracket openings
:PROPERTIES:
:SOURCE:   [[https://xenodium.com/emacs-smartparens-auto-indent/][Emacs smartparens auto-indent]]
:END:

Automatically indent and format when opening area betwen to delimiters.

#+begin_src elisp
(defun my::text/indent-between-pair (&rest _ignored)
  (newline)
  (indent-according-to-mode)
  (forward-line -1)
  (indent-according-to-mode))

(sp-local-pair 'prog-mode "{" nil :post-handlers '((my::text/indent-between-pair "RET")))
(sp-local-pair 'prog-mode "[" nil :post-handlers '((my::text/indent-between-pair "RET")))
(sp-local-pair 'prog-mode "(" nil :post-handlers '((my::text/indent-between-pair "RET")))
#+end_src

** Super

#+BEGIN_SRC elisp
(map!
 (:map override
   :g "s-n" #'evil-buffer-new
   :g "s-;" #'eval-expression
   :g "s-a" #'mark-whole-buffer
   :g "s-s" #'save-buffer
   :g "s-v" #'yank
   :g "s-x" #'execute-extended-command
   :g "s-y" #'helm-show-kill-ring

   ;; Text scale
   :g "s-="   #'doom/increase-font-size
   :g "s--"   #'doom/decrease-font-size
   :g "s-0"   #'doom/reset-font-size))
#+END_SRC

** Evil
*** Config
**** Use global ex by default

I almost always want global search and replace, doom changed this in [[orgit-rev:~/.emacs.d/::1a6f5086400d164178016784aac12114934c8245][1a6f50864]].
To undo this behavior just add =g= flag

#+BEGIN_SRC elisp
(setq evil-ex-substitute-global t)
#+END_SRC

*** Motions
**** Additional text objects

- =q= for any type of quote
- =B= for curly braces
- =r= for square brackets

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "`")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "`")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket)
  (define-key evil-inner-text-objects-map "B" 'evil-inner-curly))
#+END_SRC

**** Up to next/previous indent

Text objects for lines after or before the current line,
that have the same or deeper indent.

#+BEGIN_SRC elisp
(defun evil-indent-plus--line-down-indent-range (&optional point)
  (require 'evil-indent-plus)
  (let* ((range (evil-indent-plus--same-indent-range point))
         (base (point))
         (begin (point)))
    (list begin (cl-second range) base)))

(evil-define-text-object evil-indent-plus-i-indent-line-down (&optional count beg end type)
  "Text object describing the block with the same (or greater) indentation as the current line,
and the line above, skipping empty lines."
  :type line
  (require 'evil-indent-plus)
  (evil-indent-plus--linify (evil-indent-plus--line-down-indent-range)))

(define-key evil-inner-text-objects-map "+" 'evil-indent-plus-i-indent-line-down)

(defun evil-indent-plus--line-up-indent-range (&optional point)
  (require 'evil-indent-plus)
  (let* ((range (evil-indent-plus--same-indent-range point))
         (base (point))
         (begin (point)))
    (list begin (cl-first range) base)))

(evil-define-text-object evil-indent-plus-i-indent-line-up (&optional count beg end type)
  "Text object describing the block with the same (or greater) indentation as the current line,
and the line above, skipping empty lines."
  :type line
  (require 'evil-indent-plus)
  (evil-indent-plus--linify (evil-indent-plus--line-up-indent-range)))

(define-key evil-inner-text-objects-map "-" 'evil-indent-plus-i-indent-line-up)
#+END_SRC

**** Little Word Motion

#+BEGIN_SRC elisp
(defun load-evil-camel-case-motion ()
  (require 'evil-little-word)
  (define-key evil-normal-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-normal-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "i M-w") 'evil-inner-little-word))

(load-evil-camel-case-motion)
#+END_SRC
**** Sort Motion

#+BEGIN_SRC elisp
(evil-define-operator +evil/sort (beg end)
  "Sort lines with motion"
  (interactive "<r>")
  (sort-lines nil beg end))

(map!
 (:after evil
    :m "gS" #'+evil/sort))
#+END_SRC

**** Case Conversion

Copied code from [[https://github.com/strickinato/evil-briefcase][strickinato/evil-briefcase]] since it's not maintained anymore.
Convert case motion via ~Z~.

Example pressing ~ZciW~ would convert the inner =Word= into =camelCase=

#+BEGIN_SRC elisp
(evil-define-operator +evil/case-upper (beg end type)
  "Convert text to upper case."
  (if (eq type 'block)
      (evil-apply-on-block #'s-upcase beg end nil)
    (let ((str (s-upcase (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-lower (beg end type)
  "Convert text to lowercase."
  (if (eq type 'block)
      (evil-apply-on-block #'s-downcase beg end nil)
    (let ((str (s-downcase (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-camel-upper (beg end type)
  "Convert text to CamelCase with a Capital C"
  (if (eq type 'block)
      (evil-apply-on-block #'s-upper-camel-case beg end nil)
    (let ((str (s-upper-camel-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-camel-lower (beg end type)
  "Convert text to camelCase with a small C"
  (if (eq type 'block)
      (evil-apply-on-block #'s-lower-camel-case beg end nil)
    (let ((str (s-lower-camel-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-snake-lower (beg end type)
  "Convert text to snake_case, slithering"
  (if (eq type 'block)
      (evil-apply-on-block #'s-snake-case beg end nil)
    (let ((str (s-snake-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-snake-upper (beg end type)
  "Convert text to SNAKE_CASE, AKA SCREAMING_SNAKE_CASE"
  (if (eq type 'block)
      (evil-apply-on-block #'s-snake-case beg end nil)
    (let ((str (s-upcase (s-snake-case (buffer-substring-no-properties beg end)))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-kebab-upper (beg end type)
  "Convert text to KEBAB-KASE, mmmm... THICK MEAT"
  (if (eq type 'block)
      (evil-apply-on-block #'s-dashed-words beg end nil)
    (let ((str (s-dashed-words (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert (upcase str)))))

(evil-define-operator +evil/case-kebab-lower (beg end type)
  "Convert text to kebab-kase, mmmm... hyphens"
  (if (eq type 'block)
      (evil-apply-on-block #'s-dashed-words beg end nil)
    (let ((str (s-dashed-words (buffer-substring-no-properties beg end))))
        (delete-region beg end)
        (insert str))))

(map!
 (:after evil
  :m "Zu" #'+evil/case-upper
  :m "Zl" #'+evil/case-lower
  :m "ZC" #'+evil/case-camel-upper
  :m "Zc" #'+evil/case-camel-lower
  :m "ZS" #'+evil/case-snake-upper
  :m "Zs" #'+evil/case-snake-lower
  :m "ZK" #'+evil/case-kebab-upper
  :m "Zk" #'+evil/case-kebab-lower))
#+END_SRC

**** Org Src Block

Matches any block with ~BEGIN_~, e.g.: SRC blocks.

#+BEGIN_SRC elisp
(defun +evil-org/src-block ()
  "Matches src blocks using org-element-context."
  (-when-let* ((ctx (org-element-context))
               (type (car ctx))
               (ctx (cond
                     ((equal type 'src-block) ctx)
                     ((equal type 'example-block) ctx)
                     ((equal type 'quote-block) ctx)
                     ;; Inside quote blocks org-element-context matches the paragraphs
                     ;; So we have to take the parent block to get the quote-block
                     ((equal type 'paragraph)
                      (-some->> ctx
                        (nth 1)
                        ((lambda (x) (doom-plist-get x :parent)))
                        (--id-when (equal (car it) 'quote-block)))))))
    ctx))

(evil-define-text-object +evil-org-inner-src-block (count &optional beg end type)
  "Select an org src/quote/example block object."
  (evil-org-select-inner-element (+evil-org/src-block)))

(evil-define-text-object +evil-org-an-src-block (count beg end type)
  "An org object.
Matches urls and table cells."
  (evil-org-select-an-element (+evil-org/src-block)))

(after! evil-org
  (evil-define-key '(visual operator) evil-org-mode-map
    "ib" #'+evil-org-inner-src-block
    "ab" #'+evil-org-an-src-block))
#+END_SRC

*** Normal Bindings
**** Window navigation

Fix window navigation for various modes.
I don't like pressing ~C-w~ or ~SPC w~ as leader to navigate,
so I have to work around it:

#+BEGIN_SRC elisp
(map!
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)

(map!
 :map (image-mode-map
       magit-diff-mode-map
       magit-revision-mode-map
       magit-status-mode-map
       eshell-mode-map
       evil-org-mode-map)
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)

(add-hook! 'eshell-first-time-mode-hook
  (map!
   :map eshell-mode-map
   :en "C-h"   #'evil-window-left
   :en "C-j"   #'evil-window-down
   :en "C-k"   #'evil-window-up
   :en "C-l"   #'evil-window-right))

(map!
 :map org-agenda-mode-map
 "C-h"  #'evil-window-left
 "C-j"  #'evil-window-down
 "C-k"  #'evil-window-up
 "C-l"  #'evil-window-right)
#+END_SRC

**** History navigation in minibuffer

#+BEGIN_SRC elisp
(define-key minibuffer-local-map "\C-p" 'previous-history-element)
(define-key minibuffer-local-map "\C-n" 'next-history-element)
#+END_SRC

**** Jump to last buffer

#+BEGIN_SRC elisp
(map! :n "gb" #'evil-switch-to-windows-last-buffer)
#+END_SRC

**** Select last paste
:PROPERTIES:
:SOURCE:   https://emacs.stackexchange.com/a/21093
:END:

#+BEGIN_SRC elisp
(defun +evil|select-pasted ()
  (interactive)
  (let ((start-marker (evil-get-marker ?\[))
        (end-marker (evil-get-marker ?\])))
    (evil-visual-select start-marker end-marker)))

(map! :n "gp" #'+evil|select-pasted)
#+END_SRC

**** Go up one directory from the current buffer

#+BEGIN_SRC elisp
(map! :m "-"  #'dired-jump)
#+END_SRC

**** Visual Line Mode Navigation

#+BEGIN_SRC elisp
(map! :map visual-line-mode-map
      :nv "j" #'evil-next-visual-line
      :nv "k" #'evil-previous-visual-line)
#+END_SRC

*** Insert Bindings

Insert Mode bindings, mostly unicode insertion and workaround for german umlaut.

**** Insert from the kill ring in insert mode

#+BEGIN_SRC elisp
(map! :i "A-y" #'helm-show-kill-ring)
#+END_SRC

**** Unicode Characters

#+BEGIN_SRC elisp
(map!
 :i "C-y"   #'helm-show-kill-ring
 :i "M-`"   (cmd! (insert "°"))
 :i "M-."   (cmd! (insert "…"))
 :i "M-^"   (cmd! (insert "°"))
 :i "M-l"   (cmd! (insert "λ"))
 :i "M-w"   (cmd! (insert "⚠"))
 :i "M-i"   (cmd! (insert "ℹ")))
#+END_SRC

*** Square Bracket Bindings

Global ~[~ & ~]~ combinator bindings

**** Dumb Jump

#+BEGIN_SRC elisp
(map!
 :n "]F" #'dumb-jump-go
 :n "[F" #'dumb-jump-back)
#+END_SRC

**** Flycheck Error Jumping

#+BEGIN_SRC elisp
(map!
 :n "]e" #'flycheck-next-error
 :n "[e" #'flycheck-previous-error)
#+END_SRC
**** Projectile Alternate file finding

#+BEGIN_SRC elisp
(map!
 :n "]1" #'projectile-toggle-between-implementation-and-test
 :n "[1" #'projectile-toggle-between-implementation-and-test)
#+END_SRC
*** Comman Bindings

#+begin_src elisp
(map!
 :map (clojurescript-mode-map clojure-mode-map)
 :n ",r" #'raise-sexp
 :n ",f" #'sp-forward-barf-sexp
 :n ",b" #'sp-backward-barf-sexp
 :n ",d" #'sp-kill-sexp
 :n ",," #'sp-forward-sexp
 :n ",n" #'sp-next-sexp
 :n ",y" #'sp-clone-sexp
 :n ",<" #'transpose-sexps
 :n ",u" #'sp-backward-up-sexp
 :n ",T" #'clojure-thread
 :n ",T" #'clojure-thread)
#+end_src

*** Text Objects

Custom evil text objects mostly stolen from [[https://github.com/jerryxgh/lambda-x/blob/master/lambda-evil.el#L236][Spacemacs|define-text-object-regexp]].

**** Utils
***** Define Text Objects

#+BEGIN_SRC elisp
(defmacro +evil/define-text-object-regexp (key name start-regexp end-regexp)
  "Define a text object.
START-REGEXP and END-REGEXP are the boundaries of the text object."
  (let ((inner-name (make-symbol (concat "evil-inner-" name)))
        (outer-name (make-symbol (concat "evil-outer-" name))))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regexp ,end-regexp beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regexp ,end-regexp beg end type count t))
       (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
       (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))
#+END_SRC
**** Config

#+BEGIN_SRC elisp
(+evil/define-text-object-regexp "~" "tilde" "~" "~")
(+evil/define-text-object-regexp "=" "equal" "=" "=")
(+evil/define-text-object-regexp "|" "bar" "|" "|")
(+evil/define-text-object-regexp "*" "star" "*" "*")
(+evil/define-text-object-regexp "$" "dollar" "$" "$")
(+evil/define-text-object-regexp "%" "percent" "%" "%")
(+evil/define-text-object-regexp "/" "slash" "/" "/")
(+evil/define-text-object-regexp "_" "underscore" "_" "_")
(+evil/define-text-object-regexp "-" "hyphen" "-" "-")
#+END_SRC

**** Quotes Text Object

Changes the text matching inside quotes with ~q~ motion (e.g. ~ciq~)
Change inner bracket with ~r~

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket))
#+END_SRC
*** Ex Commands

Extend the default evil ex commands from [[file:~/.emacs.d/modules/editor/evil/+commands.el::;;; editor/evil/+commands.el -*- lexical-binding: t; -*-][+commands.el]]

#+BEGIN_SRC elisp
(after! evil-ex
  :config
  (evil-ex-define-cmd "W" #'evil-write))
#+END_SRC

*** MultiEdit

#+BEGIN_SRC elisp
(map! :nv "C-M-d" #'evil-multiedit-match-all)
#+END_SRC

*** Jump with =tab=

#+BEGIN_SRC elisp
(map! :n [tab] (general-predicate-dispatch nil
                 (and (featurep! :editor fold)
                      (save-excursion (end-of-line) (invisible-p (point))))
                 #'+fold/toggle
                 (fboundp 'evil-jump-item)
                 #'evil-jump-item)
      :v [tab] (general-predicate-dispatch nil
                 (and (bound-and-true-p yas-minor-mode)
                      (or (eq evil-visual-selection 'line)
                          (not (memq (char-after) (list ?\( ?\[ ?\{ ?\} ?\] ?\))))))
                 #'yas-insert-snippet
                 (fboundp 'evil-jump-item)
                 #'evil-jump-item))
#+END_SRC
*** TODO Paste Fix

Evil pastes at the current cursor, which I don't expect it to do.
Most of the time it requires me to move into insert mode, move one character,
and then do my function.

#+BEGIN_SRC elisp
(defun +evil/normal-mode-paste-fix (fn &optional insert-char)
  "Move forward one character and then paste."
  (interactive)
  (if (and (evil-normal-state-p)
           (my::buffer/line-contains "[^\s]"))
      (progn
        (forward-char 1)
        (when (and insert-char (looking-at insert-char))
          (insert insert-char))
        (let ((line (substring-no-properties (thing-at-point 'line))))
          (call-interactively fn)
          (when (eq line (substring-no-properties (thing-at-point 'line)))
            (delete-char 1))))
    (call-interactively fn)))
#+END_SRC

*** TODO Store all yanks in extra register

#+begin_src elisp :tangle no
(defvar +evil:last-yank nil)

(defun +evil/save-to-yank-register (&rest _rest)
  "Save the last yank to a specific register that only gets overwritten by yanks.
So deletes wont affect this register."
  (setq +evil:last-yank (evil-get-register ?\")))

(defun +evil/insert-from-yank-register ()
  "Save the last yank to a specific register that only gets overwritten by yanks.
So deletes wont affect this register."
  (-some->> +evil:last-yank
    (insert)))

;; (advice-add 'evil-yank :after #'+evil/save-to-yank-register)
#+end_src

** Leader

#+BEGIN_SRC elisp
(map!
 :leader
 "RET"  #'my::jumpy|main
 "'"  #'+popup/toggle
 "au" #'undo-tree-visualize
 "-"  #'quick-calc)
#+END_SRC

*** Buffer

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("b" . "buffer")
  :desc "Rename Buffer"  "r" #'rename-buffer
  :desc "Rename Buffer"  "+" #'persp-add-buffer))
#+END_SRC

*** File / Goto

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("f" . "file")
  :desc "Open Private Config" "P" (cmd! (find-file (f-join doom-private-dir "config.org")))
  (:prefix-map ("g" . "goto")
   :desc "Drive"                 "/" #'my::counsel|mounted-drives
   :desc "Desktop"               "D" (cmd! (find-file "~/Desktop"))
   :desc "Config"                "." (cmd! (find-file "~/.config"))
   :desc "Code"                  "c" (cmd! (find-file "~/Code"))
   :desc "Last captured"         "C" (cmd! (org-goto-marker-or-bmk org-capture-last-stored-marker))
   :desc "Downloads"             "d" (cmd! (find-file "~/Downloads"))
   :desc "Elfeed"                "e" (cmd! (find-file (car rmh-elfeed-org-files)))
   :desc "Media"                 "m" (cmd! (find-file "~/Media"))
   :desc "Music"                 "M" (cmd! (find-file "~/Media/Music"))
   :desc "Notes"                 "n" (cmd! (find-file org-directory))
   :desc "Project Root"          "p" (cmd! (find-file (projectile-project-root)))
   :desc "Last refiled"          "r" (cmd! (org-refile-goto-last-stored))
   :desc "Tmp"                   "t" (cmd! (find-file "/tmp"))
   :desc "Home"                  "h" (cmd! (find-file "~"))
   :desc "Run (Mounted Drives)"  "r" #'my::dired|find-mounted-drive)))
#+END_SRC

*** Git

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("g" . "git")
  :desc "Amend Commit (No Message)"           "A" (cmd! (magit-commit-amend "--no-edit"))
  :desc "Blame"                               "B" #'magit-blame
  :desc "Changed Files"                       "F" #'my::magit|counsel-changed-files
  :desc "New Branch"                          "N" #'magit-branch-spinoff
  :desc "Show revision original File"         "O" #'my::magit|show-revision-original
  :desc "Map-editor Changed Files"            "T" (cmd! (my::magit|counsel-changed-files "map-editor"))
  :desc "Amend Commit"                        "a" #'magit-commit-amend
  :desc "Checkout"                            "b" #'magit-checkout
  :desc "Diff"                                "d" #'magit-diff
  :desc "Push"                                "p" #'magit-push
  :desc "Undo"                                "u" #'my::magit|git-undo
  :desc "Worktree Popup"                      "w" #'magit-worktree
  :desc "New Org Pr"                          "!" #'+MM|new-pr-from-branch
  (:prefix ("f" . "file")
   :desc "VC file"                            "F" #'vc-revision-other-window)
  (:prefix ("l" . "list")
   :desc "List gists"                         "g" #'+gist:list
   :desc "List submodules"                    "n" #'magit-list-submodules
   :desc "List issues"                        "p" #'forge-list-issues
   :desc "List pull requests"                 "r" #'forge-list-pullreqs
   :desc "List pull awaiting review requests" "R" #'forge-list-requested-reviews
   :desc "List notifications"                 "s" #'forge-list-notifications)))
#+END_SRC

*** Insert

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("i" . "insert")
   :desc "New Snippet"    "S" #'+snippets/new
   :desc "Killring"       "y" #'helm-show-kill-ring))
#+END_SRC

*** Open

#+BEGIN_SRC elisp
(map!
 :leader
 (:desc "open" :prefix "o"
   :desc "Calc"            :g "c" #'calc
   :desc "Calc"            :g "C" #'=calendar
   :desc "Elfeed"          :g "e" #'+eshell/toggle
   :desc "Eshell"          :g "E" #'my::elfeed|open
   :desc "Irc"             :g "i" #'=irc
   :desc "Mail"            :g "m" #'=mu4e
   :desc "Proced"          :g "p" #'proced
   :desc "Snippet"         :g "s" #'+snippets/edit
   :desc "Flycheck Errors" :g "$" #'flycheck-list-errors))
#+END_SRC

*** Projects

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("p" . "project")
  :desc "Workspace Project Files" "P" #'my::workspaces|find-workspace-project-file
  :desc "Project VC"              "v" #'my::workspaces|workspace-project-vc
  :desc "Project Bookmarks"       "RET" #'my::jumpy|launch))
#+END_SRC

*** Search

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("s" . "search")
  :desc "Project for symbol" "P" #'+default/search-project-for-symbol-at-point
  :desc "Occur" "o" #'occur
  :desc "Web Lookup" "w" #'+lookup/online
  :desc "Web Lookup with prompt" "W" #'+lookup/online-select))
#+END_SRC

*** Toggle

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("t" . "toggle")
   :desc "Theme Dark/Light" "t" #'my::ui|toggle-theme
   :desc "Auto Completion" "c" #'+company/toggle-auto-completion))
#+END_SRC

*** Window

#+BEGIN_SRC elisp
(map!
 :leader
 :desc  "Split Vertical"        "|"    #'evil-window-vsplit
 :desc  "Split Horizontal"      "-"    #'evil-window-split

 (:prefix-map ("w" . "window")
  :desc  "Delete"               "d"    #'delete-window
  :desc  "Ace Delete Windo"     "D"    #'ace-delete-window
  :desc  "New"                  "n"    #'evil-window-new

  :desc  "Undo"                 "u"    #'winner-undo
  :desc  "Redo"                 "r"    #'winner-redo
  :desc  "Enlargen"             "o"    #'doom/window-enlargen

  :desc  "Toggle Split"         "T"    #'+window|toggle-split-direction

  :desc  "Split Vertical"       "|"    #'evil-window-vsplit
  :desc  "Split Horizontal"     "_"    #'evil-window-split

  :desc  "Move Left"            "H"    #'+evil/window-move-left
  :desc  "Move Down"            "U"    #'+evil/window-move-down
  :desc  "Move Up"              "K"    #'+evil/window-move-up
  :desc  "Move Right"           "L"    #'+evil/window-move-right

  :desc  "Set Height"           "C-_"  #'evil-window-set-height
  :desc  "Set Height"           "C-|"  #'evil-window-set-width

  :desc  "Swap"                 "SPC"  #'ace-swap-window
  :desc  "Toggle Locked"        "#"    #'my|toggle-window-dedicated
  :desc "Toggle Locked"         "."    #'+popup/raise))
#+END_SRC

*** Workspace

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("TAB" . "workspace")
  :desc "Switch to"     "." #'my::workspaces/switch-to
  :desc "Close others"  "o" #'my::workspaces|close-others
  :desc "Create"        "c" #'my::workspaces/new-named
  :desc "Rename"        "," #'+workspace/rename
  :desc "Project Files" "p" #'my::workspaces|find-workspace-project-file
  :desc "Project VC"    "v" #'my::workspaces|workspace-project-vc
  :desc "Clone"         "C" (cmd!
                             (+workspace/new (format "Clone: %s" (+workspace-current-name)) t)
                             (message "Cloned current workspace %s" (+workspace-current-name)))
  :desc "Switch to last workspace" "0"   #'+workspace/other))
#+END_SRC

*** TODO Yank

#+BEGIN_SRC elisp
(defun +yank/execute-action (x &optional insert)
  "Copy the the yank or insert it during insert mode."
  (interactive)
  (cond
   ((or (evil-insert-state-p) insert) (insert x))
   (t (my/kill-and-message x)))
  x)

(defun +yank/dired-path ()
  "Returns the current dired entry or the buffer directory."
  (or (dired-file-name-at-point) dired-directory))

(defun +yank/buffer-filename ()
  "Returns the current buffers file name if possible."
  (cond ((doom-dired-buffer-p (current-buffer)) (+yank/dired-path))
        (buffer-file-name buffer-file-name)
        (org-src-source-file-name org-src-source-file-name)
        (t nil)))

(defun +yank/buffer-path ()
  "Returns the current buffers path."
  (or (+yank/buffer-filename) default-directory))

(defun +yank|filename (&optional insert)
  "Yank the buffer file name."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-filename)
     ;; When pointing at a directory at dired, I still take the directory
     ((lambda (x) (if (f-file? x)
                      (file-name-directory x)
                    x)))
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|base (&optional insert)
  "Yank the buffer files base name."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-filename)
     (file-name-base)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|directory (&optional insert)
  "Yank the buffer files directory."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     (file-name-directory)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|path (&optional insert)
  "Yank the buffer files path."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|relative-to-project (&optional insert)
  "Yank the buffer path relative to the projectile-project-root."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     (f-full)
     ((lambda (x)
        (or
         (->> (s-replace (projectile-project-root) "" x)
              (-id-when #'s-present?))
         x)))
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(map!
 :leader
 (:prefix-map ("y" . "Yank")
  :desc "filename"            "f" #'+yank|filename
  :desc "base"                "b" #'+yank|base
  :desc "directory"           "d" #'+yank|directory
  :desc "path"                "p" #'+yank|path
  :desc "path"                "y" #'+yank|path
  :desc "relative to project" "r" #'+yank|relative-to-project))
#+END_SRC

** Local-Leader
*** Eshell

#+BEGIN_SRC elisp
(defun my::eshell/init-keymap ()
  "Setup additional custom eshell keybindings to already existing doom bindings. This must be done in a hook because eshell-mode
redefines its keys every time `eshell-mode' is enabled."
  (map! :map eshell-mode-map
        :in "C-p"         #'eshell-previous-input
        :in "C-n"         #'eshell-next-input

        :localleader "l"  #'eshell/clear))

(add-hook 'eshell-first-time-mode-hook #'my::eshell/init-keymap)
#+END_SRC

*** Elisp

#+BEGIN_SRC elisp
(map! :map emacs-lisp-mode-map
      :gni "M-;"   #'symex-mode-interface
      :n "s-k"   (cmd! (sp-transpose-sexp)
                     (evil-previous-line))
      :n "s-j"   (cmd! (sp-push-hybrid-sexp)
                     (evil-next-line))
      :n "s-r" #'eval-buffer
      :n "g]"  #'sp-slurp-hybrid-sexp
      :n "g["  #'sp-forward-barf-sexp
      :localleader
      :desc "Ly Mode"                 "l"  #'+ly-mode
      :desc "Jump to tangled source"  "j"  #'org-babel-tangle-jump-to-org
      :desc "Symex Mode"              "s" #'symex-mode-interface
      :desc "Raise sexp"              "<" #'raise-sexp
      :desc "Barf Sexp"               ">" #'barf-sexp)
#+END_SRC

*** Haskell

#+BEGIN_SRC elisp
(map! :map haskell-mode-map
      :localleader
      :desc "Stylish" "s" #'my::haskell|autofix)
#+END_SRC

*** Bash

#+BEGIN_SRC elisp
(map! :map sh-mode-map
      :localleader
      :desc "Eval Region"  "e" #'sh-execute-region
      :desc "Eval Region"  "E" #'executable-interpret)
#+END_SRC

*** Git

#+BEGIN_SRC elisp
(map! :map magit-mode-map
      :localleader
      :desc "Toggle Magit Buffer Lock" "#" #'magit-toggle-buffer-lock)
#+END_SRC

*** Reasonml

#+BEGIN_SRC elisp
(map! :map reason-mode-map
      :localleader
      :desc "Eval Region"  "r" #'refmt)
#+END_SRC

*** Mail

#+BEGIN_SRC elisp
(map! :map (mu4e-view-mode-map mu4e-headers-mode-map)
      :localleader
      :g "x" (cmd!
              (require 'org-mu4e)
              (org-mu4e-store-and-capture)))
#+END_SRC

*** mail

#+BEGIN_SRC elisp
(map! :map (mu4e-view-mode-map mu4e-headers-mode-map)
      :localleader
      :g "x" (cmd!
              (require 'org-mu4e)
              (org-mu4e-store-and-capture)))
#+END_SRC
*** Images

#+BEGIN_SRC elisp
(map! :map 'image-mode-map
      :desc "Zoom in" :gn "+" #'image-increase-size
      :desc "Zoom in" :gn "-" #'image-decrease-size
      :desc "Zoom in" :gn "0" (cmd! (image-transform-set-scale 1)))
#+END_SRC

** Minibuffer
*** Copy and Paste from the minibuffer

Since the minibuffer has no evil mode, i've got these bindings to help out:
- ~M-c~: Copy the minibuffer line
- ~M-v~: Paste from clipboard to minibuffer (Same as ~C-r 0~)
         This also removes trailing newlines

#+BEGIN_SRC elisp
(defun my::evil|paste-pruned ()
  "Paste the current clipboard pruned from newlines"
  (interactive)
  (insert (s-trim (shell-command-to-string "pbpaste")))
  (doom/forward-to-last-non-comment-or-eol))

(defun my::minibuffer|copy-line ()
  "Copies the minibuffer content to the clipboard"
  (interactive)
  (save-excursion
    (doom/forward-to-last-non-comment-or-eol)
    (set-mark-command nil)
    (doom/backward-to-bol-or-indent)
    (kill-ring-save (mark) (point))))

(defun my::minibuffer/setup-copy-bindings ()
  "Set up keybindings for the minibuffer"
  (local-set-key (kbd "s-v") 'my::evil|paste-pruned)
  (local-set-key (kbd "s-c") 'my::minibuffer|copy-line))

(add-hook 'minibuffer-setup-hook 'my::minibuffer/setup-copy-bindings)

;; (define-key! :keymaps +default-minibuffer-maps
;;   "C-w" 'sp-backward-delete-word)
#+END_SRC

* Hacks
** Override default browser

Why does this not work out of the box?

#+BEGIN_SRC elisp
(defun browse-url-brave (url &optional _new-window)
  "Ask the Chromium WWW browser to load URL.
Default to the URL around or before point.  The strings in
variable `browse-url-chromium-arguments' are also passed to
Chromium.
The optional argument NEW-WINDOW is not used."
  (interactive (browse-url-interactive-arg "URL: "))
  (setq url (browse-url-encode-url url))
  (let* ((process-environment (browse-url-process-environment)))
    (apply #'start-process
           (concat "brave " url) nil
           "brave"
           (append
            browse-url-chromium-arguments
            (list url)))))

(pcase (getenv "BROWSER")
  ("brave" (setq browse-url-browser-function 'browse-url-brave))
  ("chromium" (setq browse-url-browser-function 'browse-url-chromium))
  ("firefox" (setq browse-url-browser-function 'browse-url-firefox)))
#+END_SRC

** Fix ~evil-org-mode-map~

Fixes =(void-function ad-Advice-newline-and-indent)= error for now.
I honestly don't know where this comes from.

#+BEGIN_SRC elisp
(map!
 :map evil-org-mode-map
 :after org
 :i [return] #'org-return-and-maybe-indent)
#+END_SRC
** Prevent ~woman defvaralias~ error

I'm using ~woman~ for manuals, but it throws this error on first launch

#+BEGIN_QUOTE
Warning (defvaralias): Overwriting value of ‘woman-topic-history’ by aliasing to ‘Man-topic-history’
#+END_QUOTE

Solution from here: [[https://discord.com/channels/406534637242810369/406554085794381833/703782241766998067][Doom Discord question]]

#+BEGIN_SRC elisp
(add-to-list 'warning-suppress-types '(defvaralias))
#+END_SRC

** Stupid workaround where splitting a window with evil-ex-results breaks emacs...

#+BEGIN_SRC elisp
(advice-add 'evil-window-vsplit :after #'evil-force-normal-state)
(advice-add 'evil-window-split :after #'evil-force-normal-state)
#+END_SRC
** Emacs 28 Head Workaround

#+begin_src elisp
(with-no-warnings
      (defclass xref-location () ()
        :documentation "(Obsolete) location represents a position in a file or buffer."))
#+end_src
** Make optional

#+begin_src elisp
(defmacro define-obsolete-function-alias ( obsolete-name current-name &optional when
                                           docstring)
  "Set OBSOLETE-NAME's function definition to CURRENT-NAME and mark it obsolete.

\(define-obsolete-function-alias \\='old-fun \\='new-fun \"22.1\" \"old-fun's doc.\")

is equivalent to the following two lines of code:

\(defalias \\='old-fun \\='new-fun \"old-fun's doc.\")
\(make-obsolete \\='old-fun \\='new-fun \"22.1\")

WHEN should be a string indicating when the function was first
made obsolete, for example a date or a release number.

See the docstrings of `defalias' and `make-obsolete' for more details."
  (declare (doc-string 4))
  `(progn
     (defalias ,obsolete-name ,current-name ,docstring)
     (make-obsolete ,obsolete-name ,current-name ,when)))
#+end_src
** Fix Flycheck for emacs 29

#+begin_src elisp
(defun +flycheck/fix-emacs-29-save (&rest args)
  (flycheck-clear)
  (flycheck-buffer))

(advice-add #'flycheck-handle-save :after #'+flycheck/fix-emacs-29-save)
#+end_src
