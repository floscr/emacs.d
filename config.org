#+TITLE: Doom Emacs configuration
#+AUTHOR: floscr
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: org-startup-folded: showall
#+DISABLE_SPELLCHECKER: t
#+TODO: TODO(t) ACTIVE(a) | INACTIVE(i) DISABLED(d)

* Docs
** Code style

Most of the code here will follow a functional mindset using [[https://github.com/magnars/dash.el][dash.el]] and [[https://github.com/magnars/s.el][s.el]].
I will prefer those functions over built in functions if they are nicer to use.

I often use my helper function [[*Template Literals][(t!)]] for template strings.

** Variable Naming

All my private functions have the prefix ~my~.
It's the only prefix where you can assume that packages/emacs/doom won't override it and vice-versa.

*** Schema

- ~my-namespace~
  Its not pretty, but it's the only way to work with emacs-lisps global scope for everything.
  - ~my-namespace::sub-namespace~
- ~my:variable~: Variable
- ~my/function~: Private function
  - ~my-namespace/function~: Private function with namespace
- ~my|function~: Interactive function
  - ~my-namespace|function~: Interactive function
- ~my@function~: Macro
- ~my*hook~: Hook function

*** Exceptions

There are only a few exceptions, which I'm keeping without the prefix for ease of writing/reading:

- [[*Dash Extensions][Dash Extensions]]
  Prefixed with a ~-~
- [[*Template Literals][Template Literals]]
  ~template~ or ~t~ macros

* Setup
** Tangle Headers

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "init.el" :comments no
;; -*- no-byte-compile: t; -*-
#+END_SRC

** Required Packages

*** Library packages

**** [[https://github.com/neeasade/ct.el#ct-mix-colors-optional-space][neeasade/ct.el: color tools for emacs]]

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! ct)
#+END_SRC

*** Load Libraries

- [[https://github.com/magnars/dash.el][magnars/dash.el: List Manipulation]]
- [[https://github.com/magnars/s.el][magnars/s.el: String Manipulation]]

#+BEGIN_SRC elisp
(require 'dash)
(require 's)
(require 'f)
(require 'noflet)
(require 'ct)
#+END_SRC

#+BEGIN_SRC elisp :tangle "autoload.el" :comments link
(require 'dash)
(require 's)
(require 'f)
(require 'noflet)
(require 'ct)
#+END_SRC

* My Standard Library
:PROPERTIES:
:header-args: :tangle "autoload.el" :comments link
:END:

Macros & Functions that extend my elisp standard library.
If you copy any of my emacs-lisp code, you will need these functions.

Tangles to [[file:autoload.el][autoload.el]]

** Macros
*** Template Literals
:PROPERTIES:
:SOURCE:   https://gist.github.com/cbowdon/012d623920bd28453bf8
:END:

#+BEGIN_SRC elisp :tangle no
(template "2 = <<(+ 1 1)>>")
#+END_SRC

#+RESULTS:
: 2 = 2

#+BEGIN_SRC elisp
;;;###autoload
(defmacro template (text)
  "Template literals"
  (let ((pattern "<<\\(.*?\\)>>"))
    ;; The regexp matches anything between delimiters, non-greedily
    (with-temp-buffer
      (save-excursion (insert text))
      (let ((matches '()))
        (while (re-search-forward pattern nil t)
          (push (match-string 1) matches)
          (replace-match "%s" t t))
        `(format ,(buffer-string) ,@(reverse (mapcar 'read matches)))))))

;;;###autoload
(defalias 't! 'template)
#+END_SRC

*** Ignore Arguments
:PROPERTIES:
:SOURCE:   https://emacs.stackexchange.com/a/33063
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defmacro my@ignore-args (fn)
  "Return function that ignores its arguments and invokes FN."
  `(lambda (&rest _rest)
     (funcall ,fn)))
#+END_SRC
*** Comment

Similar to the clojure ~comment~ form

#+begin_src elisp
(defmacro comment (&rest body)
  "Comment out one or more s-expressions."
  nil)
#+end_src

** General
*** Noop

#+BEGIN_SRC elisp
;;;###autoload
(defun my/noop (&optional args) nil)
#+END_SRC

*** Without undo

#+BEGIN_SRC elisp
;;;###autoload
(defmacro my/without-undo (&rest forms)
  "Executes FORMS with a temporary buffer-undo-list that is discarded afterwards.
Taken from http://www.emacswiki.org/emacs/UndoCommands with some
modifications."
  `(let* ((buffer-undo-list)
          (modified (buffer-modified-p))
          (inhibit-read-only t))
     (unwind-protect
         (progn ,@forms)
       (set-buffer-modified-p modified)) ()))
#+END_SRC

*** INACTIVE String match or original

#+BEGIN_SRC elisp :tangle no
;;;###autoload
(defun my/s-match-or (regex x)
  "Return match groups or original"
  (interactive)
  (-if-let ((match (s-match regex x)))
      (cdr match)
    (list x)))

;;;###autoload
(defun my/s-match-or-1 (regex x)
  "Return 1st match group or original."
  (interactive)
  (-if-let ((match (s-match regex x)))
      (car (cdr match))
    x))
#+END_SRC
** Buffer
*** Check if buffer has line

#+BEGIN_SRC elisp
(defun my-buffer/contains-line (string)
  (save-excursion
    (save-match-data
      (goto-char (point-min))
      (search-forward string nil t))))
#+END_SRC

*** Get current line indentation

#+BEGIN_SRC elisp
;;;###autoload
(defun my-buffer/line-indent ()
  "Get the indent of the current line."
  (interactive)
  (or (-some->> (substring-no-properties (thing-at-point 'line))
        (s-match "^\\(\s*\\).*\n$")
        (nth 1)
        (length))
      0))
#+END_SRC

*** Check current line for regex

#+BEGIN_SRC elisp
;;;###autoload
(defun my-buffer/line-contains (regexp)
  "Check for REGEXP at current line."
  (save-excursion
    (goto-char (point-at-bol))
    (search-forward-regexp regexp (point-at-eol) t)))
#+END_SRC

*** Delete current line

#+BEGIN_SRC elisp
;;;###autoload
(defun my-buffer/delete-current-line ()
  "Delete (not kill) the current line."
  (interactive)
  (save-excursion
    (delete-region
     (progn (forward-visible-line 0) (point))
     (progn (forward-visible-line 1) (point)))))
#+END_SRC

*** Insert above/below current line

#+begin_src elisp
(defun my-buffer|insert-line-below (&optional str)
  "Insert an empty line below the current line."
  (interactive)
  (save-excursion
    (end-of-line)
    (insert "\n" (or str ""))))

(defun my-buffer|insert-line-above (&optional str)
  "Insert an empty line above the current line."
  (interactive)
  (save-excursion
    (end-of-line 0)
    (insert "\n" (or str ""))))
#+end_src

*** INACTIVE Map buffer lines

#+BEGIN_SRC elisp :tangle no
;;;###autoload
(defun my-buffer/map-lines (fun &optional start end)
  "Map lines in buffer with FUN, fn gets called with the line contents."
  (let ((start (or start (point-min)))
        (end (or end (point-max)))
        (lines (list)))
    (save-excursion
      (goto-char start)
      (while (< (point) end)
        (add-to-list 'lines
          (funcall fun (buffer-substring (line-beginning-position) (line-end-position))))
        (forward-line 1))
      (erase-buffer)
      (->> lines
           reverse
           (s-join "\n")
           insert))))
#+END_SRC
*** Jump to source

#+begin_src elisp
(defun my-buffer|jump-source-dwim (&optional other-window file-name)
  "Jump to the buffer source depending on the mode."
  (interactive)
  (cond
   ((bound-and-true-p org-src-mode) (org-goto-marker-or-bmk org-src--beg-marker))
   (t (dired-jump other-window file-name))))
#+end_src
*** Search regexp in buffer

#+begin_src elisp
(defun my-buffer/search-regexp-in-buffer (regexp)
  "Searches for REGEXP in the current buffer and returns a list of matches and their line numbers."
  (save-excursion
    (let ((matches '()))
      (goto-char (point-min))
      (while (re-search-forward regexp nil t)
        (push (cons (match-string 0) (line-number-at-pos)) matches))
      (reverse matches))))
#+end_src

** Shell Commands & Aliases
*** Async Command No Window
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/a/47910509/2298462][How to avoid pop-up of *Async Shell Command* buffer in Emacs?]]
:END:

Prevent ~async-shell-command~ displaying a popup or a buffer.

#+BEGIN_SRC elisp
(defun my-shell/async-command-no-window (command)
  "Execute async command without showing the result buffer."
  (interactive)
  (let ((display-buffer-alist (list (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))))
    (async-shell-command command)))
#+END_SRC

*** Shell command to list

#+BEGIN_SRC elisp
(defun my-shell/command-to-list (cmd)
  "Split output from shell-command to list"
  (split-string (shell-command-to-string cmd) "\n" t))
#+END_SRC

*** Start process that stays alive

I don't want some processes to exit, when I close emacs.

#+BEGIN_SRC elisp
;;;###autoload
(defun my-shell/no-exit-command (cmd &optional &rest args)
  "Launch a shell command, without opening a message buffer.
The proram persists when emacs is closed."
  (let ((args-str (or (-some->> args
                        (s-join " "))
                      "")))
    (call-process-shell-command
       (template "nohup 1>/dev/null 2>/dev/null <<cmd>> <<args-str>> &") nil nil)))
#+END_SRC

*** Open youtube link with MPV

#+BEGIN_SRC elisp
;;;###autoload
(defun my-shell/mpv-youtube-url (url)
  (-when-let* ((quality-val
                (-some->> (completing-read
                            "Max height resolution (0 for unlimited): "
                            '("720" "0" "480" "1080"))
                  (string-to-number)))
               (quality-arg (if (> 0 quality-val)
                                (template "--ytdl-format=\"[height<=?<<quality-val>>]\"")
                              "")))
    (message (template "Opening <<url>> at <<quality-val>> with mpv…"))
    (my-shell/no-exit-command "mpv" quality-arg (s-wrap url "\""))))
#+END_SRC
*** Shell Command to String

#+begin_src elisp
(defun my/shell-command (cmd &rest flags)
  "Execute a shell command and return a cons of the exit-status and the output.
Trims the resulting output automatically."
  (-let (((exit-status . (output))
          (with-temp-buffer
            (list (apply #'call-process (-concat (list cmd nil (current-buffer) nil) (-non-nil flags)))
                  (buffer-string)))))
    (cons exit-status (s-trim output))))

(defun my/shell-command-str (cmd &rest flags)
  "Return the result to a shell command when its exitcode is not stderr."
  (-let (((exit-status . output) (apply #'my/shell-command (-concat (list cmd) (-non-nil flags)))))
    (pcase exit-status
      (0 output))))

(comment
 (equal (my/shell-command "pwd") '(0 . "/home/floscr/.config/doom"))
 (equal (my/shell-command "pwd" nil nil) '(0 . "/home/floscr/.config/doom"))
 (equal (my/shell-command-str "get_url_title" "\"http://stat.us/404\"") nil)
 (equal (my/shell-command-str "get_url_title" "https://orf.at" nil nil) "news.ORF.at"))
#+end_src

** Files
*** Get file timestamp

#+BEGIN_SRC elisp
;;;###autoload
(defun my-file/timestamp (path)
  (->> (file-attributes path)
       (nth 5)))
#+END_SRC

*** Get the last modified file in directory
:PROPERTIES:
:SOURCE:   https://stackoverflow.com/a/30886283
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defun my-file/last-modified-file-in-dir (path)
  (->> (f-entries path)
       (-sort (lambda (a b) (not (time-less-p (my-file/timestamp a)
                                              (my-file/timestamp b)))))
       (car)))
#+END_SRC

*** Chmod current file

#+BEGIN_SRC elisp
;;;###autoload
(defun my-file|chmod-this-file ()
  "Chmod +x the current file."
  (interactive)
  (shell-command (template "chmod +x \"<<(buffer-file-name)>>\"")))
#+END_SRC
*** Dir has hidden entry

#+BEGIN_SRC elisp
(defun my-file/dir-has-hidden-entries (dir)
  "Check if a DIR has any hidden entries.
Return the first found file when one is found."
  (--find (s-starts-with-p "." (f-filename it)) (f-entries dir)))
#+END_SRC

*** Find project root

#+BEGIN_SRC elisp
(defun my-file/project-root (&optional dir)
  "Find the project root either via projectile (not available in certain buffers like dired)
or manually traverse upwards until the .git directory is found."
  (let ((default-directory (or dir default-directory)))
    (or
     projectile-project-root
     (f--traverse-upwards (f-exists? (f-expand ".git" it))))))

(cl-defun my-file/git-root (&optional (skip-worktree? t))
  (let ((checker-fn (if skip-worktree? #'f-dir? #'f-exists?)))
    (f--traverse-upwards (funcall checker-fn (f-expand ".git" it)))))
#+END_SRC
*** Find node_modules executable

#+begin_src elisp
(defun my-file/node-modules-executable-find (name)
  "Find an executable bin in the projects node_modules/.bin directory with NAME
Returns nil when no executable was found."
  (-some->> (projectile-project-root)
    (-f-join (f-join "node_modules/.bin" name))
    (-id-when #'f-exists?)))
#+end_src

** Debugging / Logging
*** Kill and Message

#+BEGIN_SRC elisp
;;;###autoload
(defun my/kill-and-message (x)
  "Executes kill-new but with a message log side effect."
  (kill-new x)
  (message "Copied to clipboard: %s" x))
#+END_SRC

*** Convert boolean to enabled/disabled string

#+BEGIN_SRC elisp
(defun my/bool-to-enabled-string (x)
  "Convert bool X to string for messaging.
t   -> \"Enabled\")
nil -> \"Disabled\""
  (if x "Enabled" "Disabled"))
#+END_SRC

*** Variable t/nil toggle message

#+BEGIN_SRC elisp
(defun my/bool-state-message (x)
  "Log message if a bool is enabled or not"
  (interactive)
  (message (t! "<<(symbol-name x)>>: <<(my/bool-to-enabled-string (symbol-value x))>>")))
#+END_SRC
*** Print

#+begin_src elisp
(defun prn (&rest args)
  (let* ((str (->> (-map (lambda (_) "%s") args)
                   (s-join " ")))
         (msg-args (-concat (list str) args)))
    (apply #'message msg-args)))
#+end_src

** Dash Extensions
*** Fix custom thread indentation

#+begin_src elisp
(with-eval-after-load 'dash
  (--each
   (list '-> '->> '-some-> '-some->> '--each '-each '-map '--map)
   (function-put it 'lisp-indent-function nil)))
#+end_src

*** -tap

Run a side effect ~fn~ on the initial input ~x~.
But Return the original input ~x~.

#+BEGIN_SRC elisp
;;;###autoload
(defun -tap (fn x)
  "Function docstring"
  (funcall fn x)
  x)

;;;###autoload
(defmacro --tap (fn it)
  "Anaphoric form of `-tap'."
  `(-tap (lambda (it) ,fn) ,it))
#+END_SRC

*** -log

Log the current input without breaking the pipe.

#+BEGIN_SRC elisp
;;;###autoload
(defun -log (x)
  "Function docstring"
  (--tap (message "%s" it) x))
#+END_SRC

*** -when

#+BEGIN_SRC elisp
;;;###autoload
(defun -when (pred fn x)
  "When FN equals t forward X."
  (if pred
      (funcall fn x)
    x))

;;;###autoload
(defmacro --when (pred form xs)
  "Anaphoric form of -id-when"
  (declare (debug (form form)))
  `(let ((it ,xs))
     (if ,pred
         ,form
       ,xs)))
#+END_SRC

*** -id-when

#+BEGIN_SRC elisp
;;;###autoload
(defun -id-when (fn x)
  "When FN equals t forward X."
  (when (funcall fn x) x))

;;;###autoload
(defmacro --id-when (form xs)
  "Anaphoric form of -id-when"
  (declare (debug (form form)))
  `(let ((it ,xs))
     (when ,form ,xs)))
#+END_SRC

*** -append

#+BEGIN_SRC elisp
;;;###autoload
(defun -append (elem list)
  "Append ELEM to the end of list.

This is like -snoc but it takes the ELEM as the first argument for easier composition"
  (-snoc list elem))
#+END_SRC

*** -shuffle
:PROPERTIES:
:SOURCE:   [[http://kitchingroup.cheme.cmu.edu/blog/2014/09/06/Randomize-a-list-in-Emacs/][Randomize a list in Emacs]]
:END:

#+BEGIN_SRC elisp
(defun swap-list-items (LIST el1 el2)
  "in LIST swap indices EL1 and EL2 in place"
  (let ((tmp (elt LIST el1)))
    (setf (elt LIST el1) (elt LIST el2))
    (setf (elt LIST el2) tmp)))

;;;###autoload
(defun -shuffle (LIST)
  "Shuffle the elements in LIST.
shuffling is done in place."
  (loop for i in (reverse (number-sequence 1 (1- (length LIST))))
        do (let ((j (random (+ i 1))))
             (swap-list-items LIST i j)))
  LIST)
#+END_SRC

*** -f-join

#+BEGIN_SRC elisp
;;;###autoload
(defun -f-join (x path)
  "Reversed argument order for f-join"
  (f-join path x))
#+END_SRC

*** -f-tildify

#+BEGIN_SRC elisp
;;;###autoload
(defun f-tildify (path)
  "Replace the HOME directory in path"
  (s-replace-regexp (t! "^<<(getenv \"HOME\")>>") "~" path))
#+END_SRC
*** -mapcar-first

Map over the first item of a list of ~cons~

#+begin_src elisp
(defun -mapcar-first (func lst)
  "Apply FUNC to the first item of each cons cell in LST."
  (mapcar (lambda (item)
            (if (consp item)
                (cons (funcall func (car item)) (cdr item))
              item))
          lst))
#+end_src

#+begin_src elisp :tangle no
(mapcar-first #'1+ '((1 . a) (2 . b) (3 . c))))
#+end_src

#+RESULTS:
: ((2 . a) (3 . b) (4 . c))

*** plist

#+begin_src elisp
(defun -plist-get (plist prop)
  (plist-get prop plist))
#+end_src

** Tangling

#+begin_src elisp
(defvar my-config:literate-config-file
  (concat doom-private-dir "config.org")
  "The file path of your literate config file.")

(defvar my-config:literate-config-file-cache
  (concat doom-cache-dir "literate-last-compile")
  "The file path that `my-config:literate-config-file' will be tangled to, then
byte-compiled from.")

;;;###autoload
(defun my-config/tangle-literate-config (&optional force-p file)
  "Tangles the current buffer FILE if it has changed."
  (let* ((default-directory doom-private-dir)
         (src-file (expand-file-name (or file buffer-file-name)))
         (dst-file (concat (file-name-sans-extension src-file) ".el")))
    (when (or (file-newer-than-file-p src-file
                                      dst-file)
              force-p)
      (message "Compiling your literate config...")
      (start-process
       "org-tangle" nil "emacs"
       "-q" "--batch"
       "-l" "ob-tangle"
       "--eval" (format "(org-babel-tangle-file %S %S)"
                        src-file dst-file)))))

;;;###autoload
(defalias 'my-config/reload-litarate-config-file #'doom/reload)

;;;###autoload
(defun my-config/recompile-literate-config-maybe ()
  "Recompile config.org if we're editing an org file in our DOOMDIR.

We assume any org file in `doom-private-dir' is connected to your literate
config, and should trigger a recompile if changed."
  (when (and (eq major-mode 'org-mode)
             (file-in-directory-p buffer-file-name doom-private-dir))
    (my-config/tangle-literate-config 'force)))

;; Recompile our literate config if we modify it
;;;###autoload
(after! org (add-hook 'after-save-hook #'my-config/recompile-literate-config-maybe))

;;;###autoload
(defun my-config|tangle ()
  "Tangle the current org buffer."
  (interactive)
  (my-config/tangle-literate-config t))
#+end_src
** Dates

*** Insert current date

#+begin_src elisp
(defun my-date|insert-today (&optional arg)
  "Insert the current date as YYYY-MM-DD.
When ARG is passed, query for a custom delimiter."
  (interactive "P")
  (let ((delimiter (if arg
                       (read-string "Date delimiter: " "-")
                     "-")))
    (my-evil/insert-dwim (format-time-string (concat "%Y" delimiter "%m" delimiter "%d")))))
#+end_src
* My Packages
** Bbuild

#+begin_src elisp
(defun bbuild|execute (fn cmd args)
  (let* ((default-directory* default-directory)
         (default-directory "/home/floscr/.config/dotfiles/new/modules/scripts")
         (cmd (->> (concat "bb ./src/bbuild.clj"
                           " " cmd " "
                           (-some->> args (-flatten) (s-join " ") (s-prepend " "))
                           (format " --dir \"%s\"" default-directory*))
                   (-log))))
    (apply fn (list cmd))))

(defun bbuild|list (&rest args)
  (interactive)
  (ivy-read "Bbuild: " (->> (bbuild|execute #'shell-command-to-string "list" args)
                            ((lambda (x) (split-string x "\n"))))
            :action '(1
                      ("RET"
                       (lambda (&rest args)
                         (bbuild|execute #'compile "execute" args))
                       "Run")
                      ("t"
                       (lambda (&rest args)
                         (bbuild|execute #'call-process-shell-command "execute" (-snoc args "--term")))
                       "In Terminal")
                      ("r" (lambda (x)
                             (-let (((cmd id) x))
                               (bbuild|execute "remove" id)))
                       "Remove"))
            :caller 'bbuild|list))
#+end_src

** BBookmarks

Emacs implmenentation for my bookmarks management written in clojure:

https://github.com/floscr/dotfiles/blob/6102660b90048f6be9fbaeb9e710c7de80a85f4c/new/modules/scripts/src/bbookmarks.clj

*** Docs

**** Emacs Commands

|------------------------------+----------------------------------------|
| Command key                  | Description                            |
|------------------------------+----------------------------------------|
| ~:org-goto "Heading Regexp"~ | Go to an org heading within the file   |
| ~:org-narrow-indirect~       | Narrow resulting org buffer indirectly |
|------------------------------+----------------------------------------|

*** Packages
**** [[https://github.com/clojure-emacs/parseedn][clojure-emacs/parseedn: EDN parser for Emacs Lisp]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! parseedn)
#+END_SRC

*** Config
**** Disable Emacs bookmarks

#+BEGIN_SRC elisp
(setq bookmark-save-flag nil)

;; Can't set to nil as bookmarks are still set up to hooks
;; Instead I'll keep it in this file which will be trashed on every reboot
(setq bookmark-file "/tmp/emacs-bookmarks-file")
#+END_SRC

*** Functions

#+begin_src elisp
(defun bbookmarks|execute (&rest args)
  (let ((default-directory "/home/floscr/.config/dotfiles/new/modules/scripts"))
    (->> (concat "bb ./src/bbookmarks.clj"
                 (-some->> args (s-join " ") (s-prepend " ")))
         (shell-command-to-string))))

(defun bbookmarks/goto (x)
  (progn
    (goto-char (point-min))
    (cond
     ((eq 'integer (type-of x))
      (goto-line x))
     ((eq 'string (type-of x))
      (search-forward x nil t)
      (goto-char (line-beginning-position))
      (back-to-indentation)))))

(defun bbookmarks/org-goto (x)
  (when (-some-> (org-find-exact-headline-in-buffer m)
                 (goto-char))
    (goto-char (line-beginning-position))))

(defun bbookmarks/execute-command (cmd)
  (pcase cmd
    (`[:open-file ,f] (progn
                        (when (get-file-buffer f) (setq buffer-open? t))
                        (find-file (f-expand f))
                        (+workspaces-add-current-buffer-h)))

    (`[:goto ,m] (bbookmarks/goto m))

    (`[:goto-bol _ :no-relocate] (unless buffer-open? (bbookmarks/goto m)))
    (`[:goto-bol ,m] (bbookmarks/goto m))

    (`[:org-goto ,m :no-relocate] (unless buffer-open? (bbookmarks/org-goto m)))
    (`[:org-goto ,m] (bbookmarks/org-goto m))
    (`[:org-narrow-indirect] (my-org-indirect|narrow-subtree-indirect :popup? nil))

    (`[:emacs ,cmd] (pcase cmd
                      (:org-capture-goto-last-stored (org-capture-goto-last-stored))
                      (_ (user-error (format "No implementation for emacs-command: %s" cmd)))))

    (_ (user-error (format "No implementation for: %s" cmd)))))

(defun bbookmarks/execute (x)
  (require 'parseedn)
  (-let* (((_ _ commands) x)
          (commands (parseedn-read-str commands))
          (buffer-open? nil))
    (-each commands #'bbookmarks/execute-command)))

(defun bbookmarks/remove (x)
  (require 'parseedn)
  (-let* (((_ id _) x))
    (bbookmarks|execute "remove" id)))

(defun bbookmarks|list (&rest args)
  (interactive)
  (ivy-read "Bbookmarks: " (->> (apply #'bbookmarks|execute (-concat '("list" "--with-action") args))
                                ((lambda (x) (split-string x "\n\n")))
                                (--map (split-string it "\n")))
            :action '(1
                      ("RET" bbookmarks/execute "Go to bookmark")
                      ("r" (lambda (x)
                             (-let (((_ id _) x))
                               (bbookmarks|execute "remove" id)
                               (bbookmarks|list)))
                       "Do something"))
            :caller 'bbookmarks|list))

(defun bbookmarks|list-project-bookmarks ()
  (interactive)
  (bbookmarks|list "--parent" (s-replace-regexp "/$" "" (my-file/git-root))
                   "--project-root" (s-replace-regexp "/$" "" (my-file/git-root nil))))

(defvar bbookmarks-save-mode-map (make-sparse-keymap))

(define-minor-mode bbookmarks-save-mode
  "Editing indented source code without the indent in an indirect buffer."
  :keymap bbookmarks-save-mode-map)

(defun bbookmarks|save-buffer ()
  (interactive)
  (let ((contents (buffer-substring-no-properties (point-min) (point-max))))
    (bbookmarks|execute "add" (shell-quote-argument contents))
    (kill-buffer (current-buffer))))

(map! :map bbookmarks-save-mode-map
      :gni "C-c C-c" #'bbookmarks|save-buffer
      :gni "C-c C-k" (cmd! (kill-buffer (current-buffer))))

(add-hook! bbookmarks-save-mode
  (defun bbookmarks-save-mode/init-hook ()
    (setq header-line-format
          "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")))

(defun bbookmarks|save ()
  (interactive)
  (let ((file-name (buffer-file-name))
        (buffer (get-buffer-create "*bbookmark-save*")))
    (if file-name
        (with-current-buffer (get-buffer-create "*bbookmark-save*")
          (insert (format "{:file \"%s\"
 :name \"\"}" file-name))
          (pop-to-buffer buffer)
          (backward-char 2)
          (clojure-mode)
          (bbookmarks-save-mode)
          (evil-insert-state t))
      (user-error "Buffer has no file name!"))))
#+end_src

*** Bindings

#+begin_src elisp
(map!
 :leader
 "RET"  #'bbookmarks|list)

(map!
 :leader
 (:prefix-map ("j" . "jumpy")
  :desc "Project"  "p" #'bbookmarks|list-project-bookmarks))
#+end_src

** TODO Indirect Indent Mode

Adds minor mode for editing indented source code in an indirect buffer,
with the indentation reset to 0.
Saving and committing keeps the indentation in the source buffer.

#+BEGIN_SRC elisp
(defvar-local +indirect-indent 0)

(defvar +indirect-indent-mode-map (make-sparse-keymap))

(define-minor-mode +indirect-indent-mode
  "Editing indented source code without the indent in an indirect buffer."
  :keymap +indirect-indent-mode-map)

(map! :map +indirect-indent-mode-map
      :gni "s-s" #'edit-indirect-save)

(add-hook! +indirect-indent-mode
           (defun +indirect-indent/init-hook ()
             (setq header-line-format
                   "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")))

(advice-add #'edit-indirect-commit :before #'+indirect-indent/restore-indentation)
(advice-add #'edit-indirect-save :after #'+indirect-indent/remove-indentation)
(advice-add #'edit-indirect-save :before #'+indirect-indent/restore-indentation)

(defun +indirect-indent/restore-indentation ()
  (when (and (bound-and-true-p +indirect-indent-mode)
             (not (eq +indirect-indent 0)))
    (my/without-undo
      (indent-rigidly (point-min) (point-max) (+ +indirect-indent)))))

(defun +indirect-indent/remove-indentation ()
  (when (and (bound-and-true-p +indirect-indent-mode)
             (not (eq +indirect-indent 0)))
    (my/without-undo
      (indent-rigidly (point-min) (point-max) (- +indirect-indent)))))

(defun +indirect-indent|edit (beg end &optional with-mode)
  "Edit script in an indirect buffer."
  (interactive)
  (edit-indirect-region beg end t)
  (let ((indent (indent-rigidly--current-indentation (point-min) (point-max))))
    (unless (eq indent 0)
      (my/without-undo
       (indent-rigidly (point-min) (point-max) (- indent)))
      ;; Local variables get undone when calling a mode
      ;; So we have to define the major mode before
      (funcall with-mode)
      (+indirect-indent-mode 1)
      (setq +indirect-indent indent))))
#+END_SRC

** TODO Evil edit register

Edit registers with ~+evil-edit-register|counsel~.
Mostly used to edit the macro registers ~q~.

#+BEGIN_SRC elisp
(defvar +evil-edit-register:register "")
(defvar +evil-edit-register-mode-map (make-sparse-keymap))

(define-minor-mode +evil-edit-register-mode
  "Edit evil register and save it back to the register."
  :keymap +evil-edit-register-mode-map)

(map! :map +evil-edit-register-mode-map
      "C-c C-c" #'+evil-edit-register|save-and-exit
      "C-c C-k" #'kill-buffer-and-window)

(defun +evil-edit-register|save-and-exit (&optional arg)
  "Save the buffer content back to the register register"
  (interactive)
  (evil-set-register
   (string-to-char +evil-edit-register:register)
   (buffer-substring-no-properties (point-min) (point-max)))
  (kill-buffer-and-window))

(defun +evil-edit-register|counsel (register-string)
  "Edit evil register in register"
  (require 'noflet)
  (interactive (noflet ((counsel-evil-registers-action (x) x))
                 (list (counsel-evil-registers))))
  (-when-let* ((register-string (substring-no-properties register-string))
               (buffer (generate-new-buffer (t! "*Evil Register Edit: <<register-string>>*")))
               ((_ reg register) (s-match "^\\[\\(.\\)\\]: \\(.*\\)$" register-string)))
    (pop-to-buffer buffer)
    (with-current-buffer buffer
      (+evil-edit-register-mode 1)
      (setq-local +evil-edit-register:register reg)
      (setq header-line-format "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")
      (save-excursion
        (insert register)))))
#+END_SRC
** TODO Scan Management

#+begin_src elisp
(defun my-scan|dired-file-document ()
  (interactive)
  (let* ((files (->> (dired-get-marked-files)
                     (-sort #'string<)
                     (-map #'shell-quote-argument)
                     (s-join " ")))
         (bin (f-expand "~/Code/Projects/org_print_scan/result/bin/org_print_scan"))
         (headline (read-string "Headline: "))
         (command (t! "<<bin>> copy <<files>> --headline \"<<headline>>\"")))
    (-log command)
    (shell-command-to-string command)
    (find-file "~/Media/Scans/Scans.org")
    (goto-char (max-char))
    (+org|counsel-org-tag)))
#+end_src

** Window Management
*** Window Listing

#+BEGIN_SRC elisp
(defvar my-wm:window-list-re nil "Regex to parse wmctrl list output.
Example output:
0x014000fb  0 brave-browser.Brave-browser  thinknixx1 The Borrowed by Chan Ho-Kei :: www.goodreads.com/ - Brave")

(setq my-wm:window-list-re
      (rx (seq
           bol
           ;; window id (0x014000fb)
           (submatch "0x" (+ (any digit "a-f"))) "  "
           ;; index
           (submatch (+ (any digit))) " "
           ;; title (brave-browser.Brave-browser)
           (submatch (+ nonl)) "." (submatch (+ anychar))
           ;; right aligned column for username
           " " (+ " ")
           ;; username (thinknixx1)
           (submatch (literal (system-name))) " "
           ;; Window title
           (submatch (* nonl)) eol)))

(defun my-wm/match-wm-string (x)
  (-let* ((xs (-drop 1 (s-match my-wm:window-list-re x)))
          (pid (downcase (nth 0 xs)))
          (monitor (nth 1 xs))
          (process (nth 2 xs))
          (process-title (nth 3 xs))
          (user (nth 4 xs))
          (title (nth 5 xs)))
    (list
     :pid pid
     :monitor monitor
     :process process
     :process-title process-title
     :user user
     :title title)))

(defun my-wm/list-windows ()
  "List X windows"
  (->> (shell-command-to-string "wmctrl -lx")
       (s-split "\n")
       (-drop-last 1)
       (-map #'my-wm/match-wm-string)))

(defun my-wm/-process-eq? (id x)
  (string= id (plist-get x ':process)))

(defun my-wm/-pid-eq? (id x)
  (string= id (plist-get x ':pid)))
#+END_SRC

*** Browser Window Listing

#+BEGIN_SRC elisp
(defvar my-wm:browser-title-delimiter-char " ​::​ "
  "The delimiter inserted by the tab title formating extension to seperate the url from the title.
To make sure it is our own delimiter the characters are prefixed and suffixed with zero-width space characters.")

(setq my-wm:browser-url-suffixes '(" - Chromium"
                                    " - Brave"))
(defun my-wm/browser-chop-suffix (url)
  (s-chop-suffixes my-wm:browser-url-suffixes url))

(defun my-wm/is-browser? (x)
  (and (or
        (my-wm/-process-eq? "chromium-browser" x)
        (my-wm/-process-eq? "brave-browser" x))
       (not (s-starts-with? "DevTools - " (plist-get x ':title)))))

(defun my-wm/list-browser-windows ()
  (->> (my-wm/list-windows)
       (-filter #'my-wm/is-browser?)))

(defun my-wm/prev-browser-window ()
  "Try either current or previous window to get the chrome id
Everything further down the line would have to be parsed from bspc history,
and most of the time it's not worth it.
If the current or previous windows are not chrome, just get the first one from the list."
  (--> (my-wm/list-browser-windows)
       (car it)))

(defun my-wm/browser-split-url (x)
  (pcase (s-split my-wm:browser-title-delimiter-char x)
     (`(,title ,url) (list title (my-wm/browser-chop-suffix url)))
     (`(,title) (list title ""))))

(defun my-wm/last-browser-window ()
  (-when-let*
      ((window (my-wm/prev-browser-window))
       ((title url) (-some->> (plist-get window ':title)
                      my-wm/browser-split-url)))
    (list
     title
     (if (s-blank? url) nil url))))

(defun my-wm/last-browser-url ()
  (-let* (((title url) (my-wm/last-browser-window)))
    url))

(defun my-wm/last-browser-url-org-link ()
  (let ((data (my-wm/last-browser-window)))
    (-if-let* (((description link) data))
        (org-make-link-string link description)
      (user-error "Error: Could not get browser url %s" data))))

(defun my-wm/last-browser-url-org-link-formatted ()
  (-if-let* (((title url) (my-wm/last-browser-window))
             (title-formatted
                (cond
                 ;; Custom Pull request Formatting
                  ((s-matches? "^https://github.com.*/pull/[0-9]+.*$" url)
                   (let* ((match (s-match "\\(.+\\) by \\(.+\\) · Pull Request \\(#[0-9]+\\).*$" title))
                          (pr-title (nth 1 match))
                          (pr-user (nth 2 match))
                          (pr-id (nth 3 match)))
                     (template "PR <<pr-id>>: <<pr-title>> by @<<pr-user>>")))
                  (t title))))
      (template "[[<<url>>][<<title-formatted>>]]")
    (user-error "Error: Could not get browser url %s" data)))
#+END_SRC
** Shopping list management

#+begin_src elisp :tangle no
(defun my-org-db/get-db ()
  ""
  (let* (($headlines (->> (org-ml-parse-headlines 'all)))
         (keywords (->> $headlines
                        (--reject (or (eq (org-ml-get-property :level it) 1)
                                      (org-ml-get-children it)
                                      (string= (org-ml-get-property :raw-value (org-ml--get-parent it)) "Incoming")))
                        (--map (org-ml-get-property :raw-value it)))))
    keywords))

(save-window-excursion
  (with-current-buffer (find-file (+org/expand-org-file-name "Db/Shopping.org"))
    (-log (my-org-db/get-db))))
#+end_src

** Compile project

My custom solution for caching compile commands between sessions.
I store the cached commands per directory in [[file:~/.emacs.d/.local/project-compile-cache-file.json][this json file]].

#+begin_src elisp
(defvar my-project-compile:cache-file nil)
(setq my-project-compile:cache-file (f-join doom-local-dir "project-compile-cache-file.json"))

(defun my-project-compile/update-ht-vector (k v m)
  "Merge the vector on key K in the hashtable M with V.
Removes the key before so the new value will be appended.
This function will mutate the hashtable M."
  (let ((xs (->> (seq-into (or (ht-get m k) []) 'list)
                 (-remove (lambda (x) (string= v x)))
                 (-append v))))
    (ht-set m k (seq-into xs 'vector)))
  m)

(defun my-project-compile/read-cache-file (&optional cache-file)
  (-some->> (or cache-file my-project-compile:cache-file)
    (-id-when #'f-exists?)
    (json-read-file)))

(defun my-project-compile/get-cache-items (key &optional cache-file)
  (or (-some->> (my-project-compile/read-cache-file (or cache-file my-project-compile:cache-file))
        (ht-from-alist)
        ((lambda (m) (ht-get m key))))
      []))

(defun my-project-compile/update-cache (cmd dir &optional cache-file)
  (let ((cache (->> (my-project-compile/read-cache-file)
                    (ht-from-alist)
                    (my-project-compile/update-ht-vector (intern dir) cmd)
                    (json-encode))))
    (f-write cache 'utf-8 (or cache-file my-project-compile:cache-file))))

(defun my-project-compile/compile-cmd (cmd dir &optional cache-file)
  (call-process-shell-command (format "alacritty --hold -e $SHELL -c '%s'&" cmd) nil 0 nil)
  (my-project-compile/update-cache cmd dir cache-file))

(defun my-project-compile|compile ()
  (interactive)
  (let* ((dir (->> (my-file/project-root)
                   (f-full)))
         (items (->> (my-project-compile/get-cache-items (intern dir))
                     (reverse))))
    (ivy-read "Compile: " (seq-into items 'list)
              :action (lambda (cmd) (my-project-compile/compile-cmd cmd dir)))))
#+end_src

** Comment header

#+begin_src elisp
; Variables --------------------------------------------------------------------

(defvar my-comment-header:col-count 80
  "Of how many cols should the header consist.")

(defvar my-comment-header:col-char "-"
  "With which character to fill the comment header.")

(defvar my-comment-header:mode-comment-start
  '((clojurescript-mode . ";;")
    (clojure-mode . ";;")))

(put 'my-comment-header:col-count 'safe-local-variable 'integerp)
(put 'my-comment-header:mode-comment-start 'safe-local-variable t)

; Helpers ----------------------------------------------------------------------

(defun my-comment-header/comment-start ()
  "Return the `comment-start' either defined by `my-comment-header/comment-start' or by the `major-mode'."
  (or (alist-get major-mode my-comment-header:mode-comment-start)
      comment-start))

(defun my-comment-header/read-string ()
  "Helper function to read the comment header string."
  (read-string (format "Comment header (%s): "
                       (my-comment-header/comment-start))))

(defun my-comment-header/fill (str)
  "Fill the string with the comment header character."
  (let ((n (- my-comment-header:col-count (length str))))
    (concat str (s-repeat n my-comment-header:col-char))))

(defun my-comment/match-header (&optional bound)
  (re-search-forward (concat "^"
                             (my-comment-header/comment-start)
                             " .+"
                             my-comment-header:col-char "+$")
                     bound t))

(defun my-comment-header|goto-next-comment-header ()
  "Jumps to the next comment header."
  (my-comment/match-header))

(defun my-comment/comment-header-line? ()
  "Is the current line a comment header."
  (save-excursion
    (beginning-of-line)
    (my-comment/match-header (line-end-position))))

(defun my-text/line-empty? ()
  (not (looking-back "^$")))

(defun my-text/ensure-surrounding-newlines ()
  (save-excursion
    (beginning-of-line)
    (previous-line)
    (when (my-text/line-empty?)
      (evil-insert-newline-below)))
  (save-excursion
    (beginning-of-line)
    (next-line)
    (when (my-text/line-empty?)
      (evil-insert-newline-above))))

; Main -------------------------------------------------------------------------

(defun my-comment-header|toggle-fold ()
  (interactive)
  (when (my-comment/comment-header-line?)
    (vimish-fold-delete)
    (let* ((beg (line-beginning-position))
           (end (or (save-excursion
                      (when (my-comment-header|goto-next-comment-header)
                        (progn (previous-line 2)
                               (point))))
                    (point-max))))
      (vimish-fold beg end))))

(defun my-comment-header|fold-all ()
  "Folds everything into comment headers."
  (interactive)
  (vimish-fold-delete-all)
  (save-excursion
    (goto-char (point-min))
    (while (my-comment-header|goto-next-comment-header)
      (my-comment-header|toggle-fold)
      (evil-next-line 1))))

(defun my-comment-header|insert (title)
  "Insert a comment header on the current line."
  (interactive (list (my-comment-header/read-string)))
  (when (my-comment/comment-header-line?)
    (delete-line))
  (let* ((str-beg (concat (my-comment-header/comment-start) " "))
         (str (->> (concat str-beg title " ")
                   (my-comment-header/fill))))
    (insert str)
    (goto-char (line-beginning-position))
    (forward-char (length (concat str-beg title)))
    (my-text/ensure-surrounding-newlines)
    (evil-insert-state)
    (overwrite-mode 1)))

(after! vimish-fold
  (setq my-comment-header:col-count vimish-fold-header-width))
#+end_src

** Eval Function and last marker

#+begin_src elisp
(defun my-eval-function-and-last-marker ()
  "Mark an expression with 'f' and keep working on a function."
  (interactive)
  (cider-eval-defun-at-point)
  (save-excursion
    (evil-goto-mark ?f)
    (cider-eval-last-sexp)))
#+end_src

** Project Hydras

#+begin_src elisp
(defun my-project-hydra|main ()
  (interactive)
  (pcase (projectile-project-name)
    ("org-web" (my-project-hydra|org-web/body))
    (_ (user-error "No project hydra found."))))
#+end_src

*** Hydras

**** org-web

#+begin_src elisp
(defhydra my-project-hydra|org-web (:exit t)
  "org-web Hydra"
  ("r" (lambda () (interactive) (cider-interactive-eval "(biff/fix-print (biff/refresh))")))
  ("tp" (lambda () (interactive) (projectile-run-async-shell-command-in-root "bb org:test")) "Run parser tests")

  ;; File
  ("ff" (lambda () (interactive) (find-file (f-join (projectile-project-root) "projects/backend/resources/fixtures.secret.edn"))) "File: Secret Fixtures")
  ("fr" (lambda () (interactive) (find-file (f-join (projectile-project-root) "projects/backend/src/com/org_web/repl.clj"))) "File: Repl")
  ("fs" (lambda () (interactive) (find-file (f-join (projectile-project-root) "projects/backend/storage/"))) "File: Storage")

  ("xx" (lambda () (interactive) (f-delete (f-join (projectile-project-root) "projects/backend/storage/xtdb") t)) "File: Storage"))
#+end_src
** Scratch Popup

#+begin_src elisp
(defun +my|scratch-popup ()
  "Open capture, adjust display, disable posframe."
  (interactive)
  (let* ((name "emacs-float-scratch")
         (display ":0")
         (height (* (/ (display-pixel-height display) 4) 2))
         (width (* (/ (display-pixel-width display) 4) 2))
         (frame (make-frame `((name . ,name)
                              (transient . t)
                              (height . (text-pixels . ,height))
                              (width . (text-pixels . ,width))))))
    (select-frame frame)
    ;; HACK: workaround for emacs setting the title correctly and xmonad recognizing it as a window rule
    ;; Generally emacs sets the name way to late for any tiling window manager to recognize it
    (set-frame-name (concat name "1"))
    (set-frame-name name)
    ;; HACK: Emacs sets frame dimensions in number of charters / lines
    ;; This can be worked around with text-pixels, but that would round the next character cell
    ;; So we force the window to the dimensions the tiling wm would have given it
    (set-frame-size (selected-frame) width height t))
  (doom/switch-to-scratch-buffer t)
  (org-mode)
  (spell-fu-mode)
  (evil-insert-state))
#+end_src

* Default Configuration
** Temp

Include colons as delimiters for now

#+begin_src elisp
(modify-syntax-entry ?: "w" emacs-lisp-mode-syntax-table)
(after! org-mode
  (modify-syntax-entry ?: "w" org-mode-syntax-table))
(after! grep-mode
  (modify-syntax-entry ?: "w" grep-mode-syntax-table))
#+end_src

** Secrets

Config files that I don't want to share with the world.
They will be stored in here:

#+BEGIN_SRC elisp
(defvar my-secrets:config-file nil
  "My private config file.")
(setq my-secrets:config-file "~/.config/secrets.el")
#+END_SRC

And I will load them on system start:

#+BEGIN_SRC elisp
(defun my-secrets/load-config-file ()
  (-some->> my-secrets:config-file
    (-id-when 'file-exists-p)
    (load-library)))

(my-secrets/load-config-file)
#+END_SRC
** Custom Variables
*** Directories
**** Downloads

#+BEGIN_SRC elisp
(defcustom my-directories:downloads-dir "~/Downloads"
  "Downloads Directory"
  :type 'string)
#+END_SRC

**** Repositories

#+BEGIN_SRC elisp
(defcustom my-directories:repositories-dir "~/Code/Repositories"
  "Downloads Directory"
  :type 'string)
#+END_SRC

** Emacs
*** User Name

#+begin_src elisp
(setq user-full-name "Florian Schrödl")
#+end_src

*** Move items to trash on delete

#+BEGIN_SRC elisp
(setq
 trash-directory "~/.Trash/"
 delete-by-moving-to-trash t)
#+END_SRC

*** Automatically reload tags files

#+BEGIN_SRC elisp
(setq tags-revert-without-query 1)
#+END_SRC

*** Disable blinking cursor

#+BEGIN_SRC elisp
(blink-cursor-mode -1)
(setq blink-matching-paren nil)
(setq visible-cursor nil)
#+END_SRC
*** Safe local variables

Variables that I want to safely set from ~.dir-locals~ files.

#+BEGIN_SRC elisp
(put '+file-templates-dir 'safe-local-variable #'stringp)
#+END_SRC

*** Buffer naming :INIT:

#+BEGIN_SRC elisp
(defun my-*set-uniquify-buffer-name-style ()
  (setq uniquify-buffer-name-style 'post-forward)
  (setq uniquify-separator "/")
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-ignore-buffers-re "^\\*"))

(add-hook! 'persp-mode-hook #'my-*set-uniquify-buffer-name-style)
#+END_SRC

*** Load ~.authinfo.gpg~ for authentication :AUTH:

#+BEGIN_SRC elisp
(add-to-list 'auth-sources "~/.config/gnupg/.authinfo.gpg")
#+END_SRC

*** Disable ~dcl~ mode for password files :AUTH:FIX:

Since it has the regex matching ~.com~ it's enabled for all my password files,
which I name after the matching url.

#+BEGIN_SRC elisp
(setq auto-mode-alist (rassq-delete-all 'dcl-mode auto-mode-alist))
#+END_SRC

** Doom
*** Init Modules :INIT:

#+BEGIN_SRC emacs-lisp :tangle "init.el" :comments no
(doom!
 :completion
 (company
  +childframe)
 (ivy
  +hydra
  +childframe)

 :ui
 doom
 modeline
 doom-quit
 (popup +all +defaults)
 vc-gutter
 vi-tilde-fringe
 window-select
 workspaces
 zen

 :email
 (mu4e +gmail)

 :editor
 (format +onsave)
 (evil +everywhere)
 file-templates
 fold
 rotate-text
 multiple-cursors
 (parinfer +rust)
 snippets

 :term
 eshell
 term
 ;; vterm

 :emacs
 (dired +icons)
 electric
 vc
 (undo +tree)

 :checkers
 (syntax +childframe)
 grammar
 spell

 :tools
 direnv
 (lookup
  +devdocs
  +docsets
  +dictionary
  +offline)
 eval
 editorconfig
 (magit +forge)
 rgb
 pdf
 pass
 docker
 lsp

 :lang
 beancount
 lua
 (nix +lsp)
 rust
 (ruby +rails)
 rest
 data
 (haskell +lsp)
 emacs-lisp
 markdown
 ocaml
 nim
 (clojure +lsp)
 (javascript +lsp)
 (org
  +dragndrop
  +pretty
  +present)
 sh
 yaml
 (web +css)

 :app
 irc
 calendar
 (rss +org)

 :config
 (default +bindings +snippets +evil-commands)

 :private
 (org
  +org-reading-list
  +org-tags
  +org-pinboard))
#+END_SRC

*** Garbage collection

Set it to =32 MiB=.

#+BEGIN_SRC elisp
(setq doom-gc-cons-threshold 33554432)
#+END_SRC
*** Package overrides

**** Fix poppler issue in ~pdf-tools~

#+begin_src elisp :tangle "packages.el" :comments link
(package! pdf-tools :pin "f9ccdf99e560bae70d3a13325cec9dc0e3cc45b0")
#+end_src

** UI
*** Functions
**** Toggle window split style
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/46664/switch-between-horizontal-and-vertical-splitting][Switch between horizontal and vertical splitting? - Emacs Stack Exchange]]
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defun my-ui|toggle-window-split-direction ()
  "Toggle current window split between horizontal and vertical."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

**** Toggle window dedicated
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/2189/how-can-i-prevent-a-command-from-using-specific-windows][buffers - How can I prevent a command from using specific windows? - Emacs Stack Exchange]]
:END:

Lock a window so the buffer can't be changed or it cant be deleted.

#+BEGIN_SRC elisp
;;;###autoload
(defun my-ui|toggle-window-dedicated ()
  "Control whether or not Emacs is allowed to display another
buffer in current window."
  (interactive)
  (let* ((window (get-buffer-window (current-buffer)))
         (is-locked (window-dedicated-p window))
         (txt (if is-locked "Window unlocked" "Window locked")))
    (set-window-dedicated-p window (not is-locked))
    (message (template "<<(current-buffer)>>: <<txt>>!"))))
#+END_SRC
**** Adjust font to display

#+BEGIN_SRC elisp
;;;###autoload
(defun my-ui/adjust-font (size line-space &optional font-family weight)
  (let* ((font-family (or font-family)))
    (setq-default line-spacing line-space)
    (setq-default doom-font (font-spec :family font-family :size size :weight weight))
    (setq-default doom--font-scale nil)
    (set-frame-font doom-font 'keep-size t)
    (doom/reload-font)
    (run-hooks 'after-setting-font-hook)))

;;;###autoload
(defun my-ui/get-x-screen ()
  "Get a list of all connected screens."
  (-> "xrandr | grep ' connected ' | cut -d ' ' -f 1"
      (shell-command-to-string)
      (split-string "\n")
      (reverse)
      (cdr)
      (reverse)
      (cl-sort (lambda (a b)
                 (cond ((string-match-p "^eDP" a) t)
                       ((string-match-p "^eDP" b) nil)
                       (t nil))))))

;;;###autoload
(defun my-ui/has-display-connected? (screen)
  "Check if SCREEN is connected."
  (-contains? (my-ui/get-x-screen) screen))

;;;###autoload
(defun my-ui|adjust-ui-to-display ()
  "Adjust the UI to the current attached display."
  (interactive)
  (cond
   ((string= (system-name) "mbair")
    ;; Not actually a retina display, but this looks best
    (my-ui/adjust-font 13 5 "Fira Code"))
   ((string= (system-name) "Florians-iMac.local")
    (my-ui/adjust-font 14 10 "Menlo"))
   ((string= (system-name) "thinknix")
    (if (my-ui/has-display-connected? "DP2")
        (my-ui/adjust-font 18 7 "Fira Code" 'medium)
      (my-ui/adjust-font 15 4 "Fira Code" 'medium)))
   ((string= (system-name) "thinknixx1")
    (if (my-ui/has-display-connected? "DP-3")
        (my-ui/adjust-font 18 7 "Fira Code" 'medium)
      (my-ui/adjust-font 15 4 "Fira Code" 'medium)))
   ((string= (system-name) "Florians-MacBook-Air.local")
    (my-ui/adjust-font 14 10 "Menlo"))))
#+END_SRC
**** Line spacing hydra :HYDRA:

Change and reset line-spacing for all buffers.

#+BEGIN_SRC elisp
(defvar my-ui:default-line-spacing line-spacing)
(defvar my-ui:default-line-spacing-increment-step 1)
(defvar my-ui:default-big-line-spacing-increment-step 10)

(defun my-ui/set-line-spacing (&optional increment)
  "Set the line spacing
When no line spacing is given is the default-line-spacing"
  (setq-default line-spacing (+ (or increment my-ui:default-line-spacing-increment-step) line-spacing)))

(defun my-ui|reset-line-spacing ()
  (interactive)
  (setq-default line-spacing my-ui:default-line-spacing))

(defun my-ui|increase-line-spacing ()
  (interactive)
  (my-ui/set-line-spacing))

(defun my-ui|decrease-line-spacing ()
  (interactive)
  (my-ui/set-line-spacing (- my-ui:default-line-spacing-increment-step)))

(defun my-ui|increase-line-spacing-big ()
  (interactive)
  (my-ui/set-line-spacing my-ui:default-big-line-spacing-increment-step))

(defun my-ui|decrease-line-spacing-big ()
  (interactive)
  (my-ui/set-line-spacing (- my-ui:default-big-line-spacing-increment-step)))

(evil-define-key 'normal 'global (kbd "]z") #'my-ui/line-spacing-hydra/body)

;;;###autoload (autoload '+common-lisp/macrostep/body "lang/common-lisp/autoload/hydras" nil nil)
(defhydra my-ui/line-spacing-hydra (:exit nil :hint nil :foreign-keys run :color pink)
  "
Macro Expansion
^^Definitions                           ^^Compiler Notes             ^^Stickers
^^^^^^─────────────────────────────────────────────────────────────────────────────────────
[_r_] Reset
[_]_] Expand
[_[_] Collapse
[_}_] Expand Big
[_{_] Collapse Big
"
  ("r" my-ui|reset-line-spacing)
  ("]" my-ui|increase-line-spacing)
  ("[" my-ui|decrease-line-spacing)
  ("}" my-ui|increase-line-spacing-big)
  ("{" my-ui|decrease-line-spacing-big)
  ("q" nil "cancel" :color blue))
#+END_SRC

**** TODO Theme Toggle

Toggle between a light and a dark theme.
Bound to ~SPC t t~.

#+BEGIN_SRC elisp
(defun my-ui|toggle-theme ()
  "Toggle between light and dark themes."
  (interactive)
  (-when-let* ((theme (pcase doom-theme
                        (`doom-one 'doom-one-light)
                        (`doom-one-light 'doom-one))))
    (message (t! "Toggling to theme: <<theme>>"))
    (setq doom-theme theme)
    (load-theme theme)))
#+END_SRC

*** Configuration
**** Zen mode & variable pitch fonts

#+BEGIN_SRC elisp
(setq +zen-text-scale 1.5)

(let ((height 140)
      (size 23))
  (setq doom-variable-pitch-font (font-spec :family "IBM Plex Sans" :size size)
        doom-serif-font (font-spec :family "IBM Plex Sans" :size size)))
#+END_SRC
**** Add frame padding

#+BEGIN_SRC elisp
(add-hook! '(window-setup-hook after-make-frame-functions)
  (defun my-ui/init-frame-ui (&optional frame)
    (interactive)
    "Re-enable menu-bar-lines in GUI frames."
    (when-let (frame (or frame (selected-frame)))
      (when (display-graphic-p frame)
        (set-frame-parameter frame 'internal-border-width 15)))))
#+END_SRC

**** Theme Modifications

You can blend faces like this

#+begin_src elisp :tangle no
`(cider-test-error-face :background ,(ct-mix-opacity (face-attribute 'cider-test-error-face :background) (face-attribute 'default :background) 0.1))
#+end_src


***** General

#+BEGIN_SRC elisp
(add-hook 'doom-load-theme-hook #'*doom-themes-custom-set-faces)
#+END_SRC

****** Function Start

#+BEGIN_SRC elisp
(defun *doom-themes-custom-set-faces ()
  (set-face-attribute 'fringe nil
                      :foreground (face-background 'default)
                      :background (face-background 'default))
  (custom-set-faces!
#+END_SRC

****** General

#+begin_src elisp
'(whitespace-tab :background nil)
#+end_src

****** Bookmarks

#+BEGIN_SRC elisp
'(bookmark-face :background nil)
#+END_SRC

****** Cider

Remove border

#+begin_src elisp
'(cider-result-overlay-face :box nil)
`(cider-test-error-face :background ,(ct-mix-opacity (face-attribute 'cider-test-error-face :background) (face-attribute 'default :background) 0.1))
#+end_src

****** Dired Output

Remove the rainbow colors from dired.

#+BEGIN_SRC elisp
(when (eq doom-theme `doom-one)
  '(diredfl-read-priv :foreground "#80899E")
  '(diredfl-write-priv :foreground "#80899E")
  '(diredfl-exec-priv :foreground "#80899E")
  '(diredfl-other-priv :foreground "#80899E")

  '(all-the-icons-dired-dir-face :foreground "#80899E")

  '(diredfl-dir-priv :foreground "#282C34")
  '(diredfl-k-modified :foreground "#FF8E90")

  '(diredfl-number :foreground "#80899E")
  '(diredfl-date-time :foreground "#49505F")
  `(diredfl-dir-name :foreground "#2DADF2"))
#+END_SRC

****** Mu4E

Switch the highlight.

#+BEGIN_SRC elisp
'(mu4e-highlight-face :inherit mu4e-unread-face)
#+END_SRC

****** Org Mode

Remove the ugly grey background

#+BEGIN_SRC elisp
'(org-column :background nil)
#+END_SRC

****** Function End

#+BEGIN_SRC elisp
))
#+END_SRC

***** Hooks
****** Diff Highlighting

#+BEGIN_SRC elisp
(add-hook! '(diff-hl-margin-minor-mode-hook)
  (progn
    (set-face-attribute 'smerge-refined-added nil
                        :foreground (doom-blend "#98be65" "#3e493d" 0.15)
                        :background (doom-lighten "#98bb5d" 0.2))
    (set-face-attribute 'smerge-refined-removed nil
                        :foreground (doom-blend "#ff6c6b" "#4f343a" 0.2)
                        :background (doom-lighten "#ff6c6b" 0.1))))

(add-hook! '(magit-status-mode-hook magit-diff-mode-hook)
           (progn
                   (set-face-attribute 'diff-refine-added nil
                                       :foreground (doom-blend "#98be65" "#3e493d" 0.15)
                                       :background (doom-lighten "#98bb5d" 0.2))
                   (set-face-attribute 'diff-refine-removed nil
                                       :foreground (doom-blend "#ff6c6b" "#4f343a" 0.2)
                                       :background (doom-lighten "#ff6c6b" 0.1))))
#+END_SRC
**** Adjust UI

Resize the window font size etc according to the system.
This will be disabled in terminal mode.

#+BEGIN_SRC elisp
(add-hook! '(doom-init-ui-hook after-make-frame-functions)
  (defun my-ui*after-make-frame (&rest _)
    (when (display-graphic-p) (my-ui|adjust-ui-to-display))))
#+END_SRC
**** Scrolloff

Start scrolling X lines before the end of a screen.
Disable for certain modes (terminal & ivy) where the window is to small.

#+BEGIN_SRC elisp
(setq scroll-conservatively 10)
(setq scroll-margin 10)

(add-hook 'term-mode-hook (cmd! (setq-local scroll-margin 0)))
(add-hook 'ivy-mode-hook (cmd! (setq-local scroll-margin 0)))
#+END_SRC

**** (Visual) Fill Column

#+BEGIN_SRC elisp :tangle no
(setq-default fill-column 110)
(setq fill-column 110)
(setq visual-fill-column-width fill-column)

(setq visual-fill-column-center-text t
      visual-fill-column-width fill-column)
#+END_SRC

**** Disable trailing whitespace warning

#+BEGIN_SRC elisp :tangle no
(setq-hook! 'prog-mode-hook show-trailing-whitespace nil)
#+END_SRC

**** Fix underline

Draw the underline at the bottom of the text, not at the end of line-spacing.

#+BEGIN_SRC elisp
(setq x-underline-at-descent-line nil)
#+END_SRC

** Text
*** Functions
**** Expand region hydra :HYDRA:
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/also27/second_trial_for_a_weekly_tipstricksetc_thread/efi7pbj/
:END:

Expand visual region using a hydra.
Double press ~v~ to enable.

#+BEGIN_SRC elisp
(defhydra my-text/expand-region-hydra ()
   "region: "
   ("f" er/mark-defun "defun")
   ("v" er/expand-region "expand")
   ("V" er/contract-region "contract"))

(evil-define-key 'visual 'global (kbd "v") #'my-text/expand-region-hydra/body)
#+END_SRC
**** Unfill Paragraph

Fix a paragraph that was formatted to a fill column.

#+BEGIN_SRC elisp
(defun my-text|unfill-paragraph ()
  "Fix a paragraph that was formatted to a fill column."
  (interactive)
  (let ((fill-column (point-max)))
    (fill-paragraph nil)))
#+END_SRC
** Abbrev spell correction

[[https://www.emacswiki.org/emacs/AbbrevMode][EmacsWiki: Abbrev Mode]]
[[https://www.masteringemacs.org/article/correcting-typos-misspellings-abbrev][Correcting Typos and Misspellings with Abbrev - Mastering Emacs]]

*** Config

#+begin_src elisp
(define-abbrev-table 'global-abbrev-table
  '(("fnuction" "function" nil 1)
    ("lable" "label" nil 1)))

;; Only enable abbrev in text modes
(add-hook 'text-mode-hook #'abbrev-mode)
#+end_src

* Package Configuration
** Package Overrides / Disabling / Pinning

Packages that I haven't yet moved to their structure.

*** Doom Snippets

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! doom-snippets :ignore t)
(package! my-doom-snippets
  :recipe (:host github
           :repo "floscr/doom-snippets"
           :files ("*.el" "*")))
#+END_SRC

*** Posframe

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! flycheck-posframe :pin "6eea204138721f511051af5138326fecaad237b7")
#+END_SRC

*** Calfw
Continuous events are broken in the current calfw source,
also it seems it isn't maintained anymore.
[[https://github.com/floscr/emacs-calfw/commit/3d17649c545423d919fd3bb9de2efe6dfff210fe][This Commit]] fixes the behavior.

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! calfw :recipe (:host github :repo "floscr/emacs-calfw") :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-org :recipe (:host github :repo "floscr/emacs-calfw") :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-ical :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-cal :disable t)
(package! org-gcal :disable t)
#+END_SRC

*** json-proces-client

This package is originally hosted on https://gitea.petton.fr/nico/json-process-client.git/
But this private repository host went down a few times, so I'll stick to github.

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! json-process-client
  :recipe (:host github :repo "emacsmirror/json-process-client")
  :pin "373b2cc7e3d26dc00594e0b2c1bb66815aad2826")
#+END_SRC

*** Remove those annoying LSP interface plugins

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! lsp-ui :disable t)
#+END_SRC

*** merlin

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! merlin :pin "e4791e22986993c36c3f5c91e8dff93494cc232e")
(package! merlin-eldoc :disable t)
#+END_SRC

** Emacs :EMACS:
*** Libraries

Packages that enhance or fix ~emacs-lisp~.

**** [[https://github.com/nicferrier/emacs-noflet][noflet]] :FIX:

Override functions like variables with using ~(flet ((#'my-fn)))~

Since ~flet~ was deprecated, I'm using this for now.
Pretty much only used in [[*Expand snippet by name][Expand snippet by name]].

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! noflet)
#+END_SRC

** Doom :DOOM:
*** Popups

**** Defaults

These will be written to ~init.el~ so it overwrites the doom standard values.

#+BEGIN_SRC emacs-lisp :tangle "init.el" :comments no
(setq +popup-defaults
  (list :side   'bottom
        :height 0.45
        :width  40
        :quit   t
        :select t
        :ttl    5))
#+END_SRC

**** Rules

#+BEGIN_SRC elisp
(set-popup-rules!
  '(("^\\*Org Agenda" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*Org Src" :ignore t)
    ("^\\*Org QL View: \\(Work \\)?Projects*" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*PDF-Occur*" :side right :size 0.5 :select t :modeline t)
    ("^\\*WoMan " :side right :size 0.5 :select t :modeline t :ttl nil :quit nil)
    ("^\\*helm" :vslot -100 :size 0.32 :ttl nil)
    ("^\\*helpful command" :side right :size 0.5 :select t :modeline t :ttl nil :quit nil)
    ("^\\*nodejs" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*projectile-files-errors" :ignore t)
    ("^\\*elfeed-entry" :modeline t :ttl nil)
    ("^\\*Flycheck checker" :size 0.2 :select nil)
    ("^\\*cider-error" :size 0.2 :select nil :ttl t)))
#+END_SRC
*** Themes
**** Custom doom themes package

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link :tangle no
(package! doom-themes
  :recipe (:host github :repo "floscr/emacs-doom-themes" :files ("*.el" "themes/*.el"))
  :pin nil)
#+END_SRC

*** Workspaces
**** Functions
***** Switch to

Enhancement of the default ~+workspace/switch-to~.
This allows quick deletion of workspaces from ivy with ~CTRL + BACKSPACE~.

#+BEGIN_SRC elisp
(defvar counsel-workspace-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-<backspace>") #'my-workspaces|switch-to-delete-space)
    map))

(defun my-workspaces/switch-to-delete-space (workspace)
  (let* ((current-workspace-name (+workspace-current-name))
         (new-workspace-name
            (or (--first (string= current-workspace-name it) (+workspace-list-names)) "main")))
    (+workspace/delete workspace)
    (+workspace-switch new-workspace-name)
    (my-workspaces/switch-to)))

(defun my-workspaces|switch-to-delete-space ()
  (interactive)
  (ivy-set-action #'my-workspaces/switch-to-delete-space)
  (ivy-done))

(defun my-workspaces/switch-to ()
  (interactive)
  (ivy-read "Switch to workspace: "
            (+workspace-list-names)
            :keymap counsel-workspace-map
            :action #'+workspace/switch-to))
#+END_SRC

***** Close others

#+BEGIN_SRC elisp
(defun my-workspaces|close-others ()
  "Close all other workspaces."
  (interactive)
  (--> (+workspace-list-names)
       (--reject (string= (+workspace-current-name) it) it)
       (-each it #'+workspace-delete))) ;
#+END_SRC

***** Find workspace file

Most of the time you create workspaces from a project.
But when the CWD has changed in that workspace, you would have to relocate to
the projects cwd to find a file.

#+BEGIN_SRC elisp
(defun my-workspaces/workspace-project-root (&optional arg)
  "Gets the root dir for the current workspace"
  (--find (s-match (concat (+workspace-current-name) "/$") it) projectile-known-projects))

(defun my-workspaces|find-workspace-project-file ()
  "Projectile find file for the project named after the current workspace."
  (interactive)
  (cl-letf (((symbol-function 'projectile-project-root) #'my-workspaces/workspace-project-root))
    (projectile-find-file)))

(defun my-workspaces|workspace-project-vc ()
  "Projectile find file for the project named after the current workspace."
  (interactive)
  (let ((default-directory
          (or (my-workspaces/workspace-project-root)
              (my-file/project-root))))
    (magit-status)))
#+END_SRC

***** New named workspace

#+BEGIN_SRC elisp
(defun +workspace/new-named ()
  "Create a new named workspace."
  (interactive)
  (let ((name (read-string "New workspace name: ")))
    (if name (+workspace/new name))))
#+END_SRC

***** Cleanup

#+BEGIN_SRC elisp
(defun my-workspaces/remove-other-buffers (&optional keep-alive?)
  "Kill or remove all other buffers from current workspace."
  (interactive)
  (--> (+workspace-buffer-list)
       (--reject (eq (current-buffer) it) it)
       (if keep-alive?
           (persp-remove-buffer it)
         (kill-buffer it))))

(defun my-workspaces|hide-other-buffers ()
  "Hide all inactive buffers from the current workspace."
  (interactive)
  (my-workspaces/remove-other-buffers t))

(defun my-workspaces|kill-other-buffers ()
  "Kill all interactive buffers from the current workspace."
  (interactive)
  (my-workspaces/remove-other-buffers))

(defun my-workspaces|hide-non-project-buffers ()
  "Hide all file buffers that don't belong to the project workspace."
  (interactive)
  (let ((project-path (or (expand-file-name (my-workspaces/workspace-project-root))
                          (projectile-project-root))))
    (-some--> (+workspace-buffer-list)
         ;; Dont remove non-remove buffers
         (--filter (buffer-file-name it) it)
         (--reject (s-contains? project-path (buffer-file-name it)) it)
         (--each (persp-remove-buffer it) it))))
#+END_SRC

**** Config
***** Always add buffers to current workspace

Doom per default adds buffers to the current workspace on ~find-file~.
I want buffers added whenever I visit a buffer.

#+BEGIN_SRC elisp
(after! persp-mode
  (defun my-workspaces*add-special-buffer ()
    (if-let* ((name (buffer-name))
              (add-buffer? (or (buffer-file-name)
                               (s-matches? "\\*Org Src.*" name)
                               (s-matches? "\\*Code Review" name))))
      (persp-add-buffer (current-buffer) (get-current-persp))))

  (add-hook 'doom-switch-buffer-hook #'my-workspaces*add-special-buffer))
#+END_SRC
*** Lookup

#+begin_src elisp
(defun my-lookup/prepend-custom-docs-to-lookup (&rest args)
  (user-error "foo")
  (apply orig-fun args)
  args)

(defun my-lsp/describe-thing-at-point ()
  "Display the type signature and documentation of the thing at point."
  (interactive)
  (prn "hello"))

(advice-add 'lsp-describe-thing-at-point :around #'my-lsp/describe-thing-at-point)
(advice-remove 'lsp-describe-thing-at-point #'my-lsp/describe-thing-at-point)

(comment
 (advice-remove #'lsp-describe-thing-at-point #'my-lookup/prepend-custom-docs-to-lookup)
 nil)
#+end_src

** Evil :EVIL:
*** Packages
**** [[https://github.com/tarao/evil-plugins][tarao/evil-plugins]]

Used for [[*Little Word Motion][evil-little-word]].

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! evil-plugin :recipe (:host github :repo "tarao/evil-plugins"))
#+END_SRC

**** [[https://github.com/emacsmirror/evil-replace-with-register][evil-replace-with-register: Replace with register motion]]

Replace the current selection with a register.
Press =gr= with a following motion character like =w=.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! evil-replace-with-register)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(evil-define-operator my-evil-replace-with-register (count beg end type register)
  "Replacing an existing text with the contents of a register"
  :move-point nil
  (interactive "<vc><R><x>")
  (my-parinfer/save-excursion
   "paren"
   (setq count (or count 1))
   (let ((text (if register
                   (evil-get-register register)
                 (current-kill 0))))
     (goto-char beg)
     (if (eq type 'block)
         (evil-apply-on-block
          (lambda (begcol endcol)
            (let ((maxcol (evil-column (line-end-position))))
              (when (< begcol maxcol)
                (setq endcol (min endcol maxcol))
                (let ((beg (evil-move-to-column begcol nil t))
                      (end (evil-move-to-column endcol nil t)))
                  (delete-region beg end)
                  (dotimes (_ count)
                    (insert text))))))
          beg end t)
       (delete-region beg end)
       (dotimes (_ count)
         (insert text))
       (when (and evil-replace-with-register-indent (/= (line-number-at-pos beg) (line-number-at-pos)))
         ;; indent if more then one line was inserted
         (save-excursion
           (evil-indent beg (point))))))))

(use-package! evil-replace-with-register
  :config
  (setq evil-replace-with-register-key (kbd "gr"))
  (define-key evil-normal-state-map
    evil-replace-with-register-key 'my-evil-replace-with-register)
  (define-key evil-visual-state-map
    evil-replace-with-register-key 'my-evil-replace-with-register))
#+END_SRC
**** [[https://github.com/urbint/evil-text-objects-javascript][evil-text-objects-javascript: Javascript motions]]

- "f" - function
- "c" - single-line comment
- "C" - multi-line comment

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! evil-text-objects-javascript :recipe (:host github :repo "urbint/evil-text-objects-javascript"))
#+END_SRC

**** [[https://github.com/hlissner/evil-snipe][evil-snipe: 2-char searching ala vim-sneak & vim-seek, for evil-mode]]
***** Config
****** Repeat snipe after further key press

#+BEGIN_SRC elisp
(after! evil-snipe
  (setq evil-snipe-repeat-keys t))
#+END_SRC
**** [[https://github.com/NicholasBHubbard/clean-kill-ring.el][clean-kill-ring.el: Keep your kill ring clean]]

Filters out whitespace from the kill ring

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! clean-kill-ring
  :recipe (:type git
           :host github
           :repo "NicholasBHubbard/clean-kill-ring.el")
  :pin "3338a186329a1bef19e6781aa75befa5a0d031be")
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! clean-kill-ring
  :config (clean-kill-ring-mode 1))
#+END_SRC

*** Functions

**** Evil Insert

#+begin_src elisp
(defun my-evil/insert-dwim (str)
  "The evil normal cursor does not visually represent the emacs insert cursor.
So inserting things will be off by one character.
This function will insert how I would expect to insert depending on the mode.
In normal/visual mode -> After the character
In insert mode -> at the character"
  (if (eq evil-state 'insert)
      (insert str)
    (evil-append 1)
    (insert str)
    (evil-change-to-previous-state)
    (unless (string= "" str) (backward-char 1))))
#+end_src


**** Evil ex search for string

#+begin_src elisp
(defun my-evil/ex-search-str (str)
  "Evil Ex search for STR."
  (setq evil-ex-search-pattern
        (let (evil-ex-search-vim-style-regexp)
          (evil-ex-make-search-pattern str))
        evil-ex-search-offset nil
        evil-ex-last-was-search t)
  (unless (equal (car-safe evil-ex-search-history) str)
    (push str evil-ex-search-history))
  (evil-ex-search-next))
#+end_src

*** Config
**** Enable fine undo

Whether evil actions like =cw= are undone in several steps.
This is sometimes annoying, as it might need you to press =u= multiple times.
But I prefer the fine grained control, as I'm often staying longer in insert mode,
and don't want one single undo action for the whole "session".

#+BEGIN_SRC elisp
(setq evil-want-fine-undo t)
#+END_SRC
** Text Editing :TEXT:
*** Packages
**** [[https://github.com/sulami/literate-calc-mode.el][literate-calc-mode]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! literate-calc-mode)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! literate-calc-mode
  :commands (literate-calc-mode literate-calc-minor-mode))
#+END_SRC

**** [[https://github.com/joostkremers/writeroom-mode][writeroom-mode]]

Distraction free writing

***** Config

****** Custom Design :FIX:

#+BEGIN_SRC elisp
(defun my-writeroom/setup ()
  (if writeroom-mode
      (my-writeroom/load)
    (my-writeroom/unload)))

(defun my-writeroom/load ()
  (setq-local line-spacing 0.4)
  (setq-local +writeroom:faceremaps
              (list
               (face-remap-add-relative
                'org-link `(:foreground ,(face-attribute 'default :foreground)
                            :underline ,(face-attribute 'default :foreground)
                            :weight normal))
               (face-remap-add-relative
                'default `(:foreground ,(doom-blend
                                         (face-attribute 'default :background)
                                         (face-attribute 'default :foreground)
                                         0.1))))))

(defun my-writeroom/unload ()
  (kill-local-variable 'line-spacing)
  (mapc #'face-remap-remove-relative +writeroom:faceremaps)
  (kill-local-variable '+writeroom:faceremaps))

(add-hook! 'writeroom-mode-hook #'my-writeroom/setup)
#+END_SRC
**** [[https://github.com/joostkremers/visual-fill-column][visual-fill-column]]

Centered buffers, doom does not support this anymore.

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! visual-fill-column)
#+END_SRC
**** [[https://www.emacswiki.org/emacs/NarrowIndirect][narrow-indirect]]

When narrowing to region or defun, make it in an indirect other window.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! narrow-indirect :recipe (:host github :repo "emacsmirror/narrow-indirect"))
#+END_SRC

***** Bindings

#+BEGIN_SRC elisp
(use-package! narrow-indirect
  :init
  (global-set-key (kbd "C-x n n") 'ni-narrow-to-region-indirect-other-window)
  (global-set-key (kbd "C-x n d") 'ni-narrow-to-defun-indirect-other-window))
#+END_SRC

**** [[https://github.com/eraserhd/parinfer-rust][parinfer-rust]]

***** Functions

****** Save parinfer excursion

#+begin_src elisp
(defmacro my-parinfer/save-excursion (mode &rest body)
  `(let ((prev-mode (symbol-value 'parinfer-rust--mode)))
     (parinfer-rust--switch-mode ,mode)
     ,@body
     (parinfer-rust--switch-mode prev-mode)))
#+end_src
***** Bindings

****** Paste in paren mode

Better pasting for lisps, automatically indents and fixes parens when pasting.

#+begin_src elisp
(defun my-parinfer|yank ()
  "Yank with temporary paren mode enabled."
  (interactive)
  (my-parinfer/save-excursion "paren"
                              (let ((beg (point)))
                                (->> (current-kill 0)
                                     (substring-no-properties)
                                     (s-trim-left)
                                     (s-trim)
                                     (insert))
                                (let ((end (point)))
                                  (evil-indent beg end)))))

(map!
 :mode (clojure-script-mode clojure-mode emacs-lisp-mode)
 :gi
 "s-v" #'my-parinfer|yank)
#+end_src

**** format-all

#+begin_src elisp
;; Set formatter to empty list which should be defined per mode
(setq +format-on-save-enabled-modes '())
#+end_src
**** undo-tree

***** Config

#+BEGIN_SRC elisp
(use-package! undo-tree
  :config
  (setq undo-tree-history-directory-alist `(("." . ,(concat doom-cache-dir "undo-tree-hist/"))
                                            ;; Dont save undo history for org files, they get too big
                                            ("\\.org\\'" . nil))))
#+END_SRC

** UI :UI:
*** Higlight indent guides

**** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! highlight-indent-guides :pin "cf352c85cd15dd18aa096ba9d9ab9b7ab493e8f6")
#+END_SRC

**** Config

#+BEGIN_SRC elisp
(use-package! highlight-indent-guides
  :hook ((stylus-mode) . highlight-indent-guides-mode)
  :init
  (setq highlight-indent-guides-method 'character
        highlight-indent-guides-suppress-auto-error t)
  :config
  (defun +indent-guides-init-faces-h (&rest _)
    (when (display-graphic-p)
      (highlight-indent-guides-auto-set-faces)))

  ;; HACK `highlight-indent-guides' calculates its faces from the current theme,
  ;;      but is unable to do so properly in terminal Emacs, where it only has
  ;;      access to 256 colors. So if the user uses a daemon we must wait for
  ;;      the first graphical frame to be available to do.
  (add-hook 'doom-load-theme-hook #'+indent-guides-init-faces-h)
  (when doom-theme
    (+indent-guides-init-faces-h)))
#+END_SRC

** Programming :PROGRAMMING:
*** General Purpose
**** INACTIVE [[https://github.com/emacs-tree-sitter/elisp-tree-sitter][tree-sitter]] :EMACS:

***** Package

#+BEGIN_SRC emacs-lisp :tangle no
(package! tree-sitter)
(package! tree-sitter-langs)
#+end_src

***** Config

#+begin_src emacs-lisp :tangle no
(use-package! tree-sitter
  :config
  (require 'tree-sitter-langs)
  ;; (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src
**** [[https://github.com/chubin/cheat.sh][cheat-sh]] :CLI:

Community collection of snippets for command line tools.

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! cheat-sh)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package cheat-sh
  :commands (cheat-sh)
  :config
  (setq cheat-sh-topic-mode-map
        '((awk-mode . "awk")
          (c++-mode . "cpp")
          (c-mode . "c")
          (clojure-mode . "clojure")
          (clojurescript-mode . "clojure")
          (dockerfile-mode . "docker")
          (emacs-lisp-mode . "elisp")
          (fish-mode . "fish")
          (go-mode . "go")
          (haskell-mode . "haskell")
          (hy-mode . "hy")
          (java-mode . "java")
          (js-jsx-mode . "javascript")
          (js-mode . "javascript")
          (js-mode . "js")
          (lisp-interaction-mode . "elisp")
          (lisp-mode . "lisp")
          (objc-mode . "objectivec")
          (pike-mode . "pike")
          (powershell-mode . "powershell")
          (python-mode . "python")
          (rust-mode . "rust")
          (sh-mode . "bash")
          (nim-mode . "nim"))))
#+END_SRC
**** [[https://github.com/smihica/emmet-mode][emmet-mode]] :CSS:


***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! emmet-mode)
#+end_src

***** Functions
****** Indent or Yase Emmet Expand

Source: [[file:~/.emacs.d/modules/lang/web/autoload/html.el::defun +web/indent-or-yas-or-emmet-expand (][Doom: modules/lang/web/autoload/html.el]]

#+begin_src emacs-lisp
(defun my:emmet/indent-or-yas-or-emmet-expand ()
  "Do-what-I-mean on TAB.

Invokes `indent-for-tab-command' if at or before text bol, `yas-expand' if on a
snippet, or `emmet-expand-yas'/`emmet-expand-line', depending on whether
`yas-minor-mode' is enabled or not."
  (interactive)
  (let ((action (cond ((or (<= (current-column) (current-indentation)
                                    (not (eolp))
                                    (not (or (memq (char-after) (list ?\n ?\s ?\t))
                                             (eobp)))
                                #'indent-for-tab-command))
                       ((featurep! :editor snippets)
                        (require 'yasnippet)
                        (if (yas--templates-for-key-at-point
                                #'yas-expand
                                #'emmet-expand-yas))))
                      (#'emmet-expand-line))))
    (call-interactively action)))
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! emmet-mode
  :preface (defvar emmet-mode-keymap (make-sparse-keymap))
  :hook (css-mode web-mode html-mode haml-mode nxml-mode)
  :config
  (when (require 'yasnippet nil t)
    (add-hook 'emmet-mode-hook #'yas-minor-mode-on))

  (setq emmet-css-major-modes '(css-mode
                                scss-mode
                                stylus-mode
                                sass-mode
                                less-mode
                                less-css-mode))

  (add-hook! 'stylus-mode-hook #'emmet-mode)
  (setq-hook! 'stylus-mode-hook emmet-use-sass-syntax t)
  (setq emmet-indent-after-insert nil)

  (defadvice! my-emmet/fix-stylus-colon (&optional arg1)
     :after '(emmet-expand-yas emmet-expand-line)
     (when (eq major-mode 'stylus-mode)
       (save-excursion
        (search-backward ":" nil nil)
        (delete-char 1))))

  (setq emmet-move-cursor-between-quotes t)
  (map! :map emmet-mode-keymap
        :v [tab] #'emmet-wrap-with-markup
        [tab] #'my:emmet/indent-or-yas-or-emmet-expand
        "M-E" #'emmet-expand-line)

  (puthash "aic" "align-items:center;" emmet-css-snippets)
  (puthash "brd" "border-radius:|;" emmet-css-snippets)
  (puthash "df" "display:flex;" emmet-css-snippets)
  (puthash "dn" "display:none;" emmet-css-snippets)
  (puthash "fdc" "flex-direction:column;" emmet-css-snippets)
  (puthash "fdr" "flex-direction:row;" emmet-css-snippets)
  (puthash "g" "gap:|;" emmet-css-snippets)
  (puthash "jcc" "justify-content:center;" emmet-css-snippets)
  (puthash "ov" "overflow:hidden;" emmet-css-snippets)
  (puthash "pen" "pointer-events:none;" emmet-css-snippets)
  (puthash "po" "top: 0;\nleft: 0;\nright: 0;\nbottom: 0;" emmet-css-snippets)
  (puthash "posa" "position:absolute;" emmet-css-snippets)
  (puthash "posf" "position:fixed;" emmet-css-snippets)
  (puthash "posr" "position:relative;" emmet-css-snippets))
#+END_SRC
**** [[https://elpa.gnu.org/packages/rainbow-mode.html][rainbow-mode]] :UI:

Pretty print colors string with the color as the background.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! rainbow-mode)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package rainbow-mode
  :commands (rainbow-mode)
  :config
  ;; Always enable rgb, etc colors
  (setq rainbow-html-colors t))
#+END_SRC
**** [[https://github.com/skeeto/impatient-mode][impatient-mode]] :BROWSER:

A live reload server directly in emacs for quickly editing css.
Launch using [[*Launch][my-impatient-mode|launch]].

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! impatient-mode)
#+END_SRC

***** Functions

****** Launch

#+begin_src emacs-lisp
(defun my-impatient-mode|launch ()
  "Launch server with impatient mode and open the browser."
  (interactive)
  (httpd-start)
  (impatient-mode)
  (let ((file-name (f-filename (+yank/buffer-filename))))
    (browse-url (t! "http://localhost:8080/imp/live/<<file-name>>"))))

(defun my-impatient-mode|stop ()
  "Launch server with impatient mode and open the browser."
  (interactive)
  (httpd-stop)
  (impatient-mode -1))
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! impatient-mode
  :commands impatient-mode)
#+END_SRC
**** [[https://github.com/redguardtoo/diff-lisp][diff-lisp]] :TEXT:

- Select a region and run the command diff-lisp-mark-selected-text-as-a.
- Select another region and run diff-lisp-diff-a-and-b.
- The difference of two region is displayed in a buffer.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! diff-lisp :recipe (:host github :repo "redguardtoo/diff-lisp"))
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! diff-lisp)
#+END_SRC

*** Database :DATABASE:
**** Packages
***** TODO [[https://github.com/kiwanami/emacs-edbi][edbi]]

Emacs database layer interface

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! edbi)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! package)
#+END_SRC

****** Bridge

Add nix-shell headers to the bridge

Use with header ~:tangle "edbi-bridge.pl"~

#+BEGIN_SRC perl :tangle no
#! /usr/bin/env nix-shell
#! nix-shell -i perl -p mysql -p perlPackages.DBDmysql perlPackages.RPCEPCService perlPackages.DBDPg perlPackages.DBI

use strict;
use RPC::EPC::Service;
use Data::Dumper;
use DBI;

our $dbh = undef;
our $sth = undef;

sub edbi_connect {
  my ($args) = @_;
  my ($data_source,$username,$auth) = @$args;

  # No input _probably_ means "no password" rather than empty string
  $auth = undef if($auth eq "");

  if ($dbh) {
    eval {
      $dbh->disconnect();
    }
  }

  our $dbh = DBI->connect($data_source, $username, $auth)
      or die("Could not connect to database:
Data Source ($data_source)
User Name: ($username):
DBI error: ($DBI::errstr)
");

  return $dbh->get_info(18);
}

sub edbi_do {
  return undef unless $dbh;
  my ($args) = @_;
  my ($sql, $params) = @$args;
  my $rows = $dbh->do($sql, undef, @$params);
  return $rows;
}

sub edbi_select_all {
  return undef unless $dbh;
  my ($args) = @_;
  my ($sql, $params) = @$args;
  my $rows = $dbh->selectall_arrayref($sql, undef, @$params);  return $rows;
}

sub edbi_prepare {
  return undef unless $dbh;
  $sth->finish() if $sth;
  my ($sql) = @_;
  our $sth = $dbh->prepare($sql) or return undef;
  return 'sth';
}

sub edbi_execute {
  return undef unless $sth;
  my ($params) = @_;
  return $sth->execute(@$params) or return undef;
}

sub edbi_fetch_columns {
  return undef unless $sth;
  return $sth->{NAME};
}

sub edbi_fetch {
  return undef unless $sth;
  my ($num) = @_;
  if ($num eq undef) {
    return $sth->fetchall_arrayref();
  } else {
    my $ret = [];
    for (my $i = 0; $i < $num; $i++) {
      my $row = $sth->fetchrow_arrayref();
      last if $row eq undef;
      push @$ret, [@$row];
    }
    return $ret;
  }
}

sub edbi_auto_commit {
  return undef unless $dbh;
  my ($flag) = @_;
  if ($flag eq "true") {
    $dbh->{AutoCommit} = 1;
    return 1;
  } else {
    $dbh->{AutoCommit} = 0;
    return 0;
  }
}

sub edbi_commit {
  return undef unless $dbh;
  $dbh->commit();
  return 1;
}


sub edbi_rollback {
  return undef unless $dbh;
  $dbh->rollback();
  return 1;
}

sub edbi_disconnect {
  return undef unless $dbh;
  $dbh->disconnect();
  return 1;
}

sub edbi_status {
  return undef unless $dbh;
  return [$dbh->err, $dbh->errstr, $dbh->state];
}

sub edbi_type_info_all {
  return undef unless $dbh;
  my $ret = $dbh->type_info_all;
  print STDERR Dumper $ret;
  return $dbh->type_info_all;
}

sub edbi_table_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table, $type) = @$args;
  $sth = $dbh->table_info( $catalog, $schema, $table, $type );
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_column_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table, $column) = @$args;
  $sth = $dbh->column_info( $catalog, $schema, $table, $column );
  return [[],[]] unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_primary_key_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table) = @$args;
  $sth = $dbh->primary_key_info( $catalog, $schema, $table );
  return undef unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_foreign_key_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($pkcatalog, $pkschema, $pktable, $fkcatalog, $fkschema, $fktable) = @$args;
  $sth = $dbh->foreign_key_info( $pkcatalog, $pkschema, $pktable,
                                 $fkcatalog, $fkschema, $fktable );
  return undef unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub main {
  my $methods =
    {
     'connect' => [\&edbi_connect,"data_source, username, auth", ""],
     'do' => [\&edbi_do, "sql, params", ""],
     'select-all' => [\&edbi_select_all, "sql, params", ""],
     'prepare' => [\&edbi_prepare, "sql", ""],
     'execute' => [\&edbi_execute, "params", ""],
     'fetch-columns' => [\&edbi_fetch_columns, "", ""],
     'fetch' => [\&edbi_fetch, "[number]", ""],
     'auto-commit' => [\&edbi_auto_commit, "false/true", ""],
     'commit' => [\&edbi_commit, "", ""],
     'rollback' => [\&edbi_rollback, "", ""],
     'disconnect' => [\&edbi_disconnect, "", ""],
     'status' => [\&edbi_status, "", ""],
     'type-info-all' => [\&edbi_type_info_all, "", ""],
     'table-info' => [\&edbi_table_info, "catalog, schema, table, type", ""],
     'column-info' => [\&edbi_column_info, "catalog, schema, table, column", ""],
     'primary-key-info' => [\&edbi_primary_key_info, "catalog, schema, table", ""],
     'foreign-key-info' => [\&edbi_foreign_key_info, "pk_catalog, pk_schema, pk_table, fk_catalog, fk_schema, fk_table", ""],
    };
    my $server = RPC::EPC::Service->new(0, $methods);
    $server->start;
}

main;

#+END_SRC

#+BEGIN_SRC elisp
(after! edbi
  (setq edbi:driver-info
        (list
         "nix-shell" "-p"
         "perl"
         "-p" "perlPackages.DBI"
         "-p" "perlPackages.RPCEPCService"
         "-p" "perlPackages.DBDPg"
         "-p" "perlPackages.DBDmysql"
         "--run"
         (f-join doom-private-dir "edbi-bridge.pl"))))
#+END_SRC

*** Javascript :JAVASCRIPT:
**** Packages :PACKAGE:
***** [[https://github.com/aaronjensen/eslintd-fix][eslintd-fix]] :LINTING:AUTOFIX:

A javascript auto-fixer that isn't slow.
Needs [[https://www.npmjs.com/package/eslint_d][eslint_d]] binary in ~$PATH~.

****** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! eslintd-fix)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! eslintd-fix
  :after js2-mode
  :config
  (setq
   flycheck-javascript-eslint-executable (executable-find "eslint_d")
   flycheck-disabled-checkers '(javascript-jshint javascript)))
#+END_SRC

****** Functions
******* Enable eslintd for writable buffers

#+begin_src elisp
(defun my:js/start-eslint ()
  "Start eslint on writable buffers.

When enabling on read-only buffers it will throw an error."
  (unless buffer-read-only
    (eslintd-fix-mode)))

(add-hook 'js2-mode-hook #'my:js/start-eslint)
#+end_src
***** [[https://github.com/floscr/js-import][floscr/js-import]] :AUTOFIX:FORK:

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! js-import :recipe (:host github :repo "floscr/js-import"))
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(put 'js-import-alias-map 'safe-local-variable (lambda (x) t))
#+END_SRC
***** [[https://github.com/Emiller88/emacs-jest][jest]] :FORK::UNIT_TESTING:

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! jest :recipe (:host github :repo "floscr/emacs-jest"))
#+END_SRC

****** Config

#+begin_src emacs-lisp
(use-package! jest
  :after (js2-mode)
  :hook (js2-mode . jest-minor-mode)
  :config
  (set-popup-rule! "^\\*jest\\*"
    :side 'right
    :size 0.5
    :select nil :quit 'current :ttl nil))
#+end_src

***** [[https://github.com/NicolasPetton/Indium][indium]]

A JavaScript development environment for Emacs.

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! indium)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! indium
  :commands (indium-connect indium-launch)
  :init
  (setq indium-chrome-use-temporary-profile t)
  (setq indium-chrome--default-data-dir (f-join (getenv "XDG_CACHE_HOME") "inidum-chrome-profile"))
  (setq indium-chrome-data-dir (f-join (getenv "XDG_CACHE_HOME") "inidum-chrome-profile"))
  (map! :map (js2-mode-map rjsx-mode-map)
        :localleader
        (:prefix ("i" . "Indium")
          :desc "Console"                   "c" #'indium-switch-to-repl-buffer
          :desc "Launch"                    "l" #'indium-launch
          :desc "Launch"                    "q" #'indium-quit
          :desc "Add breakpoint"            "r" #'indium-reload
          (:prefix ("b" . "breakpoint")
            :desc "Add"                     "b" #'indium-add-breakpoint
            :desc "Conditional"             "c" #'indium-add-conditional-breakpoint
            :desc "Conditional"             "e" #'indium-edit-breakpoint-condition
            :desc "Conditional"             "l" #'indium-list-breakpoints
            :desc "Conditional"             "0" #'indium-deactivate-breakpoints
            :desc "Conditional"             "1" #'indium-activate-breakpoints
            :desc "Delete"                  "d" #'indium-remove-breakpoint
            :desc "Delete all from buffer"  "D" #'indium-remove-all-breakpoints-from-buffer
            :desc "Edit Condition"          "e" #'indium-toggle-breakpoint
            :desc "Toggle"                  "t" #'indium-toggle-breakpoint)))
  (map!
        :map indium-inspector-mode-map
        :n "-" #'indium-inspector-pop)
  (map! :map indium-debugger-mode-map
        :n "gr" #'indium-debugger-resume
        :n "gi" #'indium-debugger-step-into
        :n "go" #'indium-debugger-step-over
        :n "ge" #'indium-debugger-evaluate
        :n "gl" #'indium-debugger-locals)
  :config
  (set-popup-rule! "^\\*JS REPL*" :size 0.3)
  (set-popup-rule! "^\\*JS Debugger Locals*" :size 0.3))
#+END_SRC
***** [[https://github.com/mojochao/npm-mode][npm]]

****** Functions
******* Add CI command

No namespace here, so it matches the other commmands

#+BEGIN_SRC elisp
(defun npm-mode-npm-ci ()
  "Run the 'npm install' command."
  (interactive)
  (npm-mode--exec-process "npm ci"))
#+END_SRC
***** [[https://github.com/vermiculus/graphql.el][graphql]]
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! graphql)
#+END_SRC

**** Functions
***** Match const function name

#+BEGIN_SRC elisp
(defun my-javascript/match-const-function-name (line)
  "Matches a line to the word after the declaration"
  (nth 2 (s-match
          "\\(const\\|let\\|class\\)\s\\(.+?\\)\s"
          line)))

(defun my-javascript/const-function-at-point ()
  "Returns the current function name at the current line"
  (my-javascript/match-const-function-name (thing-at-point 'line t)))
#+END_SRC
***** Setup test files

- add it/it-only text rotate

#+begin_src elisp
(add-hook! 'js2-mode-hook
  (defun my-javascript/setup-test-file-vars ()
    "Sets up variables for test files (cypress, jest)."
    (when (-some->> (buffer-file-name)
            (string-match "\\.\\(test\\|spec\\|cy\\)\\.js$"))
      ;; Rotate it/it.only
      (add-to-list 'rotate-text-local-patterns '("it\\(\\.only\\)?" (lambda (x y) (if (string= x "it") "it.only" "it")))))))
#+end_src

*** Emacs Lisp (Elisp) :ELISP:
**** Packages
**** Functions

#+begin_src elisp
(defun my-elisp|eval-last-sexp (&optional output-to-current-buffer)
  (interactive "P")
  (let ((previous-evil-state evil-state))
    (save-excursion
      (my-cider/eval-jump-opening-brace)
      (when (eq previous-evil-state 'normal)
        (evil-insert-state)
        (forward-char 1))
      (eval-last-sexp output-to-current-buffer)
      ;; Dont restore state when doing eval when inserting result
      ;; The `cider-eval-print-handler' function is async,
      (when (and (not output-to-current-buffer)
                 (eq previous-evil-state 'normal))
        (evil-normal-state)))))
#+end_src

**** Config

***** Remove Rainbow Delimiters

I don't need them with parinfer and lispyville, they're just distracting.

#+begin_src elisp
(remove-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
#+end_src
**** Bindings

#+begin_src elisp
(map! :map emacs-lisp-mode-map
      :desc "Eval" :n "RET" #'my-elisp|eval-last-sexp)
#+end_src


*** Json :JSON:
**** Functions
***** Is Last JSON key at point

#+BEGIN_SRC elisp
(defun my-json/is-last-key? ()
  "Is the next line the last json key."
  (save-excursion
    (forward-line)
    (my-buffer/line-contains "}")))
#+END_SRC

***** Insert JSON Key

Insert JSON key in a JSON document
This functions is dependant on the yasnippet: [[file:snippets/json-mode/key::# --][key]]

#+BEGIN_SRC elisp
(defun my-json/insert-key (&optional above?)
  "Adds a new JSON key pair."
  (let ((last-line? (my-buffer/line-contains ",$")))
    ;; Insert comma
    (if (and (not last-line?) (not above?))
        (replace-regexp "$" "," nil (point-at-bol) (point-at-eol)))
    (end-of-line)
    (if above?
        (evil-insert-newline-above)
      (evil-insert-newline-below))
    (indent-according-to-mode)
    (my-snippets/insert-by-name "key")))

(defun my-json|insert-key-above ()
  "Function docstring"
  (interactive)
  (my-json/insert-key t))

(defun my-json|insert-key-below ()
  "Function docstring"
  (interactive)
  (my-json/insert-key nil))
#+END_SRC

***** Autofix JSON

Uses [[https://www.npmjs.com/package/json-fix][json-fix]] to autofix JSON files.

#+BEGIN_SRC bash :tangle no
npm i -g json-fix
#+END_SRC

#+BEGIN_SRC elisp
(defun my-json|autofix-buffer ()
  "Autofix json buffer"
  (interactive)
  (let ((b (if mark-active (min (point) (mark)) (point-min)))
        (e (if mark-active (max (point) (mark)) (point-max))))
    (shell-command-on-region b e
     (template "json-fix --no-sort --spaces <<tab-width>>") (current-buffer) t)))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after json-mode
 :map json-mode-map
 :gni "<C-return>" #'my-json|insert-key-below
 :gni "<C-S-return>" #'my-json|insert-key-above)
#+END_SRC
***** Functions
***** Export default variable

#+BEGIN_SRC elisp
(defun js2r-export-default ()
  "Exports the current declaration at the end of the file"
  (interactive)
  (save-excursion
    (let* ((name (my-javascript/const-function-at-point)))
      (goto-char (point-max))
      (insert "\n")
      (insert (template "export default <<name>>;")))))
#+END_SRC

***** Extract constant to file

Extract the ~const~ under the cursor into a new file.

#+BEGIN_SRC elisp
(defun js2r-extract-const-to-file ()
  "Extracts function to external file"
  (interactive)
  (let* ((name (my-javascript/const-function-at-point))
         (path (concat "./" name ".js")))
    (evil-digit-argument-or-evil-beginning-of-line)
    (js2r-kill)
    (f-write-text "" 'utf-8 path)
    (find-file path)
    (yank)))
#+END_SRC

***** Generate ~index.js~ file index

Generate a file index in the current file for every other file in the current directory.

#+BEGIN_SRC elisp
(defun +js/index-file-names (&optional dir)
  "Get filenames from current buffers directory."
  (let ((fs (directory-files (or dir default-directory) nil ".*\\.js")))
    (mapcar 'f-no-ext
            (remove "index.js" fs))))

(defun +js|generate-index (&optional dir ignore-list is-old-es-style)
  "Generate an index import file for files in directory.
Pass DIR for directory, falls back to default-directory
Pass IGNORE-LIST for a list of files
Pass IS-OLD-ES-STYLE for using the non-esm style exports"
  (interactive)
  (erase-buffer)
  (let* ((dir (or dir default-directory))
         (fs (->>
              (+js/index-file-names dir)
              (-log)
              (--reject (s-ends-with-p ".test" it))
              (--when ignore-list (--remove (-contains? ignore-list it) it)))))
    (message "%s" fs)
    (cond (is-old-es-style
           (progn
             (mapc (lambda (f) (insert "import " f " from './" f "';\n")) fs)
             (insert "\n")
             (insert "export default {\n")
             (mapc (lambda (f) (insert "    " f ",\n")) fs)
             (insert "};")))
          (t
           (mapc (lambda (f) (insert "export { default as " f " } from './" f "';\n")) fs)))))
#+END_SRC

***** Convert expression into template string

Converts an expression into a template string.

Example:
When you would call the function on the ~foo~ inside the console.log,
It would wrap it like this ~console.log(`${foo}`)~.

#+BEGIN_SRC elisp
(defun +js|convert-sexp-to-template-string ()
  "Wrap sexp into a template string"
  (interactive)
  (kill-sexp)
  (insert (concat "`${" (substring-no-properties (car kill-ring)) "}`"))
  (pop kill-ring))
#+END_SRC

***** Split / Join JSX Tag Node

Stolen from the vscode extension: [[https://github.com/dannyconnell/vscode-split-html-attributes][dannyconnell/vscode-split-html-attributes]]
I don't want to translate this to elisp, and js works as well.

Split/Joins a JSX tags by seperating the attributes

#+BEGIN_SRC js :tangle "./.cache/split-join-tag.js"
const useSpacesForTabs = true;
const tabSize = 4;
const sortOrder = [];
const closingBracketOnNewLine = true;

let input = process.argv[2]

// count the number of lines initally selected
let lineCount = input.split('\n').length
let lineText = input

// get the initial white space at the start of the line
let initialWhitespaceRegex = /\s*/i
let initialWhitespace = lineText.match(initialWhitespaceRegex)[0]

// get the opening tag
let openingTagRegex = /^[^\s]+/
let openingTag = input.match(openingTagRegex)[0]

// remove opening tag and trim
input = input.replace(openingTagRegex, '')
input = input.trim()

// get the ending bracket (if it's a "/>")
let endingBracket = ''
if (input.endsWith('/>')) {
    endingBracket = '/>'
}
else {
    endingBracket = '>'
}

// remove ending bracket and trim
if (endingBracket == '/>') {
    input = input.replace('/>', '')
}
else {
    input = input.substring(0, input.length - 1)
}
input = input.trim()

// create the indentation string
let indentationString
if (useSpacesForTabs == false) {
    indentationString = '\t'
}
else {
    indentationString = ' '.repeat(tabSize)
}

// regex to select all spaces that aren't within quotes
let spacesRegex = /\s+(?=([^"]*"[^"]*")*[^"]*$)/g

// get attributes into an array
let attributesString = input.replace(spacesRegex, '\n')
let attributesArray = attributesString.split('\n')

// sort the attributes array
let sortedAttributesArray = []
if (sortOrder.length) {

    // loop through sortOrder array
    sortOrder.forEach(search => {
        // loop through attributesArray
        let itemsToMove = []
        attributesArray.forEach((item, index) => {
            if (item.match(search)) {
                itemsToMove.push(index)
                // attributesArray.splice(index, 1)
            }
        })
        // move matched items from attributesArray to sortedAttributesArray (and sort them)
        let tempMatchedItems = []
        itemsToMove.forEach(indexItem => {
            tempMatchedItems.push(attributesArray[indexItem])
        })
        tempMatchedItems.sort()
        sortedAttributesArray.push(...tempMatchedItems)

        // remove matched items from attributesArray
        for (var i = itemsToMove.length - 1; i >= 0; --i) {
            attributesArray.splice(itemsToMove[i], 1)
        }
    })

    // sort remaining attributes and add to sortedAttributesArray
    attributesArray.sort()
    sortedAttributesArray.push(...attributesArray)
}
else {
    sortedAttributesArray = attributesArray
}

// add the opening tag
let result = openingTag

// set the join character based on number of lines initially selected
// (newLine if one line, space if more)
let joinCharacter = lineCount > 1 ? ' ' : '\n'

// if there are no attributes, set joinCharacter to ''
if (sortedAttributesArray.length == 1 && sortedAttributesArray[0] == '') {
    joinCharacter = ''
}

// add the sorted attributes to the textSplit string
if (lineCount > 1) {
    sortedAttributesArray.forEach(item => {
        result += joinCharacter + item
    })
}
else {
    sortedAttributesArray.forEach(item => {
        result += joinCharacter + initialWhitespace + indentationString + item
    })
}

// configure ending bracket (new line or not new line)
if (lineCount > 1) {
    if (endingBracket == '/>') {
        endingBracket = ' ' + endingBracket
    }
}
else {
    if (closingBracketOnNewLine) {
        endingBracket = '\n' + initialWhitespace + endingBracket
    }
    else if (endingBracket == '/>') {
        endingBracket = ' ' + endingBracket
    }
}

// add the ending bracket
result = result + endingBracket

console.log(result)
#+END_SRC

#+BEGIN_SRC elisp
(defun +rjsx/find-opening-closing-tag ()
  "Return the opening and closing carent character positions for a tag under the cursor."
  (save-excursion
    (let* ((is-evil-normal-state (evil-normal-state-p))
           (opening
            (or (-some->> (rjsx--tag-at-point)
                  (js2-node-abs-pos))
                ;; Fallback when js2-node-abs-pos parser fails
                (save-excursion (search-backward "<"))))
           (closing (progn
                      (when is-evil-normal-state
                        (evil-insert-state))
                      (while (and
                              (re-search-forward "[^=]>" (point-max) t nil)
                              (progn (backward-char 1) t)
                              (rjsx--tag-at-point)
                              (not (eq (js2-node-abs-pos (rjsx--tag-at-point)) opening))
                              (progn (forward-char 1) t)))
                      (when is-evil-normal-state
                        (evil-normal-state))
                      (forward-char 2)
                      (point))))
      (cons opening closing))))

(defun +rjsx/split-join ()
  "Function docstring"
  (interactive)
  (when (eq ?> (char-after))
    (backward-char 1))
  (-let* ((bounds (cond
                   ((use-region-p) (cons (region-beginning) (region-end)))
                   (t (+rjsx/find-opening-closing-tag))))
          ((beg . end) bounds)
          (input (->> (buffer-substring-no-properties beg end)
                   (s-replace "\n" "\\n")
                   (s-replace "'" "\\'")))
          (output (->> (shell-command-to-string (t! "node <<doom-private-dir>>/.cache/split-join-tag.js  $'<<input>>'"))
                    (s-trim-right))))
    (delete-region beg end)
    (insert output)
    (indent-region beg
                   ;; End position might be filled by whitespace, so we search again for the ending carent
                   (save-excursion (progn
                                     (goto-char (cdr (+rjsx/find-opening-closing-tag))))))))
#+END_SRC

***** Expand self closing tag

Converts self closing JSX tags to closing tags.
~<Foo />~ -> ~<Foo>|</Foo>~

#+BEGIN_SRC elisp
(defun +rjsx|expand-insert-self-closing-tag ()
  "Opens the current tag at any position of the cursor and starts insert mode"
  (interactive)
  (search-forward "/>")
  (evil-backward-char)
  (call-interactively #'delete-backward-char)
  (call-interactively #'rjsx-electric-gt)
  (newline)
  (call-interactively #'evil-indent-line)
  (call-interactively #'evil-open-above))
#+END_SRC

***** Extract Props from function arguments to body

#+BEGIN_SRC elisp
(defun +js|extract-props ()
  "Extract props object under the cursor."
  (interactive)
  (save-excursion
    (let* ((point-start (search-backward "{"))
           (point-end (search-forward "}"))
           (text (buffer-substring-no-properties point-start point-end)))
      (delete-region point-start point-end)
      (insert "props")
      (evil-open-below 1)
      (insert (template "const <<text>> = props;"))
      (search-backward "}")
      (js2r-expand-node-at-point)))
  (evil-normal-state))
#+END_SRC

***** Company Files

Remove the ~js~ extension for ~company-files~.

#+BEGIN_SRC elisp :tangle no
(defun company-js-files (command &optional arg &rest ignored)
  "Company complete path. Remove extension after completion"
  (interactive (list 'interactive))
  (require 'company)
  (cl-case command
    (interactive (company-begin-backend 'company-js-files))
    (prefix (company-files--grab-existing-name))
    (candidates (company-files--complete arg))
    (location (cons (dired-noselect
                     (file-name-directory (directory-file-name arg))) 1))
    (post-completion (when (s-matches? "\.js$" arg) (delete-backward-char 3)))
    (sorted t)
    (no-cache t)))

(map! :map js2-mode-map
      :i "C-x C-f" #'company-js-files)
#+END_SRC

***** Import JS File

#+BEGIN_SRC elisp :tangle no
(defun +js/import-file (file)
  (let ((cursor-postion (point))
        (filename (f-no-ext file)))
    (insert (template "import  from '<<filename>>';"))
    (goto-char cursor-postion)
    (forward-char 7)
    (evil-insert-state)))

(defun +js|ivy-import-file (&optional action)
  (interactive)
  (let* ((local-files
          (-->
           (-concat (list find-program) counsel-file-jump-args)
           (string-join it " ")
           shell-command-to-string
           split-string))
         (node-packages
          (-->
           (concat "jq -r '.dependencies | keys | .[]' " (concat (projectile-project-root) "package.json"))
           shell-command-to-string
           split-string))
         (imports (append local-files node-packages)))
    (ivy-read "Import file " imports :action (or action '+js/import-file))))
 #+END_SRC

***** Switch Ternary

#+BEGIN_SRC elisp
(defun js2r-ternary-switch-statements ()
  "Switch expressions in a ternary."
  (interactive)
  (js2r--guard)
  (js2r--wait-for-parse
   (save-excursion
     (let* ((ternary (js2r--closest 'js2-cond-node-p))
            (test-expr (js2-node-string (js2-cond-node-test-expr ternary)))
            (true-expr (js2-node-string (js2-cond-node-true-expr ternary)))
            (false-expr (js2-node-string (js2-cond-node-false-expr ternary)))
            (stmt (js2-node-parent-stmt ternary))
            (stmt-pre (buffer-substring (js2-node-abs-pos stmt) (js2-node-abs-pos ternary)))
            (stmt-post (s-trim (buffer-substring (js2-node-abs-end ternary) (js2-node-abs-end stmt))))
            (beg (js2-node-abs-pos stmt)))
       (goto-char beg)
       (delete-char (js2-node-len stmt))
       (insert "return " test-expr)
       (newline)
       (insert "? " false-expr)
       (newline)
       (insert ": " true-expr ";")
       (indent-region beg (point))))))
#+END_SRC

***** Ignore Flycheck error on line

#+BEGIN_SRC elisp
(defun +js|eslint-fix-ignore-error ()
  "Adds an ignore with the current flycheck error."
  (interactive)
  (if-let ((error-id (flycheck-copy-errors-as-kill (point) #'flycheck-error-id)))
    (save-excursion
      (previous-line)
      (end-of-line)
      (newline-and-indent)
      (insert (template "// eslint-disable-next-line <<error-id>>")))))
#+END_SRC
***** Find file from package.json root

#+BEGIN_SRC elisp
(defun +javscript|package-root-files ()
  "Find any file relative to the upmost package.json,
useful for repos that contain multiple packages."
  (interactive)
  (let ((default-directory
          (f--traverse-upwards (f-exists? (f-expand "package.json" it)))))
    (+default/find-file-under-here)))
#+END_SRC


***** Find node_modules package

Go to a package from the node_modules directory.

#+BEGIN_SRC elisp
(defun +javascript/find-npm-package-goto (package)
  "Go to directory by package name"
  (-some->> (f-join (projectile-project-root) "node_modules")
    (-id-when #'f-exists?)
    (-f-join package)
    (find-file)))

(defun +javascript|find-npm-package ()
  "Find package in node_modules directory."
  (interactive)
  (-when-let* ((json (-some->> (f-join (projectile-project-root) "package.json")
                       (-id-when #'f-exists?)
                       (json-read-file)))
               ((&alist 'dependencies dependencies
                        'devDependencies devDependencies) json)
               (packages (->> (-concat dependencies devDependencies)
                              (-map #'car))))
    (ivy-read "Go to package directory: " packages
              :action #'+javascript/find-npm-package-goto)))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after js2-mode
 :map js2-mode-map
 :desc "Goto parent function" :n "gh" (cmd! (js2-beginning-of-defun))
 :localleader
 :desc "Goto NPM Package" "m" #'+javascript|find-npm-package
 :desc "Package Root Files" "SPC" #'+javscript|package-root-files
 (:prefix-map ("c" . "Create")
  :desc "Import File" "i" #'js-import))

(map!
 :after rjsx-mode
 :map rjsx-mode-map
 :localleader
 (:desc "Open Self-Closing Tag" :n ">" #'+rjsx|expand-insert-self-closing-tag)
 (:desc "Rename Tag" :n "," #'rjsx-rename-tag-at-point)
 (:desc "Collapse/Expand Tag" :n "<" #'+rjsx/split-join))
#+END_SRC

***** Evil Function Text Object Motion

Adds text objects for functions in javascript.
So you can press ~daf~ to delete a function.

#+BEGIN_SRC elisp
(add-hook! js-mode
  (require 'evil-text-objects-javascript)
  (evil-text-objects-javascript/install))
#+END_SRC

***** Evil Method Text Object Motion

Overwrite ~evil-text-objects-javascript~ to also accepts methods.

I mainly changed the function marking helper.

#+BEGIN_SRC diff :tangle no
- (call-interactively #'mark-defun)
+ (call-interactively #'js2-mark-defun)
#+END_SRC

#+BEGIN_SRC elisp
(after! evil-text-objects-javascript
  (evil-define-text-object
    evil-inner-javascript-function (count &optional beg end type)
    "inner text object for all javascript functions."
    (call-interactively #'js2-mark-defun)
    (narrow-to-region (region-beginning) (region-end))
    (goto-char (point-min))
    (let* ((beg (save-excursion
                  (search-forward "(")
                  (backward-char)
                  (evil-jump-item)
                  (search-forward-regexp "[({]")
                  (point)))
           (end (save-excursion
                  (goto-char beg)
                  (evil-jump-item)
                  (point))))
      (evil-range beg end type)))

  (evil-define-text-object
    evil-outer-javascript-function (count &optional beg end type)
    "Outer text object for all Javascript functions."
    (call-interactively #'js2-mark-defun)
    (narrow-to-region (region-beginning) (region-end))
    (goto-char (point-min))
    (let* ((beg (save-excursion
                  (when (looking-at "[[:space:]]")
                    (evil-forward-word-begin))
                  (point)))
           (end (save-excursion
                  (goto-char beg)
                  (search-forward "(")
                  (backward-char)
                  (evil-jump-item)
                  (search-forward-regexp "[({]")
                  (evil-jump-item)
                  (forward-char)
                  (if (save-excursion
                        (progn
                          (forward-char)
                          (when (looking-at ",") (point))))
                    (point)))))
      (evil-range beg end type))))
#+END_SRC
*** Nix :NIXOS:NIX:
**** Packages
***** Nixpkgs Fmt :AUTOFIX:
****** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! nixpkgs-fmt)
#+END_SRC

****** Config

#+begin_src elisp
(use-package nixpkgs-fmt
  :after nix-mode
  :config
  (setq nixpkgs-fmt-on-save-mode t)
  :init
  (add-hook! nix-mode #'nixpkgs-fmt-on-save-mode))
#+end_src
**** Functions
***** Edit indirect

Edit nix script regions in an indirect buffer just like ~org-edit-special~.

#+BEGIN_SRC elisp
(defun my-nixos/edit-indirect ()
  "Edit script in an indirect buffer."
  (interactive)
  (and-let* ((beg (save-excursion
                    (search-backward "''\n" nil t)
                    (forward-char 3)
                    (point)))
             (end (save-excursion
                    (re-search-forward "''" nil t)
                    (previous-line 1)
                    (goto-char (point-at-eol))
                    (point))))
    (+indirect-indent|edit beg end #'sh-mode)))

(map! :map nix-mode-map "C-c '" 'my-nixos/edit-indirect)

(set-popup-rule! "^\\*edit-indirect" :ignore t)
#+END_SRC

*** Haskell :HASKELL:
***** Functions
****** Autofix with [[https://hackage.haskell.org/package/brittany][brittany]] :AUTOFIX:

#+begin_src elisp
(defun my-haskell|autofix ()
  "Function formats haskell buffer with brittany on save."
  (interactive)
  (when (eq major-mode 'haskell-mode)
    (shell-command-to-string (format "brittany --config-file .brittany.yaml --write-mode inplace %s" buffer-file-name))
    (revert-buffer :ignore-auto :noconfirm)
    (haskell-mode-stylish-buffer)
    (save-buffer)))
#+end_src
*** Markdown :MARKDOWN:
**** Config

#+BEGIN_SRC elisp
(use-package! markdown-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.mdx\\'" . markdown-mode))
  (setq markdown-fontify-code-blocks-natively t)
  :config
  (add-hook! markdown-mode
    (hl-line-mode -1)
    (visual-line-mode)
    (visual-fill-column-mode)
    (outline-minor-mode)
    (setq markdown-hide-urls t)
    (setq visual-fill-column-width 90
          display-line-numbers nil)
    (setq line-spacing 2
          fill-column 80)))
#+END_SRC
**** Bindings

#+begin_src elisp
(map! (:map markdown-mode-map
       :n "<"    #'markdown-promote
       :n ">"    #'markdown-demote))
#+end_src
*** Nim :NIM:
**** Packages
***** [[https://github.com/SerialDev/inim-mode][inim-mode]]

Nim Repl Support.
Needs inim installed from nimble.

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! inim :recipe (:host github :repo "SerialDev/inim-mode"))
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! package)
#+END_SRC
**** Functions
***** Import Nim Package

Finds packages either from nims std lib or your nim packages.

- Requires evil for inserting
- Requires ~$NIM_UNWRAPPED_DIR~ to be set to nims source repository on your disk
- Searches for nimble dir in either ~$NIMBLE_DIR~ or your users home directory

To set a nimble directory via nix shell add this snippet:

#+begin_src nix :tangle no
{ pkgs, packages, nimpkgs, buildInputs }:

pkgs.mkShell {
  shellHook = ''
    export NIMBLE_DIR="$PWD/.nimble"
  '';
};
#+end_src

#+begin_src elisp
(defun my-nim|import/add-std-import-statement (import)
  "Insert stdlib import below last stdin statement."
  (goto-char (point-max))
  (cond ((search-backward-regexp "^import std/.+$" 0 t)
         (evil-insert-newline-below))
        ((goto-char (point-min)) (evil-insert-newline-above)))
  (insert (t! "import std/<<import>>")))

(defun my-nim|import/add-lib-import-statement (import)
  "Insert package import below all import statements."
  (goto-char (point-max))
  (cond ((search-backward-regexp "^import .+$" 0 t)
         (evil-insert-newline-below))
        ((goto-char (point-min)) (evil-insert-newline-above)))
  (insert (t! "import <<import>>")))

(defun my-nim|import ()
  "Add import from nims stdlib or your nimble packages."
  (interactive)
  (let* ((nim-src-dir (-some->> (getenv "NIM_UNWRAPPED_DIR")
                        (-f-join "nim/lib/pure")
                        (-id-when #'f-exists?)))
         (libs (->> (f-entries nim-src-dir (lambda (x) (f-ext? x "nim")) t)
                    (--map (->> (f-relative it nim-src-dir)
                                (f-no-ext)
                                ((lambda (x) (cons x 'libs)))))))
         (nim-deps-dir (-some->> (or (getenv "NIMBLE_DIR")
                                     (f-expand "~/.nimble"))
                         (-f-join "pkgs")
                         (-id-when #'f-exists?)))
         (deps (->> (f-directories nim-deps-dir)
                    (--map (-some->>
                               (f-files it (lambda (x) (f-ext? x "nim")))
                             (car)
                             (f-base)
                             (s-replace-regexp "-[0-9\\.]+$" "")
                             ((lambda (x) (cons x 'deps))))))))
    (ivy-read "Import: " (-concat libs deps)
              :action (lambda (import)
                        (save-excursion
                          (pcase import
                            (`(,x . deps) (my-nim|import/add-lib-import-statement x))
                            (`(,x . libs) (my-nim|import/add-std-import-statement x))))))))
#+end_src
***** Flycheck for ~v.1.6.0~

Nim has different output for v1.6.0 for linting, so this broke flycheck

The error output for 1.6.0 is

#+BEGIN_QUOTE
FILENAME:3:8 Hint: duplicate import of 'osproc'; previous import here: FILENAME:1:8 [DuplicateModuleImport]
FILENAME:73:14 Error: expression 'getCacheDir()' is of type 'string' and has to be used (or discarded)
#+END_QUOTE

#+begin_src elisp
(after! nim-mode
  (flycheck-define-checker nim-1-6-0
    "A syntax checker for the nim programming language.
v1.6.0 has a different output style than previously

See http://nim-lang.org"
    :command ("nim" "check"
              (option-flag "--experimental" flycheck-nim-experimental)
              (option-flag "--threads:on" flycheck-nim-threads)
              (option "--hints:" flycheck-nim-hints concat)
              (option "--warnings:" flycheck-nim-warnings concat)
              (eval (--map (format "--hint[%s]:%s" (car it) (cadr it))
                           flycheck-nim-specific-hints))
              (eval (--map (format "--warning[%s]:%s" (car it) (cadr it))
                           flycheck-nim-specific-warnings))
              (eval flycheck-nim-args)
              ;; Must use source-inplace so relative imports and
              ;; qualified references to local variables resolve correctly
              source-inplace)
    :error-patterns
    ((error line-start (file-name) ":" line ":"
            column " Error:"
            (message (one-or-more not-newline)
                     (optional
                      (and "\nbut expected one of:"
                           (minimal-match (one-or-more anything)) "\n\n"))))
     (warning line-start (file-name) ":" line ":"
              column " " (or "Hint:" "Warning:") (message) line-end))
    :error-filter
    (lambda (errors)
      (flycheck-sanitize-errors (flycheck-increment-error-columns errors)))
    :modes (nim-mode nimrod-mode)
    :predicate (lambda () (not org-src-mode)))

  (add-to-list 'flycheck-checkers 'nim-1-6-0))
#+end_src
***** TODO Nimpretty

#+begin_src elisp
(defcustom nimpretty-command "nimpretty"
  "The 'nimpretty' command."
  :type 'string
  :group 'nim)

(defcustom nimpretty-show-errors 'buffer
  "Where to display nimpretty error output.
It can either be displayed in its own buffer, in the echo area, or not at all.

Please note that Emacs outputs to the echo area when writing
files and will overwrite nimpretty's echo output if used from inside
a `before-save-hook'."
  :type '(choice
          (const :tag "Own buffer" buffer)
          (const :tag "Echo area" echo)
          (const :tag "None" nil))
  :group 'nim)

(defcustom nimpretty-args nil
  "Additional arguments to pass to nimpretty."
  :type '(repeat string)
  :group 'nim)

(defun nim--goto-line (line)
  (goto-char (point-min))
  (forward-line (1- line)))

(defalias 'nim--make-nearby-temp-file
  (if (fboundp 'make-nearby-temp-file) #'make-nearby-temp-file
    (lambda (prefix &optional dir-flag suffix)
      (let ((temporary-file-directory (nim--temporary-file-directory)))
        (make-temp-file prefix dir-flag suffix)))))

(defalias 'nim--temporary-file-directory
  (if (fboundp 'temporary-file-directory) #'temporary-file-directory
    (lambda ()
      (let ((remote (file-remote-p default-directory)))
        (if remote
            ;; Assume that /tmp is a temporary directory on the remote host.
            ;; This won’t work on Windows.
            (concat remote "/tmp")
          temporary-file-directory)))))

(defalias 'nim--file-local-name
  (if (fboundp 'file-local-name) #'file-local-name
    (lambda (file) (or (file-remote-p file 'localname) file))))

(defun nimpretty--kill-error-buffer (errbuf)
  (let ((win (get-buffer-window errbuf)))
    (if win
        (quit-window t win)
      (kill-buffer errbuf))))

(defun nimpretty--process-errors (filename tmpfile errbuf)
  (with-current-buffer errbuf
    (if (eq nimpretty-show-errors 'echo)
        (progn
          (message "%s" (buffer-string))
          (nimpretty--kill-error-buffer errbuf))
      ;; Convert the nimpretty stderr to something understood by the compilation mode.
      (goto-char (point-min))
      (insert "nimpretty errors:\n")
      (let ((truefile tmpfile))
        (while (search-forward-regexp
                (concat "^\\(" (regexp-quote (nim--file-local-name truefile))
                        "\\):")
                nil t)
          (replace-match (file-name-nondirectory filename) t t nil 1)))
      (compilation-mode)
      (display-buffer errbuf))))

(defun nim--delete-whole-line (&optional arg)
  "Delete the current line without putting it in the `kill-ring'.
Derived from function `kill-whole-line'.  ARG is defined as for that
function."
  (setq arg (or arg 1))
  (if (and (> arg 0)
           (eobp)
           (save-excursion (forward-visible-line 0) (eobp)))
      (signal 'end-of-buffer nil))
  (if (and (< arg 0)
           (bobp)
           (save-excursion (end-of-visible-line) (bobp)))
      (signal 'beginning-of-buffer nil))
  (cond ((zerop arg)
         (delete-region (progn (forward-visible-line 0) (point))
                        (progn (end-of-visible-line) (point))))
        ((< arg 0)
         (delete-region (progn (end-of-visible-line) (point))
                        (progn (forward-visible-line (1+ arg))
                               (unless (bobp)
                                 (backward-char))
                               (point))))
        (t
         (delete-region (progn (forward-visible-line 0) (point))
                        (progn (forward-visible-line arg) (point))))))

(defun nim--apply-rcs-patch (patch-buffer)
  "Apply an RCS-formatted diff from PATCH-BUFFER to the current buffer."
  (let ((target-buffer (current-buffer))
        ;; Relative offset between buffer line numbers and line numbers
        ;; in patch.
        ;;
        ;; Line numbers in the patch are based on the source file, so
        ;; we have to keep an offset when making changes to the
        ;; buffer.
        ;;
        ;; Appending lines decrements the offset (possibly making it
        ;; negative), deleting lines increments it. This order
        ;; simplifies the forward-line invocations.
        (line-offset 0)
        (column (current-column)))
    (save-excursion
      (with-current-buffer patch-buffer
        (goto-char (point-min))
        (while (not (eobp))
          (unless (looking-at "^\\([ad]\\)\\([0-9]+\\) \\([0-9]+\\)")
            (error "Invalid rcs patch or internal error in nim--apply-rcs-patch"))
          (forward-line)
          (let ((action (match-string 1))
                (from (string-to-number (match-string 2)))
                (len  (string-to-number (match-string 3))))
            (cond
             ((equal action "a")
              (let ((start (point)))
                (forward-line len)
                (let ((text (buffer-substring start (point))))
                  (with-current-buffer target-buffer
                    (cl-decf line-offset len)
                    (goto-char (point-min))
                    (forward-line (- from len line-offset))
                    (insert text)))))
             ((equal action "d")
              (with-current-buffer target-buffer
                (nim--goto-line (- from line-offset))
                (cl-incf line-offset len)
                (nim--delete-whole-line len)))
             (t
              (error "Invalid rcs patch or internal error in nim--apply-rcs-patch")))))))
    (move-to-column column)))

(defun nimpretty ()
  "Format the current buffer according to the formatting tool.

The tool used can be set via ‘nimpretty-command’ (default: nimpretty) and additional
arguments can be set as a list via ‘nimpretty-args’."
  (interactive)
  (let ((tmpfile (nim--make-nearby-temp-file "nimpretty" nil ".nim"))
        (patchbuf (get-buffer-create "*Nimpretty patch*"))
        (errbuf (if nimpretty-show-errors (get-buffer-create "*Nimpretty Errors*")))
        (coding-system-for-read 'utf-8)
        (coding-system-for-write 'utf-8)
        our-nimpretty-args)

    (unwind-protect
        (save-restriction
          (widen)
          (if errbuf
              (with-current-buffer errbuf
                (setq buffer-read-only nil)
                (erase-buffer)))
          (with-current-buffer patchbuf
            (erase-buffer))

          (write-region nil nil tmpfile)

          (setq our-nimpretty-args
                (append our-nimpretty-args nimpretty-args
                        (list (file-local-name tmpfile))))
          (message "Calling nimpretty: %s %s" nimpretty-command our-nimpretty-args)
          (if (zerop (apply #'process-file nimpretty-command nil errbuf nil our-nimpretty-args))
              (progn
                ;; There is no remote variant of ‘call-process-region’, but we
                ;; can invoke diff locally, and the results should be the same.
                (if (zerop (let ((local-copy (file-local-copy tmpfile)))
                             (unwind-protect
                                 (call-process-region
                                  (point-min) (point-max) "diff" nil patchbuf
                                  nil "-n" "-" (or local-copy tmpfile))
                               (when local-copy (delete-file local-copy)))))
                    (message "Buffer is already nimprettied")
                  (nim--apply-rcs-patch patchbuf)
                  (message "Applied nimpretty"))
                (if errbuf (nimpretty--kill-error-buffer errbuf)))
            (message "Could not apply nimpretty")
            (if errbuf (nimpretty--process-errors (buffer-file-name) tmpfile errbuf))))

      (kill-buffer patchbuf)
      (delete-file tmpfile))))

(use-package! nim-mode
  :config
  (map!
    :localleader
    :map nim-mode-map
    "p" #'nimpretty))
#+end_src
**** Config

#+begin_src elisp
(use-package nim-mode
  :ensure t
  :hook
  (nim-mode . lsp)
  :config
  (setq nim-compile-default-command '("c"
                                      "-r"
                                      "--verbosity:0"
                                      "--hint[Processing]:off"
                                      "--warning[UnusedImport]:off"
                                      "--hint[XDeclaredButNotUsed]:off"
                                      "--hint[DuplicateModuleImport]:off"
                                      "--excessiveStackTrace:on"
                                      "--outdir:/tmp/nimbins")))
#+end_src

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after nim-mode
 :map nim-mode-map
 :localleader
 (:prefix-map ("c" . "Create")
  :desc "Import File" "i" #'my-nim|import))
#+END_SRC
*** ReasonMl / ReScript :REASON_ML:
**** Packages
***** [[https://github.com/ocaml/merlin][merlin]]
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! merlin)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package merlin
  :after (reason-mode)
  :init
  ;; Disable merlin's own error checking
  ;; We'll use flycheck-ocaml for that
  (add-hook! merlin-mode (flycheck-add-mode 'ocaml-merlin 'reason-mode))
  (setq
   merlin-error-after-save nil
   merlin-command (executable-find "ocamlmerlin"))
  :config
  (add-to-list 'company-backends 'merlin-company-backend))
#+END_SRC

***** [[https://github.com/flycheck/flycheck-ocaml][flycheck-ocaml]]
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! flycheck-ocaml)
#+END_SRC

****** Config

******* Enable for reason-mode

#+begin_src elisp
(use-package flycheck-ocaml
  :after (flycheck merlin)
  :commands
  (flycheck-ocaml-setup)
  :config
  (with-eval-after-load 'merlin
    (flycheck-ocaml-setup))
  (with-eval-after-load 'reason-mode
    (flycheck-ocaml-setup)))
#+end_src

***** [[https://github.com/reasonml-editor/reason-mode][reason-mode]]
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! reason-mode)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! reason-mode
  :mode "\\.rei?$"
  :commands (reason-mode)

  :init
  (set-lookup-handlers! 'reason-mode
    :definition #'merlin-locate
    :references #'merlin-occurrences
    :documentation #'merlin-document)

  ;; Don't use refmt indentation, it can be horribly slow
  ;; and files get autofixed on save anyway
  (setq-hook! reason-mode indent-region-function #'indent-region-line-by-line)
  (setq-hook! reason-mode indent-line-function #'indent-relative)

  ;; [|array|]
  (set-electric! 'some-mode :chars '(?|))

  (set-company-backend! 'reason-mode 'merlin-company-backend)

  (let* ((refmt-bin (executable-find "refmt"))
         (merlin-bin (executable-find "ocamlmerlin"))
         (merlin-base-dir (when merlin-bin
                            (replace-regexp-in-string "bin/ocamlmerlin$" "" merlin-bin))))
    (when merlin-bin
      (add-to-list 'load-path (concat merlin-base-dir "share/emacs/site-lisp/"))
      (setq merlin-command merlin-bin))
    (when refmt-bin
      (setq refmt-command refmt-bin))
    (add-hook! reason-mode
      (merlin-mode)
      (merlin-use-merlin-imenu)
      (add-hook 'before-save-hook #'refmt-before-save nil t)))

  :config
  (add-hook
   'reason-mode-hook
   (lambda ()
     (merlin-mode)
     (setq utop-command "opam config exec -- rtop -emacs")
     (add-hook 'before-save-hook 'refmt-before-save)
     (add-hook 'reason-mode-hook 'merlin-mode)
     (add-hook 'reason-mode-hook 'utop-minor-mode)
     (add-hook 'reason-mode-hook 'flycheck-mode)
     :delight "re")))
#+END_SRC

**** Functions

***** Convert between ReasonML and Ocaml in SRC blocks

#+begin_src elisp
(defun my-org-babel|org-src-block-refmt-reason-ocaml-toggle ()
  "Convert an Org SRC block from ocaml to reason and vice versa."
  (interactive)
  (save-excursion
    (let* ((old-block (org-element-at-point))
           (old-lang (org-element-property :language old-block))
           (new-lang (if (string= old-lang "ocaml") "reason" "ocaml"))
           (formatter (if (string= old-lang "ocaml") 'refmt-region-ocaml-to-reason 'refmt-region-reason-to-ocaml)))
      (org-edit-special)
      (funcall formatter (point-min) (point-max))
      (org-edit-src-exit)
      (let* ((new-block (org-element-at-point))
             (new-block-parsed (org-element-interpret-data (org-element-put-property (org-element-at-point) :language new-lang)))
             (from (org-element-property :begin new-block))
             (to (org-element-property :end new-block)))
        (delete-region from to)))))
#+end_src

***** Rtop

#+begin_src elisp
(defun my-reason|rtop ()
  "Launch reason version of utop."
  (interactive)
  (cl-letf ((utop-command "rtop -emacs"))
    (utop)))
#+end_src
*** Lisp

**** Sort sexp

#+begin_src elisp
(defun my-lisp|sort-sexp ()
  "Sort sexps between point and end of current sexp.
  With multilines sexp, comments and blank lines are considered part of the following
  sexp. Comments at the end of a line (after some other content)
  are considered part of the preceding sexp."
  (interactive)
  (save-excursion
    (save-restriction
      (up-list)
      (backward-sexp)
      (let* ((map? (looking-at "{"))
             (start (1+ (point)))
             (end (progn (forward-sexp)
                         (1- (point))))
             (multiline? (< (line-number-at-pos start)
                            (line-number-at-pos end)))
             ;; Should really check every line, but the only the first with a sexp should be enough
             (one-sexp-per-line? (save-excursion
                                   (goto-char start)
                                   ;; Skip start comment, if any
                                   (let ((sexp2-end (progn (clojure-forward-logical-sexp 2) (point)))
                                         (sexp2-start (progn (clojure-forward-logical-sexp -2) (point))))
                                      (< (line-number-at-pos sexp2-start)
                                       (line-number-at-pos sexp2-end))))))
        (narrow-to-region start end)
        ;; Delete last empty line, if any
        (save-excursion
         (beginning-of-line)
         (when (looking-at "[[:blank:]]*$")
          (backward-char)
          (delete-region (point) (point-max))))

        (goto-char start)
        (sort-subr nil
               (lambda ()
                     (if (and multiline? one-sexp-per-line?)
                      (progn (message "forward line")
                           (forward-line))
                      (search-forward-regexp "[^:blank:]" nil :no-error)))
               ;; Move to end of current top-level thing.
               (lambda ()
                     (condition-case nil
                       (while t (up-list))
                       (scan-error nil))
                   ;; We could be inside a symbol instead of a sexp.
                     (unless (looking-at "\\s-\\|$")
                      (clojure-forward-logical-sexp))
                     (when (and multiline? one-sexp-per-line?)
                     ;; move past comments at the end of the line.
                      (search-forward-regexp "$")))

                 ;; Start of record
               (lambda ()
                     (when multiline?
                      (skip-chars-forward "\r\n[:blank:]")
                      (comment-forward)
                      (skip-chars-forward "[:blank:]\n\r[("))
                     (condition-case nil
                       (progn (clojure-forward-logical-sexp)
                              (forward-sexp -1))
                       (scan-error nil))

                     nil)

                 ;; End of record
               (lambda ()
                     (clojure-forward-logical-sexp (if map? 2 1)))

               (lambda (a b)
                     (let* ((s1 (buffer-substring (car a) (cdr a)))
                            (s2 (buffer-substring (car b) (cdr b)))

                            ;; Ignore namespaces for keywords
                            (s1* (replace-regexp-in-string
                                  "^::" ""
                                  (if (string-match "^::.*/\\(.*\\)" s1)
                                      (match-string 1 s1)
                                   s1)))
                            (s2* (replace-regexp-in-string
                                  "^::" ""
                                  (if (string-match "^::.*/\\(.*\\)" s2)
                                      (match-string 1 s2)
                                   s2))))
                       (string< s1* s2*))))
        ;; Delete starting whitespaces
        (goto-char (point-min))
        (delete-region (point) (progn (skip-chars-forward "[:blank:]") (point)))
        ;; Go to the end and insert newline if we end with a comment.
        (goto-char (point-max))
        (when (nth 4 (parse-partial-sexp (point-min) (point)))
         (insert "\n"))
        ;; Clean superfluous spaces
        (when (not multiline?)
         (goto-char (point-min))
         (while (re-search-forward "\\s-+" nil t)
          (replace-match " ")))
        ;; Fill paragraph
        (when (and (not map?) (not one-sexp-per-line?))
         (fill-region-as-paragraph start end))))
    ;; Indent
    (let ((end (progn (up-list) (point)))
          (start (progn (progn (clojure-forward-logical-sexp -1)) (point))))
      (indent-region start end))))
#+end_src

*** Clojure / Clojurescript
**** Packages
***** clj-kondo

#+begin_src elisp 
(use-package! flycheck-clj-kondo
  :when t
  :after flycheck)
#+end_src

***** Cider
****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! cider :pin "f39e0b52014913f5acc1dc28ad94c68385c0834e")
#+END_SRC

****** Config

#+begin_src elisp
(defun my-cider/init-faces ()
  (set-face-attribute 'cider-error-overlay-face nil
                      :foreground (face-attribute 'custom-state :foreground)
                      :background (face-attribute 'custom-state :background))
  (set-face-attribute 'cider-error-highlight-face nil
                      :underline `(:color ,(face-attribute 'shadow :foreground)
                                   :style wave)))

(defun my-cider/clear-errors (&rest _)
  (when cider-mode
    (cider-clear-compilation-highlights t)))

(use-package! cider
  :config
  (setq cider-repl-pop-to-buffer-on-connect nil)
  ;; Show errors inline
  (setq cider-use-overlays t)
  (setq cider-use-fringe-indicators nil)
  (setq cider-show-error-buffer nil)
  (setq cider-auto-select-error-buffer nil)
  (setq cider-words-of-inspiration nil)
  (add-hook 'doom-load-theme-hook #'my-cider/init-faces)
  (advice-add 'doom/escape :before #'my-cider/clear-errors))
#+end_src

****** Hacks
******* Fix cider for 28.1

[[https://github.com/clojure-emacs/cider/issues/3029][Problem starting cider in clj/cljs `(cl-no-applicable-method map-into ((right-margin 80)) hash-table)` · Issue #3029 · clojure-emacs/cider]]

Fixes cider from breaking with newest emacs, for this isseu

#+BEGIN_QUOTE
condition-case: Error in a Doom startup hook: nrepl-connected-hook, cider--connected-handler, (cl-no-applicable-method map-into (("nrepl.middleware.print/stream?" "1")) (hash-table :test equal))
#+END_QUOTE

#+begin_src elisp :tangle "packages.el" :comments link
(package! map :pin "bb50dba")
#+end_src
****** Functions
******* Fix ~cider-connect~ checking ~.authinfo.gpp~ -> password

#+begin_src elisp
(defun my-cider/connect (connect-fn &optional params)
  (require 'noflet)
  (let* ((buffer (noflet ((cider--ssh-hosts () nil))
                   (apply connect-fn params))))
    (persp-add-buffer buffer)))

(defun my-cider|connect-clj (&optional params)
  "Custom cider connect function that doesn't trigger authinfo.gpg password query."
  (interactive "P")
  (my-cider/connect #'cider-connect-clj params))

(defun my-cider|connect-cljs (&optional params)
  "custom cider-connect-cljs function that doesn't trigger authinfo.gpg password query."
  (interactive "P")
  (my-cider/connect #'cider-connect-cljs params))
#+end_src
******* Print comment fix

- Make cider eval work with ~evil-mode~
- Fix result insertion to insert after the sexp not inside
- Pprint maps

#+begin_src elisp
(defun my-cider/eval-jump-opening-brace ()
  (when (eq (string-to-char "(") ;; Workaround for parinfer inferring ?( as opening brace
            (char-after))
    (evil-jump-item)))

(defun my-cider/eval-print-handler (&optional buffer)
  "Make a handler for evaluating and printing result in BUFFER."
  ;; NOTE: cider-eval-register behavior is not implemented here for performance reasons.
  ;; See https://github.com/clojure-emacs/cider/pull/3162
  (nrepl-make-response-handler (or buffer (current-buffer))
                               (lambda (buffer value)
                                 (with-current-buffer buffer
                                   (forward-char 1)
                                   (insert
                                    " "
                                    (if (derived-mode-p 'cider-clojure-interaction-mode)
                                        (format "\n%s\n" value)
                                      value))
                                   (backward-char 1)
                                   (ignore-errors
                                     (when (string= (string (char-after (point))) "}")
                                       (evil-jump-item)
                                       (cider-format-edn-last-sexp)))))
                               (lambda (_buffer out)
                                 (cider-emit-interactive-eval-output out))
                               (lambda (_buffer err)
                                 (cider-emit-interactive-eval-err-output err))
                               ()))

(defun my-cider|cider-eval-last-sexp (&optional output-to-current-buffer)
  (interactive "P")
  (let ((previous-evil-state evil-state))
    (save-excursion
      (my-cider/eval-jump-opening-brace)
      (when (eq previous-evil-state 'normal)
        (evil-insert-state)
        (forward-char 1))
      (cider-interactive-eval nil
                              (when output-to-current-buffer (my-cider/eval-print-handler))
                              (cider-last-sexp 'bounds)
                              (cider--nrepl-pr-request-map))
      ;; (cider-eval-last-sexp output-to-current-buffer)
      ;; Dont restore state when doing eval when inserting result
      ;; The `cider-eval-print-handler' function is async,
      (when (eq previous-evil-state 'normal)
        (evil-normal-state)))))

(defun my-cider|pprint-eval-last-sexp-to-comment (&optional insert-before)
  "Pointer position fix for evil normal state."
  (interactive "P")
  (my-cider/eval-jump-opening-brace)
  (when (eq evil-state 'normal)
    (forward-char 1))
  (call-interactively #'cider-pprint-eval-last-sexp-to-comment))
#+end_src

******* Cleanup dead cider buffers

#+begin_src elisp
(defun my-cider|cleanup-cider-buffers ()
  (let* ((buffers (->> (buffer-list)
                       (-filter (lambda (b) (->> (buffer-name b)
                                                 (substring-no-properties)
                                                 (s-starts-with? "*cider-repl")))))))
    (-each buffers #'kill-buffer)))
#+end_src


****** Bindings

#+begin_src elisp
(defun my-cider|eval-pp (&rest args)
  (interactive)
  (let* ((buf (current-buffer)))
    (evil-append 0)
    (cider-pprint-eval-last-sexp)
    (with-current-buffer buf
      (backward-char 2)
      (evil-normal-state))))

(use-package! clojure-mode
  :config
  (map! :map (clojurescript-mode-map clojure-mode-map)
        :desc "Eval" :n "RET" #'my-cider|cider-eval-last-sexp
        :desc "Eval" :n "C-c C-p" #'my-cider|eval-pp
        :desc "Eval" :n "DEL" #'my-eval-function-and-last-marker)

  (map! (:localleader
         (:map (clojure-mode-map clojurescript-mode-map clojurec-mode-map)
              "c"  #'my-cider|connect-clj
              "C"  #'my-cider|connect-cljs
              (:prefix ("m" . "modify")
               :desc "Toggle Comment / Ignore" "t" #'clojure-toggle-ignore
               :desc "Toggle Comment / Ignore" "T" #'clojure-toggle-ignore-surrounding-form
               :desc "Thread first" "f" #'lsp-clojure-thread-first)
              (:prefix ("e" . "eval")
               :desc "Eval last sexp to comment" "c" #'my-cider|pprint-eval-last-sexp-to-comment)
              (:prefix ("i" . "inspect/insert")
                       "e" #'cider-enlighten-mode
                       "i" #'cider-inspect
                       "n" #'clojure-insert-ns-form
                       "r" #'cider-inspect-last-result)
              :localleader
              "x" #'cider-scratch)
         (:map (clojurescript-mode-map)
              (:prefix ("i" . "inspect")
                       "i" #'my-cider|inspect-expr)))))
#+end_src

***** [[https://github.com/noctuid/lispyville][lispyville]]

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! lispyville :recipe (:host github :repo "noctuid/lispyville"))
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! lispyville
  :hook
  ((emacs-lisp-mode . lispyville-mode)
   (lisp-mode . lispyville-mode)
   (clojure-mode . lispyville-mode)
   (clojurescript-mode . lispyville-mode)
   (cider-repl-mode . lispyville-mode))
  :init
  (setq lispyville-key-theme
        '(
          ;; operators
          ;; text-objects
          wrap
          raise
          c-w
          ;; (prettify insert)

          commentary

          slurp/barf-cp
          additional
          additional-insert
          additional-motions
          (additional-wrap normal visual insert)))
  :config
  (lispyville-set-key-theme)
  ;; Override paragraph jumping from additional key theme
  (map! :map lispyville-mode-map
        :nm "{" #'evil-backward-paragraph
        :nm "}" #'evil-forward-paragraph
        :nm "M-h" #'lispyville-backward-sexp-begin
        :nm "M-l" #'lispyville-forward-sexp-begin
        :nm "M-H" #'lispyville-beginning-of-defun
        :nm "M-L" #'lispyville-end-of-defun
        :nm "M-J" #'my-lispyville|drag-2-forward
        :nm "M-K" #'my-lispyville|drag-2-backward))
#+END_SRC

******* Jumps

Define jump points for lispyville functions

#+begin_src elisp
(advice-add #'lispyville-beginning-of-defun :around #'doom-set-jump-a)
(advice-add #'lispyville-end-of-defun :around #'doom-set-jump-a)
(advice-add #'lispyville-backward-up-list :around #'doom-set-jump-a)
(advice-add #'lispyville-up-list :around #'doom-set-jump-a)
(advice-add #'lispyville-insert-at-beginning-of-list :around #'doom-set-jump-a)
(advice-add #'lispyville-insert-at-end-of-list :around #'doom-set-jump-a)
(advice-add #'lispyville-open-below-list :around #'doom-set-jump-a)
(advice-add #'lispyville-open-above-list :around #'doom-set-jump-a)
#+end_src
****** Functions

******* Drag two items forward/backward

#+begin_src elisp
(defun my-lispyville|drag-2-backward ()
  "Drags two items backward, useful for maps to drag the key and the value around."
  (interactive)
  (lispyville--drag #'lispy-move-up 2)
  (lispyville-forward-sexp-alt2 3)
  (lispyville--drag #'lispy-move-up 2)
  (lispyville-backward-sexp))

(defun my-lispyville|drag-2-forward ()
  "Drags two items backward, useful for maps to drag the key and the value around."
  (interactive)
  (lispyville--drag #'lispy-move-down 2)
  (lispyville-backward-sexp)
  (lispyville--drag #'lispy-move-down 2)
  (lispyville-backward-sexp))
#+end_src
***** INACTIVE [[https://github.com/ericdallo/jet.el][ericdallo/jet.el: Emacs integration for the jet Clojure tool]]

****** Package

#+BEGIN_SRC emacs-lisp :tangle no :comments link
(package! jet :recipe (:host github :repo "ericdallo/jet.el"))
#+END_SRC

****** Config

#+BEGIN_SRC elisp :tangle no
(use-package! jet)
#+END_SRC

**** Functions
***** Keywords to map

#+begin_src elisp
(defun my-clojure|region-keywords-to-map ()
  "Convert keywords in region to a clojure map."
  (interactive)
  (let* ((beg (region-beginning))
         (end (region-end))
         (input (buffer-substring-no-properties beg end))
         (output (->> input
                      (s-replace-all '(("(" . "")
                                       (")" . "")
                                       ("[" . "")
                                       ("]" . "")))
                      (s-split "\s")
                      (-sort #'string<)
                      (-map (fn! (concat ":" % " " %)))
                      (s-join (if (> (length input) 20) "\n" " "))
                      ((lambda (x) (s-wrap x "{" "}"))))))
    (save-excursion
      (my-parinfer/save-excursion
       "paren"
       (progn
         (delete-region beg end)
         (insert output))))))
#+end_src

***** Key formatting sorting

#+begin_src elisp
(defun my-clojure::format|sort-keys ()
  "Convert set of keys to multiline."
  (interactive)
  (-let* (((beg end) (evil-select-inner-object 'lispyville-list nil nil nil))
          (text (buffer-substring-no-properties (+ beg 1) (- end 1)))
          (new-text (->> text
                         (s-split " ")
                         (-sort #'string<)
                         (s-join " "))))
    (save-excursion
      (delete-region beg end)
      (goto-char beg)
      (insert (concat "[" new-text "]")))))

(defun my-clojure::format|keys-to-multi-line ()
  "Convert set of keys to multiline."
  (interactive)
  (-let* (((beg end) (evil-select-inner-object 'lispyville-list nil nil nil))
          (text (buffer-substring-no-properties (+ beg 1) (- end 1)))
          (new-text (->> text
                         (s-split " ")
                         (-sort #'string<)
                         (s-join "\n"))))
    (save-excursion
      (my-parinfer/save-excursion
       "paren"
       (progn
         (delete-region beg end)
         (goto-char beg)
         (insert (concat "[" new-text "]"))
         (indent-region (- 1 beg) (+ 1 end)))))))
#+end_src
***** Spy

#+begin_src elisp
(defun my-clojure/spy-buffer-fns ()
  "Get buffer functions"
  (-map
   (lambda (x) (->> x
                    (cdr)
                    (car)
                    (substring-no-properties)
                    ((lambda (x) (s-split-up-to ": " x 1)))
                    (cdr)
                    (car)))
   (counsel--imenu-candidates)))

(defun my-clojure|spy ()
  "Wrap element with spy function and insert function into file if not already available in namespace."
  (interactive)
  (save-excursion
    (let* ((fns (my-clojure/fns))
           (spy? (-contains? fns "spy")))
     (lispyville-wrap-round t)
     (insert "spy ")
     (when (not spy?)
       (lispyville-backward-function-begin)
       (insert "(defn spy" "\n"
               "  ([val] (js/console.log val) val)" "\n"
               "  ([val desc] (js/console.log desc val) val))" "\n" "\n")))))
#+end_src
***** Inspect cleaned up expression

#+begin_src elisp
(defun my-cider|inspect-expr (expr ns)
  "Evaluate EXPR in NS and inspect its value.
Interactively, EXPR is read from the minibuffer, and NS the
current buffer's namespace."
  (interactive (list (cider-read-from-minibuffer "Inspect expression: " (cider-sexp-at-point))
                     (cider-current-ns)))
  (setq cider-inspector--current-repl (cider-current-repl))
  (when-let* ((value (cider-sync-request:inspect-expr
                      expr ns
                      cider-inspector-page-size
                      cider-inspector-max-atom-length
                      cider-inspector-max-coll-size)))
    (cider-inspector--render-value value)
    (with-current-buffer cider-inspector-buffer
      (let ((content (->> (buffer-substring-no-properties (point-min) (point-max))
                          (s-replace "\nInspector error for: " "")
                          (s-replace-regexp ",$" ""))))
        (read-only-mode -1)
        (erase-buffer)
        (insert content)
        (zprint-format-buffer)
        (clojurescript-mode)
        (goto-char (point-min))))))
#+end_src
***** Thread logging

Inserts ~doto println~ depending on thread first/last.
Used in [[file:snippets/clojure-mode/thread_spy::--][thread_spy snippet]]

#+begin_src elisp
(defun my-clojure/thread-spy ()
  (let ((log-fn (if (derived-mode-p 'clojurescript-mode) "js/console.log" "println"))
        (p (point)))
    (save-excursion
      (search-backward "->" nil t)
      (let* ((thread-first? (string= (symbol-at-point) "->")))
        (if thread-first?
            (format "(doto %s)" log-fn)
          (format "(#(doto %% %s))" log-fn))))))
#+end_src
***** Update NS

#+begin_src elisp
(defun my-clojure|update-ns-dwim ()
  "Updates the ns no-matter where your cursor is, when non is existing insert a new one."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (if (re-search-forward "(ns " nil t)
        (progn
          (sp-kill-sexp)
          (insert (funcall clojure-expected-ns-function)))
      (clojure-insert-ns-form))))
#+end_src

***** Get prev atom

Automatically get the previous atom name in the current file as the base
Used for [[file:snippets/clojure-mode/reset][reset! snippet]]

#+begin_src elisp
(defun my-clojure/get-prev-atom-variable-name ()
  (save-excursion
   (-some-> (when (re-search-backward "(defonce \\(.+?\\) (atom" nil t)
              (match-string 1))
     (substring-no-properties))))
#+end_src
***** Newline :HACK:

#+begin_src elisp
(defun my-clojure|newline-and-indent ()
  "Workaround for clojure when inserting a newline after a comment would indent the expression below weirdly."
  (interactive)
  (if (clojure--in-comment-p)
      (progn (newline nil t)
             (insert ";; "))
    (newline-and-indent)))
#+end_src

**** Config

#+begin_src elisp
(use-package! clojure-mode
  :config
  (define-clojure-indent (alet 'defun) (mlet 'defun))
  (define-clojure-indent (describe 1) (it 1) (is 1)))
#+end_src

#+begin_src elisp
(use-package! lsp-mode
  :commands lsp
  :hook ((clojurescript-mode . lsp)
         (clojure-mode . lsp))
  :config
  (remove-hook 'clojure-mode-hook #'rainbow-delimiters-mode)
  (setq lsp-enable-file-watchers nil)
  (setq lsp-file-watch-ignored-directories
        (cl-union lsp-file-watch-ignored-directories
                  '("[/\\\\]build\\'"
                    "[/\\\\]deployment\\'"
                    "[/\\\\]public\\'"
                    "[/\\\\]resource\\'"
                    "[/\\\\]target\\'"
                    "[/\\\\]tmp\\'"
                    "[/\\\\].log\\'"
                    "[/\\\\].clj-kondo\\'"
                    "[/\\\\].git\\'"
                    "[/\\\\].shadow-cljs\\'"
                    "[/\\\\]src/js\\'"
                    "[/\\\\]src/less\\'"
                    "[/\\\\]src/tailwind\\'"
                    "[/\\\\]test/e2e/screenshots\\'"))))
#+end_src

**** Themes

#+begin_src elisp
(after! clojure-mode
  (font-lock-add-keywords
   'clojurescript-mode
   `((,(concat "(\\(?:clojure.core/\\)?\\("
                (regexp-opt '("defui" "$" "defn*"))
                ;; Function declarations.
                "\\)\\>"
                ;; Any whitespace
                "[ \r\n\t]*"
                ;; Possibly type or metadata
                "\\(?:#^\\(?:{[^}]*}\\|\\sw+\\)[ \r\n\t]*\\)?"

                "\\(\\sw+\\)?")
      (1 font-lock-keyword-face)
      (2 font-lock-function-name-face nil t)))
   t))
#+end_src

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after lsp-mode
 :map lsp-mode-map
 :gni "M-<RET>" #'lsp-find-references)

(map!
 :map (clojure-mode-map clojurescript-mode-map)
 :desc "Newline" :i "RET" #'my-clojure|newline-and-indent
 :desc "Goto parent function" :n "gh" (cmd! (lispyville-backward-function-begin))
 :desc "Goto parent function" :n "[[" (cmd! (lispyville-backward-function-begin))
 :desc "Goto parent function" :n "]]" (cmd! (lispyville-forward-function-begin))
 :localleader
 "s" #'clojure-sort-ns
 "S" #'my-lisp|sort-sexp
 "l" #'my-pitch|l10n-jump)
#+END_SRC

***** Test rotation words

#+begin_src elisp
(add-hook! 'clojurescript-mode-hook
  (defun my-clojure/setup-test-file-vars ()
    "Sets up variables for test files (cypress, jest)."
    (when (-some->> (buffer-file-name)
            (string-match "\\.*_spec.cljs$"))
      ;; Rotate it/it.only
      (add-to-list 'rotate-text-local-symbols '("it" "j/only")))))
#+end_src

*** Stylus

#+begin_src elisp
(defun my-stylus|fmt ()
  (interactive)
  (when-let ((bin (my-file/node-modules-executable-find "stylus-supremacy"))
             (default-directory (projectile-project-root)))
    (shell-command (t! "<<bin>> format <<buffer-file-name>> -r -p stylus.json"))))

(set-formatter! 'stylus-supremacy
  '(("%s" (my-file/node-modules-executable-find "stylus-supremacy"))
    "format" ("%s" buffer-file-name)
    "-p" ("%s/stylus.json" (projectile-project-root)))
  :modes '(stylus-mode))

(setq-hook! 'stylus-mode-hook +format-with 'stylus-supremacy)

(add-to-list '+format-on-save-enabled-modes 'stylus-mode t)
#+end_src

**** Counsel stylus

#+begin_src elisp
(defun my-stylus|imenu-top-level-classes ()
  "imenu for top-level classes in stylus."
  (interactive)
  (let ((items (my-buffer/search-regexp-in-buffer "^\\.[a-zA-Z0-9_-]+")))
    (ivy-read "Select a class selector: "
              items
              :action (-lambda ((_ . l))
                        (evil-scroll-line-to-center l)))))
#+end_src
** Git / Magit :GIT:MAGIT:
*** Packages
**** magit

From ~dd348025233c2302bafc51d8832c5cc691a91b0f~

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! magit :pin "c1fb53d3de6390961ccd8dfb1cc135383508d0fc")
(package! compat :pin "cc1924fd8b3f9b75b26bf93f084ea938c06f9615")
(package! forge :pin "36208c43bf41782cfe81fccc904f8adbe57818e1")
(package! magit-gitflow :pin "cc41b561ec6eea947fe9a176349fb4f771ed865b")
(package! magit-todos :pin "67fd80c2f10aec4d5b2a24b5d3d53c08cc1f05dc")
;; (package! code-review :pin "d38fbe59304ed31c759ce733cda16f69a8ef2d8c" :recipe (:files ("graphql" "code-review*.el")))
#+end_src

**** [[https://github.com/freesteph/elescope][elescope: Search and clone Git repos directly within Emacs.]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! elescope)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package elescope
  :commands (elescope-checkout)
  :config
  (setq elescope-root-folder my-directories:repositories-dir)
  :init
  (defalias '+git|clone 'elescope-checkout))
#+END_SRC
**** [[https://github.com/emacsmirror/git-lens][git-lens: Show new, deleted or modified files in branch]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! git-lens)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! git-lens
  :commands (git-lens))
#+END_SRC
**** [[https://github.com/wandersoncferreira/code-review][code-review]]

***** Config

#+BEGIN_SRC elisp
(use-package! code-review
  :config
  (setq code-review-auth-login-marker 'forge))
#+END_SRC

*** Functions
**** Create worktree workspace

Creates a new git workspace from a branch.
Automatically adds ~.projectfile~ and opens a new doom workspace.

#+BEGIN_SRC elisp
(defun my-magit|create-worktree-project-from-branch (branch start-point &optional force)
  "Create a new BRANCH and check it out in a new worktree at PATH in a new workspace."
  (interactive
   `(,@(magit-branch-read-args "Create and checkout branch")
     ,current-prefix-arg))
  (let* ((worktree-path (f-join (my-file/git-root) ".worktrees"))
         (path (f-join worktree-path branch)))
    (when (not (f-exists-p worktree-path))
      (mkdir worktree-path t))
    (magit-run-git "worktree" "add" (if force "-B" "-b") branch (expand-file-name path) start-point)
    (f-touch (f-join path ".projectile"))
    ;; Ignore existing workspace
    (condition-case nil
        (+workspace-new branch)
      (error nil))
    (+workspace-switch branch)
    (magit-diff-visit-directory path)
    (projectile-add-known-project path)
    path))
#+END_SRC

***** Transient binding :TRANSIENT:

#+begin_src elisp
(after! magit
  (transient-append-suffix 'magit-worktree "b" '("c" "Create branch and worktree" my-magit|create-worktree-project-from-branch)))
#+end_src

**** Revision show original file

Show the original file when visiting a revision buffer.
E.g.: When showing a diff from a commit, you may want to edit that file.

#+BEGIN_SRC elisp
(defun my-magit|show-revision-original ()
  "Show the orginal file from a revision buffer
If possible also go to the pointing line"
  (interactive)
  (when magit-buffer-file-name
    (let ((file-name magit-buffer-file-name)
          (line-number (line-number-at-pos)))
      (if current-prefix-arg
          (delete-other-windows))
      (find-file file-name)
      (goto-line line-number))))
#+END_SRC

**** Changed files in branch

Show a list of the changed files in the current branch.
For now only works on branches that were directly forked from master.

#+BEGIN_SRC elisp
(defun my-magit/list-new-files ()
  "List of added files in the current branch."
  (my-shell/command-to-list "git ls-files -om --exclude-standard"))

(defun my-magit/list-modified-files (&optional branch)
  "Get a list of modified files from the BRANCH to head."
  (my-shell/command-to-list
   (t! "git --no-pager diff --no-renames --name-only --no-merges <<(magit-rev-parse \"HEAD\")>> <<branch>>;")))

(defun my-magit/list-branch-changed-files (branch)
  "Get a list of new and modified files from BRANCH to head."
  (->> (my-magit/list-modified-files branch)
       (-concat (my-magit/list-new-files))
       (-uniq)
       (-filter
        (lambda (x)
          (let ((default-directory (projectile-project-root)))
            (f-exists? x))))))

(defun my-magit|counsel-changed-files (&optional branch)
  (interactive)
  (let ((enable-recursive-minibuffers t))
    (ivy-read (template "Changed files for <<(or branch (magit-get-current-branch))>>:")
              (my-magit/list-branch-changed-files (or "origin/master"))
              :require-match t
              :history 'file-name-history
              :action counsel-projectile-find-file-action
              :caller 'my-magit|counsel-changed-files)))
#+END_SRC
**** Undo commit

#+BEGIN_SRC elisp
(defun my-magit|git-undo ()
  "Soft reset current git repo to HEAD~1."
  (interactive)
  (magit-reset-soft "HEAD~1"))
#+END_SRC

**** Push dated remote branch

For work I need remote branches with a date prefix.

#+BEGIN_SRC elisp
(defun my-magit|push-dated (&optional branch)
  "Pushes the given the current BRANCH with a dated prefix
my-branch-name -> 19-01-my-branch-name
When no BRANCH is given, take the current one."
  (interactive)
  (let* ((branch (or branch (magit-get-current-branch)))
         (date (format-time-string "%y-%m"))
         (remote (template "origin/<<date>>-<<branch>>")))
    (magit-git-push branch remote "--set-upstream")
    remote))
#+END_SRC

**** Diff range from current branch to ~magit-thing-at-point~

When I'm on the log view, I want to quickly diff it against the currently checked out branch.
The transient shortcut for this is ~d R~ define [[*Transient][here]].

#+BEGIN_SRC elisp
(defun my-magit|diff-range-from-current-branch ()
  "Ranged diff from the checked out branch to the commit at point."
  (interactive)
  (magit-diff-range (template "<<(magit-commit-at-point)>>..<<(magit-get-current-branch)>>")))
#+END_SRC

**** Diff range from current pull request

#+BEGIN_SRC elisp
(defun my-magit|diff-range-from-pullreq ()
  "Ranged diff from the pull request under point."
  (interactive)
  (-some->> (forge-current-topic)
    (forge--pullreq-range)
    (magit-diff-range)))
#+END_SRC

**** Review branch

#+BEGIN_SRC elisp
(defun my-magit|delete-review-branches ()
  "Delete all review branches that no longer have an upstream."
  (interactive)
  (->> (magit-list-branches)
       (--filter (s-starts-with? "refs/heads/REVIEW" it))
       (--map (magit-name-local-branch it))
       (--reject (magit-get-upstream-branch it))
       (--each (lambda (x) (magit-branch-delete x t)))))

(defun my-magit|checkout-review-branches (&optional branch start-point)
  "Create a branch with review prefix for easy cleanup afterwards."
  (interactive)
  (let* ((remotes (magit-list-remote-branch-names))
         (atpoint (magit-branch-at-point))
         (branch (magit-completing-read
                  "Checkout branch" remotes
                  nil nil nil 'magit-revision-history
                  (or (car (member atpoint remotes))
                      (and atpoint
                           (car (member (and (string-match "[^/]+/" atpoint)
                                             (substring atpoint (match-end 0)))
                                        remotes))))))
         (review-branch-name (s-replace "origin/" "REVIEW-" branch)))
    ;; HACK Workaround where the buffer cant be read
    (advice-remove 'magit-checkout #'+magit-revert-repo-buffers-deferred-a)
    (magit-checkout branch)
    (when (magit-anything-modified-p)
      (user-error "Cannot checkout when there are uncommitted changes"))
    (if (-contains? (magit-list-local-branch-names) review-branch-name)
        (magit-branch-checkout review-branch-name)
      (magit-branch-and-checkout (s-replace "origin/" "REVIEW-" branch) branch))))
#+END_SRC
**** Cleanup branches

Cleans up all merged and review branches

#+BEGIN_SRC elisp
(defun my-magit|cleanup-branches (&optional base-branch)
  "Remove all merged and review branches."
  (interactive)
  (my-magit|delete-review-branches)
  (let* ((base-branch (or base-branch "master")))
    (call-interactively #'my-magit|delete-review-branches)
    (deferred:$
      (deferred:process-shell (template "git branch --merged | egrep -v \"(^\\*|<<base-branch>>)\" | xargs git branch -d"))
      (deferred:nextc it
        (magit-status-maybe-update-revision-buffer)))))
#+END_SRC

**** Branches by user

#+BEGIN_SRC elisp
(defun my-magit|branches-by-user (&optional ignore-review?)
  "List all branches by user.
Universal argument to ignore review branches."
  (interactive "P")
  (let ((branches
         (->>
          (concat "git for-each-ref"
                  " --sort=-committerdate"
                  " --format='%(committerdate) %(authorname) %(refname)'"
                  " --sort=-committerdate"
                  ;; refs/remotes/origin/ for remote branches
                  " refs/heads"
                  " | grep -e 'Florian Schroedl'")
          (shell-command-to-string)
          (s-split "\n")
          (-butlast)
          (-map (lambda (x) (->> (s-match ".*Florian Schroedl refs\\/heads\\/\\(.*\\)" x)
                                 (-last-item))))
          ((lambda (xs)
             (if ignore-review?
                 (--reject (s-starts-with? "REVIEW" it) xs)
               xs))))))
    (ivy-read "Checkout: " branches :action #'magit-checkout)))
#+END_SRC

**** Commit Template

Loads commit template from ~./git/TEMPLATE~ if the file exist.

#+BEGIN_SRC elisp
(defun my-magit::commit-template/find-template-file (branch)
  (when-let* ((dir (my-magit/find-root-git-dir))
              (entries (f-entries dir (lambda (x) (s-starts-with? "TEMPLATE" (f-base x)))))
              (branch-template (template "TEMPLATE-<<branch>>")))
    (or
     (-find (lambda (x) (string= branch-template (f-base x))) entries)
     (-find (lambda (x) (string= "TEMPLATE" (f-base x))) entries))))

(defun my-magit::commit-template|remove-template-file ()
  "Open an existing template file or create a new one."
  (interactive)
  (-when-let* ((file (my-magit::commit-template/find-template-file (magit-get-current-branch))))
    (when (save-window-excursion
            (find-file file)
            (y-or-n-p "Delete commit template file?"))
      (f-delete file))))

(defun my-magit::commit-template|edit-template-file ()
  "Open an existing template file or create a new one."
  (interactive)
  (let ((file (or (my-magit::commit-template/find-template-file (magit-get-current-branch))
                  (f-join (my-magit/find-root-git-dir) "TEMPLATE"))))
    (find-file file)))

(defun my-magit::commit-template/insert-template (&rest _)
  "When a TEMPLATE file in the git directory exists, insert it as a commit template."
  (when (eq (point) (point-at-eol))
    (-some->> (my-magit::commit-template/find-template-file (magit-get-current-branch))
      (f-read)
      (s-trim)
      (s-append " ")
      (insert)))
  (evil-insert-state))
#+END_SRC

And the hook

#+BEGIN_SRC elisp
(add-hook! 'git-commit-setup-hook :append #'my-magit::commit-template/insert-template)
#+END_SRC

**** Find root directory

Find the root directory of a ~.git~ repository
This also works for worktrees that are in a nested directory.

#+BEGIN_SRC elisp
(defun my-magit/find-root-git-dir ()
  "Find the root directory of a repository."
    (-some->> (magit-toplevel)
      (-f-join ".git")
      (-id-when #'f-exists?)
      ((lambda (x)
         (if (f-file? x)
             (->> (magit-list-worktrees)
                  (car)
                  (car)
                  (-f-join ".git"))
           x)))))
#+END_SRC
**** Lock git buffer :ADVICE:

#+BEGIN_SRC elisp
(advice-add #'magit-toggle-buffer-lock :after (lambda () (my/bool-state-message 'magit-buffer-locked-p)))
#+END_SRC

**** Check for merge conflicts
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option][Is there a git-merge --dry-run option? - Stack Overflow]]
:END:

Try two merge two branches in memory, to determine if there would be merge conflicts.

#+BEGIN_SRC elisp
(defun my-magit/check-for-merge-conflicts (&optional source-branch target-branch)
  "Try to merge SOURCE-BRANCH into TARGET-BRANCH, return list of conflicting files when there are any.
This will try to merge in memory, so no index files will be created.
SOURCE-BRANCH defaults to the current branch.
TARGET-BRANCH defaults to origin/master."
  (interactive)
  (let* ((source-branch (or source-branch (magit-get-current-branch)))
         (target-branch (or target-branch "origin/master"))
         (merge-base (my-shell/command-to-list (t! "git merge-base <<target-branch>> <<source-branch>>"))))
    (my-shell/command-to-list (t! "git merge-tree <<(car merge-base)>> <<target-branch>> <<source-branch>>"))))
#+END_SRC
**** Copy over changes from diff

#+BEGIN_SRC elisp
(defun my-magit|diff-copy-file-changes ()
  "Copies over contents of diff at point to the curent file system."
  (interactive)
  (save-excursion
    (let ((buffer (call-interactively #'magit-diff-visit-file)))
      (with-current-buffer buffer
        (make-directory (f-dirname magit-buffer-file-name) t)
        (f-write (substring-no-properties (buffer-string)) 'utf-8 magit-buffer-file-name)))
    (kill-buffer)))
#+END_SRC
**** Smerge mode hydra
:PROPERTIES:
:SOURCE:   [[https://github.com/alphapapa/unpackaged.el#hydra][alphapapa/unpackaged.el: A collection of useful Emacs Lisp code that isn't substantial enough to be packaged]]
:END:

#+BEGIN_SRC elisp
(use-package smerge-mode
  :after hydra
  :config
  (defhydra unpackaged/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^        ^Keep^                ^Diff^                  ^Other^
^^------------^^---------------------^^----------------------^^-------
_gn_ext       _gb_ase               _g<_: upper/base        _gC_ombine
_gp_rev       _gu_pper              _g=_: upper/lower       _gr_esolve
^^            _gl_ower              _g>_: base/lower        _gk_ill current
^^            _ga_ll                _gR_efine
^^                                  _gE_diff
"
    ("gn" smerge-next)
    ("gp" smerge-prev)
    ("gb" smerge-keep-base)
    ("gu" smerge-keep-upper)
    ("gl" smerge-keep-lower)
    ("ga" smerge-keep-all)
    ("g<" smerge-diff-base-upper)
    ("g=" smerge-diff-upper-lower)
    ("g>" smerge-diff-base-lower)
    ("gR" smerge-refine)
    ("gE" smerge-ediff)
    ("gC" smerge-combine-with-next)
    ("gr" smerge-resolve)
    ("gk" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  (add-hook! 'magit-diff-visit-file-hook
    (defun my-smerge-mode*init-smerge-mode ()
      "Reveal the point if in an invisible region."
      (when smerge-mode
        ;; Prevent parinfer triggering on diff files
        (when parinfer-rust-mode (parinfer-rust-mode-disable))
        ;; Disable flycheck for diff buffers
        (flycheck-mode -1)
        (unpackaged/smerge-hydra/body)))))
#+END_SRC

**** Merge master

#+begin_src elisp
(defun my-magit|merge-master ()
  "Merges origin master to the current branch."
  (interactive)
  (magit-merge-plain "origin/master"))
#+end_src
**** Git related find file

#+begin_src elisp :tangle no
(require 'cl-lib)
(require 'subr-x)
(require 'project)
(require 'vc-git)

(defface git-related-score
  '((t (:foreground "#50a6c6")))
  "Face used for git related score."
  :group 'git-related)

(defface git-related-file
  '((t (:foreground "#82898b")))
  "Face used for git related file name."
  :group 'git-related)

(defvar git-related--graphs nil)

(cl-defstruct git-related--graph files commits)
(cl-defstruct git-related--file (name "" :type string) (commits nil :type list))
(cl-defstruct git-related--commit (sha "" :type string) (files nil :type list))

(defun git-related--new-graph ()
  "Create an empty graph."
  (make-git-related--graph
   :files (make-hash-table :test 'equal :size 2500)
   :commits (make-hash-table :test 'equal :size 2500)))

(defun git-related--record-commit (graph sha filenames)
  "Record in the GRAPH the relation between SHA and FILENAMES."
  (let ((commit (make-git-related--commit :sha sha)))
    (dolist (filename filenames)
      (let* ((seen-file (gethash filename (git-related--graph-files graph)))
             (file-found (not (null seen-file)))
             (file (or seen-file (make-git-related--file :name filename))))

        (cl-pushnew commit (git-related--file-commits file))
        (cl-pushnew file (git-related--commit-files commit))

        (unless file-found
          (setf (gethash filename (git-related--graph-files graph)) file))))

    (setf (gethash sha (git-related--graph-commits graph)) commit)))

(defun git-related--replay (&optional graph)
  "Replay git commit history into optional GRAPH."
  (let ((graph (or graph (git-related--new-graph))))
    (with-temp-buffer
      (process-file vc-git-program nil t nil "log" "--name-only" "--format=%x00%H")
      (let* ((commits (split-string (buffer-string) "\0" t))
             (replay-count 0)
             (progress-reporter (make-progress-reporter "Building commit-file graph..." 0 (length commits))))
        (dolist (commit commits)
          (let* ((sha-and-paths (split-string commit "\n\n" t (rx whitespace)))
                 (sha (car sha-and-paths))
                 (paths (when (cadr sha-and-paths)
                          (split-string (cadr sha-and-paths) "\n" t (rx whitespace)))))
            (git-related--record-commit graph sha paths)
            (progress-reporter-update progress-reporter (cl-incf replay-count))))
        (progress-reporter-done progress-reporter)))
    graph))

(defun git-related--similar-files (graph filename)
  "Return files in GRAPH that are similar to FILENAME."
  (unless (git-related--graph-p graph)
    (user-error "You need to index this project first"))
  (let ((file (gethash filename (git-related--graph-files graph))))
    (when file
      (let ((file-sqrt (sqrt (length (git-related--file-commits file))))
            (neighbor-sqrts (make-hash-table :test 'equal :size 100))
            (hits (make-hash-table :test 'equal :size 100)))

        (dolist (commit (git-related--file-commits file))
          (dolist (neighbor (remove file (git-related--commit-files commit)))
            (let ((count (cl-incf (gethash (git-related--file-name neighbor) hits 0))))
              (when (= count 1)
                (setf (gethash (git-related--file-name neighbor) neighbor-sqrts)
                      (sqrt (length (git-related--file-commits neighbor))))))))

        (let (ranked-neighbors)
          (maphash
           (lambda (neighbor-name neighbor-sqrt)
             (let ((axb (* file-sqrt neighbor-sqrt))
                   (n (gethash neighbor-name hits)))
               (push (list (if (cl-plusp axb) (/ n axb) 0.0) neighbor-name) ranked-neighbors)))
           neighbor-sqrts)
          (cl-sort
           (cl-remove-if-not #'git-related--file-exists-p ranked-neighbors :key #'cadr)
           #'> :key #'car))))))

(defun git-related--file-exists-p (relative-filename)
  "Determine if RELATIVE-FILENAME currently exists."
  (file-exists-p
   (expand-file-name relative-filename
                     (my-file/git-root nil))))

(defun git-related--propertize (hit)
  "Given the cons HIT return a rendered representation for completion."
  (propertize
   (concat
    (propertize (format "%2.2f" (car hit)) 'face 'git-related-score)
    " ---> "
    (propertize (cadr hit) 'face 'git-related-file))
   'path (cadr hit)))

;;;###autoload
(defun git-related-update ()
  "Update graph for the current project."
  (interactive)
  (let* ((default-directory (my-file/git-root nil))
         (project-symbol (intern (project-name (project-current))))
         (graph (cl-getf git-related--graphs project-symbol)))
    (setf (cl-getf git-related--graphs project-symbol)
          (git-related--replay graph))))

;;;###autoload
(defun git-related-find-file ()
  "Find files related through commit history."
  (interactive)
  (if (buffer-file-name)
      (let ((default-directory (my-file/git-root nil)))
        (find-file
         (let* ((selection (completing-read "Related files: "
                                            (mapcar #'git-related--propertize
                                                    (git-related--similar-files
                                                     (cl-getf git-related--graphs (intern (project-name (project-current))))
                                                     (file-relative-name (buffer-file-name) (my-file/git-root nil))))
                                            nil t)))
           (when selection
             (let ((filename (get-text-property 0 'path selection)))
               (find-file filename))))))
    (message "Current buffer has no file")))

(provide 'git-related)

;;; git-related.el ends here
#+end_src


**** Delete multiple worktrees

#+begin_src elisp
(defun my-magit|worktree-delete (worktrees)
  "Delete one or multiple worktrees."
  (interactive
   (list (ivy-read "Delete worktree" (cdr (magit-list-worktrees))
                   :action (lambda (x)
                             (magit-worktree-delete (first x)))
                   :multi-action (lambda (xs)
                                   (--map (magit-worktree-delete (first it)) xs))))))
#+end_src

*** Config

#+BEGIN_SRC elisp
(after! magit
  :config
  (setq
   magit-save-repository-buffers 'dontask
   magit-clone-default-directory "~/Code/Repositories/"
   magithub-clone-default-directory magit-clone-default-directory
   git-commit-summary-max-length 120))

(after! forge
  :config
  (setq forge-database-file (f-join doom-local-dir "forge-database.sqlite")))
#+END_SRC

**** Fix smerge mode color

#+BEGIN_SRC elisp
(after! smerge-mode
  :config
  ;; TODO This is broken after switching the theme but works for now
  ;; This fixes the smerge diff color is really bright an ugly
  (set-face-attribute 'smerge-refined-added nil :foreground nil :background nil))
#+END_SRC

**** ~magit-find-file~ customizations

~magit-blob-mode~ overrides loads of evil bindings, making it very annoying to use.
The mode doesn't really bring big advantages so I remove the hook.

#+begin_src elisp
(after! magit
  ;; Fix binding overrides with evil
  (remove-hook 'magit-find-file-hook #'magit-blob-mode)
  ;; Add line-numbers
  (add-hook! 'magit-find-file-hook #'display-line-numbers-mode))
#+end_src

*** Bindings
**** Diff Navigation

My workflow for navigating diffs
Use ~z1~ to fold all diffs to their file headers and press's ~{~ or ~}~ to

1. Refold all sections
2. Go to the next section
3. Unfold everything in the current section

Then use ~]~ to navigate the sections

#+BEGIN_SRC elisp
(defun my-magit/jumpunfold-section (&optional forward)
  "Fold all section. Go to next section when FORWARD. Show all children"
  (interactive)
  (magit-section-show-level-1-all)
  (call-interactively (if forward #'magit-section-forward-sibling #'magit-section-backward-sibling))
  (call-interactively #'magit-section-show-children))

(map!
 (:map magit-diff-mode-map
  :nv "}" (cmd! (my-magit/jumpunfold-section 't))
  :nv "{" (cmd! (my-magit/jumpunfold-section))))
#+END_SRC

**** Code Review

#+begin_src elisp
(map!
 :after code-review
 :map code-review-mode-map
 :ng "RET" #'magit-diff-visit-file
 :ng "TAB" #'magit-section-toggle
 :ng "<tab>" #'magit-section-toggle
 :n "[[" #'code-review-comment-jump-previous
 :n "]]" #'code-review-comment-jump-next)
#+end_src

**** Time Machine Navigation

#+BEGIN_SRC elisp
(map!
 :after git-timemachine
 :map git-timemachine-mode-map
 :n "[" #'git-timemachine-show-previous-revision
 :n "]" #'git-timemachine-show-next-revision
 :n "gb" #'git-timemachine-blame)
#+END_SRC

**** Disable quit for locked buffers

Disable accidentally quitting magit buffers with ~q~ when the buffer is locked.

#+BEGIN_SRC elisp
(defun my-magit/disable-locked-quit (orig-fn &rest args)
  (unless magit-buffer-locked-p
    (apply orig-fn args)))

(advice-add #'magit-mode-bury-buffer :around #'my-magit/disable-locked-quit)
#+END_SRC

**** Fix text mode

Restores functionality when editing magit buffers as text.
For now only the toggle functionality is needed.

#+BEGIN_SRC elisp
(defvar +magit-evil-edit-mode-map (make-sparse-keymap))

(define-minor-mode +magit-evil-edit-mode ""
  :keymap +magit-evil-edit-mode-map)

(map! :map +magit-evil-edit-mode-map
      :n [tab] #'magit-section-toggle)
#+END_SRC

*** Transient Bindings :TRANSIENT:

You can add flags or commands to the magit interface transient here.
To append something, just state the flag that you see in the transient popup as the 2nd argument.

#+BEGIN_SRC elisp
(after! magit
  (transient-append-suffix 'magit-log "-f" '("-0" "No merges" "--no-merges"))
  (transient-append-suffix 'magit-push "p" '("d" "dated" my-magit|push-dated))

  (transient-append-suffix 'magit-diff "d" '("R" "Diff range from current branch" my-magit|diff-range-from-current-branch))
  (transient-append-suffix 'magit-diff "d" '("P" "Pullrequest Range" my-magit|diff-range-from-pullreq))
  (transient-append-suffix 'magit-diff "d" '("f" "File" magit-diff-buffer-file))

  (transient-append-suffix 'magit-commit
    "-R" '("-D" "Override the author date" "--date=" transient-read-date))
  (transient-append-suffix 'magit-merge
    "m" '("M" "Merge master" my-magit|merge-master))

  (transient-append-suffix 'magit-branch "l" '("R" "Create review branch" my-magit|checkout-review-branches))
  (transient-append-suffix 'magit-branch "l" '("U" "My Branches" my-magit|branches-by-user)))
#+END_SRC
** Dired :DIRED:ORGANIZATION:
*** Packages
**** [[https://github.com/Fuco1/dired-hacks#dired-filter][dired-hacks - dired-filter]]

Filter current dired buffer by query/extension etc.
Trigger with ~g/.~ in ~normal-mode~.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! dired-filter)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! dired-filter
  :after dired
  :config
  (setq dired-filter-saved-filters
        (quote (("images"
                 (extension "jpg" "png" "gif"))
                ("media"
                 (extension "mp3" "mp4" "MP3" "MP4" "avi" "mpg" "flv" "ogg" "wmv" "mkv" "mov" "wma"))
                ("archives"
                 (extension "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
                ("documents"
                 (extension "doc" "docx" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub")))))
  (dired-filter-define created-today
      "Show only files that are newer than today."
    (:description "created-today")
    (let ((case-fold-search nil))
      (time-less-p (time-subtract (current-time) (* 60 60 24))
                   (file-attribute-modification-time (file-attributes file-name))))))
#+END_SRC
**** [[https://github.com/Fuco1/dired-hacks#dired-subtree][dired-hacks/dired-subtree]]

***** Config

#+BEGIN_SRC elisp
(use-package! dired-subtree
  :after dired
  :config
  (evil-define-key 'normal dired-mode-map
    (kbd "<tab>") (cmd! () (dired-subtree-toggle)
                      ;; Fix for dired-all-the-icons not showing up
                      (dired-revert))
    (kbd "<backtab>") (cmd! () (dired-subtree-cycle)
                          (dired-revert))
    (kbd "gh") 'dired-subtree-up))
#+END_SRC
**** [[https://github.com/Fuco1/dired-hacks#dired-subtree][dired-hacks/dired-subtree]]

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! dired-subtree)
#+END_SRC

*** Config
**** Listing Switches / Sorting

#+BEGIN_SRC elisp
(defconst my-dired:default-listing-switches
  "-ahl -t --group-directories-first")

(setq dired-listing-switches my-dired:default-listing-switches)
#+END_SRC

**** Omit files types in dired

#+begin_src elisp
(use-package! dired
  :config
  (setq dired-omit-files
        (concat dired-omit-files
                ;; Apple files
                "\\|\\.com.apple.timemachine.donotpresent$"
                "\\|\\.Spotlight-V100$"
                "\\|\\.fseventsd$"
                "\\|\\.DocumentRevisions-V100$"
                "\\|\\.TemporaryItems$"
                ;; Windows files
                "\\|\\System Volume Information$")))
#+end_src

**** Automatically revert dired buffers
:PROPERTIES:
:SOURCE:   [[https://www.reddit.com/r/emacs/comments/1acg6q/how_to_configure_dired_to_update_instantly_when/][How to configure dired to update instantly when files/folders change? : emacs]]
:END:

#+BEGIN_SRC elisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

**** Automatically create directories when moving/copying items :ADVICE:
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/12994164/allow-dired-do-copy-and-dired-do-rename-to-create-new-dir-on-the-fly][emacs - Allow dired-do-copy and dired-do-rename to create new dir on the fly - Stack Overflow]]
:END:

#+BEGIN_SRC elisp
(after! dired
  (defadvice dired-mark-read-file-name (after rv:dired-create-dir-when-needed (prompt dir op-symbol arg files &optional default) activate)
    (when (member op-symbol '(copy move))
      (let ((directory-name (if (< 1 (length files))
                                ad-return-value
                              (file-name-directory ad-return-value))))
        (when (and (not (file-directory-p directory-name))
                   (y-or-n-p (format "directory %s doesn't exist, create it?" directory-name)))
          (make-directory directory-name t))))))
#+END_SRC
**** Enable Async Mode

#+BEGIN_SRC elisp
(after! async
  (dired-async-mode 1))
#+END_SRC
*** Functions
**** Kill all dired buffers

#+BEGIN_SRC elisp
(defun my-dired|kill-dired-buffers ()
  "Kills all dired buffers."
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))
#+END_SRC

**** Go to mounted drive :COUNSEL:

#+begin_src elisp
(defun my-dired|find-mounted-drive ()
  "Browse mounted disk.
When the mounted drive has only 1 partition, select this one otherwise show listing of disks."
  (interactive)
  (let ((dir (f-join "/run/media/" user-login-name)))
    (counsel-find-file
     (-some->> dir
       (f-directories)
       (--id-when (eq 1 (length it)))
       (car))
     (f-join "/run/media/" user-login-name))))
#+end_src

**** Unparent directory at point

#+BEGIN_SRC elisp
(defun my-dired|ungroup-directory ()
  "Move all files and directories to the current directory,
If everything goes well and the directory is empty, safely delete it.
It might not work out though, when any of the entries has the same name,
in that case throw a warning."
  (interactive)
  (->> (dired-get-marked-files)
       (-map (lambda (x)
               (let ((cmd (if (my-file/dir-has-hidden-entries x)
                              "mv -n ./* ./.* ../"
                            "mv -n ./* ../")))
                 (shell-command (t! "cd \"<<x>>\"; <<cmd>>"))
                 (when (f-empty? x)
                   (dired-delete-file x))))))
  (revert-buffer))
#+END_SRC
**** TODO Mouse navigation of the heading directory
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/13354/dired-heading-directory-with-text-properties-to-jump-to-parent-directories][breadcrumbs - Dired heading directory with text-properties to jump to parent directories - Emacs Stack Exchange]]
:END:

Allows to click on the header bar to got to navigate tree breadcrumbs in the dired header bar.

#+begin_src elisp
(defface dired-mouseover-face
  '((t (:foreground "green")))
  "Face for `dired-mouseover-face'."
  :group 'dired)

(defvar dired-mouse-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mouse-2] 'dired-follow-link)
    (define-key map [return] 'dired-follow-link)
    (define-key map [follow-link] 'mouse-face)
    map)
  "Keymap for mouse when in `dired-mode'.")

;; Author:  Drew Adams -- http://emacs.stackexchange.com/a/13411/2287
(defun dired-follow-link (event)
  "Follow the link in the dired directory heading, causing a new
dired buffer to be opened.
When clicking on the current directory always go one directory upwards."
  (interactive (list last-nonmenu-event))
  (run-hooks 'mouse-leave-buffer-hook)
  (with-current-buffer (window-buffer (posn-window (event-start event)))
    (let ((path  (get-text-property (posn-point (event-start event)) 'breadcrumb)))
      (if (f-equal? dired-directory path)
          (dired-up-directory)
        (dired path)))))

(defun dired-propertize-directory-heading ()
  (interactive)
  (unless (buffer-narrowed-p)
    (let* (
           p beg end path peol
           (inhibit-read-only t))
      (save-excursion
        (goto-char (point-min))
        (setq peol (point-at-eol))
        (set-text-properties (point) peol nil)
        (re-search-forward "\\([^/\\]+\\)[/\\]" peol t)
        (when (looking-back "\\(^ +\\)\\([a-zA-Z]:\\)?/")
          (setq p (match-end 1))
          (setq path (if (match-string 2) (concat (match-string 2) "/") "/"))
          (add-text-properties (point-min) (1- (match-end 0)) (list
                                                               'breadcrumb path
                                                               'mouse-face 'dired-mouseover-face
                                                               'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                                               'keymap dired-mouse-map)))
        (while (re-search-forward "\\([^/\\]+\\)[/\\]" peol t)
          (setq beg (match-beginning 1))
          (setq end (match-end 1))
          (setq path (buffer-substring-no-properties p end))
          (add-text-properties beg end (list
                                        'breadcrumb path
                                        'mouse-face 'dired-mouseover-face
                                        'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                        'keymap dired-mouse-map)))
        (setq path (buffer-substring-no-properties p (1- peol)))
        (add-text-properties (point) (1- peol) (list
                                                'breadcrumb path
                                                'mouse-face 'dired-mouseover-face
                                                'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                                'keymap dired-mouse-map))))))

(add-hook 'dired-after-readin-hook 'dired-propertize-directory-heading)
#+end_src
**** Get marked file size
:PROPERTIES:
:SOURCE:   https://www.emacswiki.org/emacs/DiredGetFileSize
:END:

#+BEGIN_SRC elisp
 (defun my-dired|get-marked-file-size ()
   "Get the file size of all marked dired entries."
   (interactive)
   (let ((files (dired-get-marked-files)))
     (with-temp-buffer
       (apply 'call-process "du" nil t nil "-sch" files)
       (message
        "Size of all marked files: %s"
        (progn (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$") (match-string 1))))))
#+END_SRC

**** Toggle sorting

When you toggle the sorting via ~dired-sort-toggle-or-edit~ the cursor stays at the current file, which is very disorienting.
With this function the cursor stays on the current line.
~save-excursion~ does not work in this function, it just throws to the top of the buffer.
The dired-line jumps at the end are used to jump the filename again.

#+BEGIN_SRC elisp
(defun my-dired|toggle-sorting (&optional arg)
  "Change sorting but stay on the same line."
  (interactive "P")
  (let ((pos (point)))
    (cond
     ((eq arg 3)
      (setq dired-listing-switches (symbol-value 'my-dired:default-listing-switches))
      (setq dired-actual-switches (symbol-value 'my-dired:default-listing-switches))
      (dired-sort-set-mode-line)
      (revert-buffer))
     ((eq arg 2)
      (setq dired-listing-switches
            (read-string "Global ls switches (must contain -l): " dired-listing-switches))
      (setq dired-actual-switches (symbol-value 'dired-listing-switches))
      (dired-sort-set-mode-line)
      (revert-buffer))
     (arg
      (setq dired-actual-switches
            (read-string "Buffer ls switches (must contain -l): " dired-actual-switches)))
     (t (dired-sort-toggle-or-edit)))
    (goto-char pos)
    (dired-next-line 1)
    (dired-previous-line 1)))
#+END_SRC
**** Open file externally
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/cgbpvl/opening_media_files_straight_from_gnu_emacs_dired/eufxc9j/
:END:

***** Config

#+begin_src elisp
(defvar my-dired::open-external:extensions nil
  "Which files to open externally by default when pressing enter.")

(setq my-dired::open-external:extensions
      '(
        ;; Video
        "mov" "mpv" "mkv" "webm" "avi"
        ;; Audio
        "mp4" "mp3" "ogg"))
#+end_src

***** Function

#+BEGIN_SRC elisp
(defun my-dired::open-external/mouse-open (event)
  "Open marked dired file(s) at point with an external application. Open directories normally"
  (interactive "e")
  (my-dired::open-external/mouse-open event))

(defun my-dired::open-external/mouse-open (event &optional find-file-func find-dir-func)
  "In Dired, visit the file or directory name you click on.
The optional arguments FIND-FILE-FUNC and FIND-DIR-FUNC specify
functions to visit the file and directory, respectively.  If
omitted or nil, these arguments default to `find-file' and `dired',
respectively."
  (interactive "e")
  (or find-file-func (setq find-file-func 'my-dired::open-external/xdg-open))
  (or find-dir-func (setq find-dir-func 'dired))
  (let (window pos file)
    (save-excursion
      (setq window (posn-window (event-end event))
            pos (posn-point (event-end event)))
      (if (not (windowp window))
          (error "No file chosen"))
      (set-buffer (window-buffer window))
      (goto-char pos)
      (setq file (dired-get-file-for-visit))
      (if (file-directory-p file)
          (or (and (cdr dired-subdir-alist)
                   (dired-goto-subdir file))
              (progn
                (select-window window (funcall find-dir-func file))))
        (select-window window)
        (funcall find-file-func)))))

(defun my-dired::open-external/xdg-open (&optional file)
  "Open marked dired file(s) at point with an external application."
  (let ((file-list (or (list file) (dired-get-marked-files)))
        (process-connection-type nil))
    (--map (my-shell/no-exit-command "xdg-open" (s-wrap (expand-file-name it) "\"")) file-list)))

(defun my-dired::open-external|open-dwim (&optional file)
  (interactive)
  (let ((file-list (or file (dired-get-marked-files)))
        (process-connection-type nil))
    (-each file-list (lambda (x)
                       (message "%s" x)
                       (let* ((path (expand-file-name x))
                              (ext (f-ext path)))
                         (if (-contains? my-dired::open-external:extensions ext)
                             (my-shell/no-exit-command "xdg-open" (s-wrap path "\""))
                           (dired-find-file)))))))
#+END_SRC
**** Convert Images
:PROPERTIES:
:SOURCE:   [[http://xenodium.com/enrich-your-dired-batching-toolbox/index.html][Enrich Emacs direds batching toolbox]]
:END:

#+BEGIN_SRC elisp
(defun my-dired|convert-image (&optional arg)
  "Convert image files to other formats."
  (interactive "P")
  (assert (executable-find "convert") nil "Install imagemagick")
  (let* ((dst-fpath)
         (src-fpath)
         (src-ext)
         (last-ext)
         (dst-ext))
    (mapc
     (lambda (fpath)
       (setq src-fpath fpath)
       (setq src-ext (downcase (file-name-extension src-fpath)))
       (when (or (null dst-ext)
                 (not (string-equal dst-ext last-ext)))
         (setq dst-ext (completing-read "to format: "
                                        (seq-remove (lambda (format)
                                                      (string-equal format src-ext))
                                                    '("jpg" "png")))))
       (setq last-ext dst-ext)
       (setq dst-fpath (format "%s.%s" (file-name-sans-extension src-fpath) dst-ext))
       (message "convert %s to %s ..." (file-name-nondirectory dst-fpath) dst-ext)
       (set-process-sentinel
        (start-process "convert"
                         (generate-new-buffer (format "*convert %s*" (file-name-nondirectory src-fpath)))
                         "convert" src-fpath dst-fpath)
        (lambda (process state)
          (if (= (process-exit-status process) 0)
              (message "convert %s ✔" (file-name-nondirectory dst-fpath))
            (message "convert %s ❌" (file-name-nondirectory dst-fpath))
            (message (with-current-buffer (process-buffer process)
                       (buffer-string))))
          (kill-buffer (process-buffer process)))))
     (dired-map-over-marks (dired-get-filename) arg))))
#+END_SRC
**** Shred File

#+begin_src elisp
(defun my-dired|do-shred ()
  "Run shred on marked files.
This will erase them."
  (interactive)
  (yes-or-no-p "Do you REALLY want to shred these files forever? ")
  (save-window-excursion
    (dired-do-async-shell-command "shred -zu" nil (dired-get-marked-files))))
#+end_src

*** Bindings

#+BEGIN_SRC elisp
(map! :after dired
      :map dired-mode-map
      ;; Mouse controls
      :ng (kbd "<mouse-2>") 'my-dired::open-external|open-dwim
      :ng (kbd "<mouse-8>") 'dired-up-directory


      :n "q" (cmd! (kill-buffer))
      :n "Q" #'my-dired|kill-dired-buffers

      :ng "RET" 'my-dired::open-external|open-dwim
      :gn "o" 'my-dired|toggle-sorting
      :n "gg" 'my-dired|goto-top
      :localleader
      (:prefix ("s" . "search")
       "i"  #'dired-goto-subdir))

(define-key dired-mode-map (kbd "<down-mouse-1>") 'dired-mouse-find-file)
#+END_SRC

**** Go to top =gg= evil fix :EVIL:

When I do =gg= in dired, I mostly want to go to the first entry.
This function first goes to the first entry and then to the top of the buffer.

#+BEGIN_SRC elisp
(defun my-dired|goto-top ()
  "Go to first directory, when already there go to first line."
  (interactive)
  (if (<= (line-number-at-pos) 3)
      (goto-char (point-min))
    (goto-line 3)
    (dired-next-dirline 1)
    (dired-prev-dirline 1)))
#+END_SRC
**** Wdired mode evil fix :EVIL:

Stay in normal mode when switching to wdired

#+BEGIN_SRC elisp
(defun my-dired|evil-wdired-mode ()
  "Stay in normal mode when switching to wdired."
  (interactive)
  (wdired-change-to-wdired-mode)
  (evil-normal-state))

(map! :after dired
      :map dired-mode-map
      :n "\\" #'my-dired|evil-wdired-mode)
#+END_SRC

**** Use same window for copying/renaming with prefix

I've set ~dired-dwim-target~ to ~t~, so it uses the other window as the target destination.
I undo this option with the interactive prefix argument, which can be accessed via ~SPC ucopy R/U~.

#+BEGIN_SRC elisp
(defun my-dired/dired-target-from-prefix (fn)
  (let ((dired-dwim-target (if (eq (prefix-numeric-value current-prefix-arg) 4) ;; Single C-u
                              nil
                            dired-dwim-target)))
      (call-interactively fn)))

(map! :after dired
      :map dired-mode-map
      :n "R" (cmd! (my-dired/dired-target-from-prefix #'dired-do-rename))
      :n "C" (cmd! (my-dired/dired-target-from-prefix #'dired-do-copy)))
#+END_SRC

**** Dired Paste DWIM

#+BEGIN_SRC elisp
(defun my-dired|paste-dwim ()
  "Paste data in the current directory."
  (interactive)
  (let ((file (read-string "Filename: "))
        (last-clip-type (->> (shell-command-to-string "greenclip print")
                             (s-split "\n")
                             (-first-item))))
    (unless (string= "" file)
      (cond
       ((s-matches? "^image\\/png" last-clip-type)
        (shell-command-to-string (template "xclip -selection clipboard -t image/png -o > <<file>>")))))
    (dired-revert)))

(map! :after dired
      :map dired-mode-map
      :n "p" 'my-dired|paste-dwim)
#+END_SRC
** System :SYSTEM:
*** Packages
**** [[https://github.com/emacs-straight/disk-usage][disk-usage]]

Explore disk usage in emacs

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! disk-usage)
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! disk-usage
  :commands (disk-usage)
  :config
  (map! :map disk-usage-mode-map
        :n "-" #'disk-usage-up))
#+END_SRC
**** [[https://github.com/alpha22jp/atomic-chrome][atomic-chrome]] :BROWSER:

Edit browser input fields with emacs.

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! atomic-chrome)
#+END_SRC
***** Config

#+begin_src elisp
(use-package! atomic-chrome
  :commands (atomic-chrome-start-server)
  :config
  (setq
   atomic-chrome-url-major-mode-alist
   '(("github\\.com" . gfm-mode))))
#+end_src

**** [[https://github.com/cbowdon/daemons.el][cbowdon/daemons.el Systemd UI]] :LINUX:

Manage systemd from emacs

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! daemons)
#+END_SRC
***** Config

#+begin_src elisp
(use-package! daemons
  :commands (daemons))
#+end_src
**** [[https://doc.endlessparentheses.com/Fun/proced-mode.html][proced]] :UNIX:
***** Packages

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! proced-narrow)
#+END_SRC

***** Functions
****** Shorten nixos path names in proced

Nixos paths can be very long, which is distracting in proced.
This shortens the nixos paths to ~{nix}~.

#+BEGIN_SRC elisp
(defun my-proced/remove-nixos-path-name (oldformat &rest xs)
  (let ((xs (--map (->> it
                        (s-replace-regexp "/nix/store/[^/]+" "{nix}")
                        (s-replace-regexp (concat "^/home/" (user-login-name)) "~")
                        (s-replace-regexp (concat "^/etc/profiles/per-user/" (user-login-name)) "~")
                        ((lambda (x) (if (s-contains? "chromium" x) "{chromium}" x))))
                  xs)))
    (apply oldformat xs)))

(advice-add #'proced-format-args :around #'my-proced/remove-nixos-path-name)
#+END_SRC

***** Bindings

#+begin_src elisp
(map! :map proced-mode-map
      :n "/" #'proced-narrow
      :n "gr" #'proced)

(map! :map process-menu-mode-map
      :n "gr" #'list-processes)
#+end_src
** Projectile :PROJECTILE:
*** Config
**** Ignored Projects

Dont add packages inside ~~.emacs.d~ to projectile, as I often browse the source for a package,
but I dont want them added to my ~projectile-known-projects~.

#+BEGIN_SRC elisp
(use-package! projectile
  :init
  (setq projectile-ignored-projects '("~/"
                                      "/tmp"
                                      "~/.emacs.d/.local/straight/repos/")))
#+END_SRC

**** Scan directory for repositories

#+BEGIN_SRC elisp
(use-package! projectile
  :init
  (setq projectile-project-search-path '("~/Code/Dotfiles"
                                         "~/Code/Repositories"
                                         "~/Code/Projects"
                                         "~/Code/Tools"
                                         "~/Code/Meisterlabs"
                                         "~/Code/Meisterlabs/mindmeister-web/.worktrees"))
  :config
  ;; Auto discover when running switch project for the first time
  (add-transient-hook! 'counsel-projectile-switch-project
    (projectile-cleanup-known-projects)
    (projectile-discover-projects-in-search-path)))
#+END_SRC
** Documents :DOCUMENTS:
*** Pdf :PDF:
**** Config

***** TODO Fix midnight colors for doom-one theme

#+BEGIN_SRC elisp
;; Fix midnight colors for doom-one theme
(setq pdf-view-midnight-colors '("#BBC2CD" . "#282C34"))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map!
 :map pdf-occur-buffer-mode-map
 :gn [tab] (cmd! (pdf-occur-goto-occurrence t)))
#+END_SRC
*** Ebook :EBOOK:
**** Packages
***** [[https://depp.brause.cc/nov.el/][nov]]

Major mode for reading EPUBs in Emacs

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! nov)
#+END_SRC

****** Functions
******* Setup function

#+begin_src elisp
(defun my-nov/setup ()
  (setq line-spacing 5)
  (face-remap-add-relative 'variable-pitch :family "Liberation Serif" :height 1.4)
  (setq visual-fill-column-center-text t)
  (setq visual-fill-column-width (+ nov-text-width 25))
  (visual-fill-column-mode t))
#+end_src

****** Config

#+BEGIN_SRC elisp
(use-package! nov
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (setq nov-text-width 75)
  (setq nov-save-place-file (f-join doom-local-dir "nov-places"))
  :config
  (add-hook 'nov-mode-hook 'my-nov/setup))
#+END_SRC

** Spell Checking
*** Packages
**** [[https://github.com/btford/write-good][btford/write-good]] :LINTING:DOOM:

Naive linter for english prose.

***** Config
****** Disable doom defined hooks for writegood mode

#+BEGIN_SRC elisp
(use-package! writegood-mode
  :hook 'nil)
#+END_SRC

****** Disable ~writegood-mode~ with ~spell-fu~ mode

#+BEGIN_SRC elisp
(defun +spell-fu/activate-writegood-mode-hook ()
  "Toggle writegood mode with spell-fu mode."
  (cond
   (spell-fu-mode (writegood-mode 1))
   (t (writegood-mode -1))))

(add-hook! 'spell-fu-mode-hook :after #'+spell-fu/activate-writegood-mode-hook)
#+END_SRC
**** Flyspell
***** Defer flyspell until first ~evil-insert-state~

Flyspell most of the time is an annoyance when opening a file just for reading.
I mostly only need it when writing text (sometimes when reviewing, but then I can toggle it manually).

So I defer it until the first text change has been done (or the first insert state).
I've tried it on the ~first-change-hook~, but that is also affected by changing todo states for example in ~org-mode~.

#+begin_src elisp
(defun +flyspell/load-after-first-insert--activate ()
  "Turns on flyspell after the first buffer change or evil-insert state."
  (remove-hook! '(first-change-hook evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert)
  (remove-hook! '(first-change-hook evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert--activate)
  (spell-fu-mode 1))

(defun +flyspell/load-after-first-insert ()
  "Turns on flyspell after the first buffer evil-insert state.
Exception for org mode when the header property \"DISABLE_SPELLCHECKER\" is set."
  (cond ((and (equal major-mode 'org-mode) (+org/get-global-property "DISABLE_SPELLCHECKER")) nil)
        (t (add-hook! '(evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert--activate))))

(defmacro my-spelling@remove-doom-spell-hooks (package mode)
  `(use-package! ,package
     :init
     (remove-hook! '(org-mode-hook
                     markdown-mode-hook
                     TeX-mode-hook
                     rst-mode-hook
                     mu4e-compose-mode-hook
                     message-mode-hook
                     text-mode-hook
                     git-commit-mode-hook)
       ,mode)))

(my-spelling@remove-doom-spell-hooks spell-fu #'spell-fu-mode)
(my-spelling@remove-doom-spell-hooks flyspell #'flyspell-mode)
(my-spelling@remove-doom-spell-hooks writegood-mode #'writegood-mode)

(add-hook! '(org-mode-hook markdown-mode-hook) :local #'+flyspell/load-after-first-insert)
#+end_src
** Flycheck :LINTING:
*** Config
**** Disabled Checkers
***** Elisp

Disable flycheck completely in org-src-mode, the hints are not useful.

Source: https://github.com/adimit/config/blob/74a7fc0acaf82e18d0ca4bd0ca6e539ff93b13bc/emacs/main.org#checkdoc-in-org-src-edit-buffers

#+begin_src elisp
(add-hook 'org-src-mode-hook (lambda () (flycheck-mode -1)))
#+end_src

***** Nim

#+BEGIN_SRC elisp
(add-hook! 'nim-mode-hook :append
  (setq-local flycheck-disabled-checkers '(nim-nimsuggest))
  (flycheck-select-checker 'nim-1-6-0))
#+END_SRC
** Completion :COMPLETION:
*** Packages
**** [[https://github.com/abo-abo/swiper][ivy / counsel]]
***** Actions
****** Search from ~counsel-find-file~

#+begin_src elisp
(defun my-counsel/search-from-find-file-counsel (x)
  "Function docstring"
  (let ((default-directory (if (f-dir? x) x (f-dirname x))))
    (+default/search-cwd)))

(after! ivy
 (setq my-counsel::action:search-from-find-file
  '(("s" my-counsel/search-from-find-file-counsel "Search in directory")))
 (ivy-add-actions 'counsel-find-file my-counsel::action:search-from-find-file))
#+end_src
***** Functions
****** Project File Jump

#+BEGIN_SRC elisp
(defun my-counsel|project-file-jump (x)
  "Jump to file in project"
  (interactive)
  (counsel-file-jump nil (f-join (projectile-project-root) x)))
#+END_SRC

****** External Drives

#+BEGIN_SRC elisp
(defun my-counsel|mounted-drives ()
  "Counsel of mounted drives."
  (interactive)
  (let* ((path (f-join "/run/media/" (user-login-name)))
         (entries (f-entries path)))
    (pcase (length entries)
      (0 (user-error "Error: No mounted devices!"))
      (1 (counsel-find-file (car entries)))
      (_ (counsel-find-file path)))))
#+END_SRC

****** Search project for symbol at point :FIX:ADVICE:

Doom doesn't double escape ~|~ which is needed for ~rg~.
Original [[file:~/.emacs.d/modules/config/default/autoload/search.el::defun +default/search-project-for-symbol-at-point][+default/search-project-for-symbol-at-point]]

I've also removed the feature checking, since I ony use ~ivy~.

#+begin_src elisp
(defun my-ivy|search-project-for-symbol-at-point (symbol dir)
  "Search current project for symbol at point.
If prefix ARG is set, prompt for a known project to search from."
  (interactive
   (list (->> (or (doom-thing-at-point-or-region) "")
              (rxt-quote-pcre)
              (s-replace-all '(("|" . "\\|"))))
         (let ((projectile-project-root nil))
           (if current-prefix-arg
               (if-let (projects (projectile-relevant-known-projects))
                   (completing-read "Search project: " projects nil t)
                 (user-error "There are no known projects"))
             (doom-project-root default-directory)))))
  (+ivy/project-search nil symbol dir))

(advice-add #'+default/search-project-for-symbol-at-point :override #'my-ivy|search-project-for-symbol-at-point)
#+end_src

****** Occur modify for last search

In the occur buffer I quickly want to change the text I searched for.
With these functions I can quickly do an ~evil-ex~ replacement or a multicursor edit.

#+begin_src elisp
(defun my-ivy-occur|evil-ex-last-search ()
  "Evil Ex search for the occur grepped text."
  (interactive)
  (let ((str (ivy-state-text ivy-occur-last)))
    (my-evil/ex-search-str str)
    (evil-ex "%s//")))

(defun my-ivy-occur|evil-mutliedit-last-search ()
  "Evil Ex search for the occur grepped text."
  (interactive)
  (require 'evil-multiedit)
  (ivy-wgrep-change-to-wgrep-mode)
  (let ((str (ivy-state-text ivy-occur-last)))
    (when (search-forward-regexp str)
      (forward-char (- (- (length str) 1)))
      (setq evil-multiedit--dont-recall t)
      (evil-multiedit--start-regexp str (point-min) (point-max)))))
#+end_src

***** Config
****** Always show actions in hydra.

#+BEGIN_SRC elisp
(setq ivy-read-action-function #'ivy-hydra-read-action)
#+END_SRC

****** Banish mouse cursor :HACK:

The cursor will steal the focus from ivy-posframe, breaking ivy completely...

This option moves the mouse cursor to 0x0,
which is really unacceptable, but works for now.

#+BEGIN_SRC elisp
(setq posframe-mouse-banish t)
#+END_SRC

***** Bindings

****** Minibuffer

#+BEGIN_SRC elisp
(map!
 :after ivy
 :map ivy-minibuffer-map
  "<s-return>" 'ivy-call
  "<C-tab>" 'minibuffer-complete
  "<C-return>" 'ivy-immediate-done
  "M-m" 'ivy-mark
  "M-SPC" 'ivy-restrict-to-matches)
#+END_SRC

****** Occur Mode

#+BEGIN_SRC elisp
(map! :map ivy-occur-mode-map
      :gni "RET" #'ivy-occur-press-and-switch)
#+END_SRC
**** [[https://github.com/raxod502/prescient.el][company-prescient]]

Better sorting for company

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! prescient)
(package! company-prescient)
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! prescient
  :config
  (prescient-persist-mode 1))

(use-package! company-prescient
  :after company
  :config
  (company-prescient-mode 1))
#+END_SRC
**** [[https://company-mode.github.io/][company]]
***** Functions
****** Complete line for all project files

#+begin_src elisp
(cl-defun my-grep/search-in-project (str &optional (dir default-directory))
  (let ((default-directory (my-file/project-root dir)))
    (->> (shell-command-to-string (s-join " " (list "rg" "--no-filename"
                                                    (concat "\"" (shell-quote-argument str) "\""))))
         (counsel--split-string)
         (-uniq)
         (-map #'s-trim-left))))

(defun my-company/complete-line-project (command &optional arg &rest ignored)
  "Complete line in all project files."
  (interactive (list 'interactive))
  (require 'company)
  (pcase command
    (`interactive (company-begin-backend 'my-company/complete-line-project))
    (`prefix      (company-grab-line "^[\t\s]*\\(.+\\)" 1))
    (`candidates  (my-grep/search-in-project arg))))
#+end_src


****** Complete line for all buffers

Complete a whole line with all lines from buffers matching the current major-mode.

#+BEGIN_SRC elisp
(defun my-company/list-buffers-with-mode (modes)
  "Get all buffers that match MODES"
  (--filter
   (with-current-buffer it (-contains? (doom-enlist modes) major-mode))
   (buffer-list)))

(defun my-company/list-buffers-with-major-mode ()
  "Get all buffers matching the current major-mode
Has built in aliases"
  (let ((javascript-modes (list 'rjsx-mode 'js2-mode)))
    (pcase major-mode
      ('rjsx-mode
       (my-company/list-buffers-with-mode javascript-modes))
      ('js2-mode
       (my-company/list-buffers-with-mode javascript-modes))
      (_
       (my-company/list-buffers-with-mode major-mode)))))

(defun my-company/complete-line-all-buffers (command &optional arg &rest ignored)
  "`company-mode' completion backend that completes whole-lines, akin to vim's
C-x C-l."
  (interactive (list 'interactive))
  (require 'company)
  (pcase command
    (`interactive (company-begin-backend 'my-company/complete-line-all-buffers))
    (`prefix      (company-grab-line "^[\t\s]*\\(.+\\)" 1))
    (`candidates
     (all-completions
      arg
      (funcall (-compose
                #'-uniq
                #'-flatten
                (lambda (xs)
                  (--map (with-current-buffer it
                           (split-string
                            (replace-regexp-in-string
                             "^[\t\s]+" ""
                             (buffer-substring-no-properties (point-min) (point-max)))
                            "\\(\r\n\\|[\n\r]\\)" t)) xs)))
               (my-company/list-buffers-with-major-mode))))))
#+END_SRC

Bindings

#+BEGIN_SRC elisp
(map!
 (:prefix "C-x"
   :i "C-p" #'my-company/complete-line-project
   :i "C-l" #'my-company/complete-line-all-buffers
   :i "C-." #'+company/whole-lines))
#+END_SRC

***** Config
****** Sort company by occurrence
:PROPERTIES:
:SOURCE:   [[https://github.com/company-mode/company-mode/issues/52][{Proposal} Improve company-dabbrev candidate ordering · Issue #52 · company-mode/company-mode]]
:END:

#+BEGIN_SRC elisp
(setq company-transformers '(company-sort-by-occurrence)
      company-idle-delay 0.5)
#+END_SRC

** LSP
*** Config
**** Guess root

When working in nested git worktrees, lsp should infer the root by using projectile, by finding the closest ~.projectile~ file.
This file is always created when [[*Create worktree workspace][creating a worktree]].

#+begin_src elisp
(setq lsp-auto-guess-root t)
#+end_src

**** Disable presets

All are these are distracting and not helpful.

- Removes all popup UIs
- Remove signature message
- Remove lsp flycheck

#+BEGIN_SRC elisp
(use-package! lsp
  :config
  (setq lsp-eldoc-render-all nil
        lsp-eldoc-enable-hover nil
        lsp-eldoc-enable-signature-help nil
        lsp-eldoc-prefer-signature-help nil
        lsp-inhibit-message t

        lsp-enable-file-watchers nil

        lsp-eldoc-enable-hover nil
        lsp-signature-auto-activate nil
        lsp-signature-render-documentation nil
        lsp-signature-doc-lines 1

        lsp-diagnostics-provider :none
        lsp-modeline-diagnostics-enable nil
        lsp-modeline-code-actions-enable nil

        lsp-highlight-symbol-at-point nil
        lsp-prefer-flymake nil

        lsp-on-idle-hook nil))
#+END_SRC

**** Fix flycheck for js buffers :FIX:

LSP manually disables all checkers and chooses it's own.
This way you can't add checkers after your regular hooks like ~js2-hook~.
So I fix the checker manually for each mode after lsp was loaded.

#+BEGIN_SRC elisp
(after! lsp-mode
  (remove-hook 'lsp-mode-hook #'+lsp-init-flycheck-or-flymake-h))

(defun +js/fix-checker ()
  "Fix LSP overwritten checkers."
  (interactive)
  (when (-contains? '(js2-mode rjsx-mode) major-mode)
    (flycheck-select-checker 'javascript-eslint)))

(add-hook 'lsp-mode-hook #'+js/fix-checker)
#+END_SRC
** Snippets :SNIPPETS:
*** Overrides

Add the snippet key to to the snippet prompt so I know it for next time.
There is no api for it, so I just override the ~yas--prompt-for-template~ function.

#+begin_src elisp
(after! yasnippet
  (defun yas--prompt-for-template (templates &optional prompt)
    "Interactively choose a template from the list TEMPLATES.

TEMPLATES is a list of `yas--template'.

Optional PROMPT sets the prompt to use."
    (when templates
      (setq templates
            (sort templates #'(lambda (t1 t2)
                                (< (length (yas--template-name t1))
                                   (length (yas--template-name t2))))))
      (cl-some (lambda (fn)
                 (funcall fn (or prompt "Choose a snippet: ")
                          templates
                          (lambda (x) (concat (yas--template-name x) " "
                                              (let ((key (yas--template-key x)))
                                                (when (not (string= key (yas--template-name x)))
                                                  (format "(%s)" (yas--template-key x))))))))
               yas-prompt-functions))))
#+end_src

*** Functions
**** Expand snippet by name
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/10211730/insert-yasnippet-by-name][emacs - Insert yasnippet by name - Stack Overflow]]
:END:

#+BEGIN_SRC elisp
(defun my-snippets/insert-by-name (name)
  (require 'noflet)
  (noflet ((dummy-prompt
            (prompt choices &optional display-fn)
            (declare (ignore prompt))
            (or (cl-find name choices :key display-fn :test #'string=)
                (throw 'notfound nil))))
    (let ((yas-prompt-functions '(dummy-prompt)))
      (catch 'notfound
        (yas-insert-snippet t)))))
#+END_SRC

**** Use last src language
:PROPERTIES:
:SOURCE:   [[https://github.com/tecosaur/emacs-config/blob/0c50e2a651e8903a922a60acf701d4a6ba0e1d29/config.org][emacs-config/config.org at 0c50e2a651e8903a922a60acf701d4a6ba0e1d29 · tecosaur/emacs-config]]
:END:

Used with [[file:snippets/org-mode/src::`%`$0][src snippet]] to auto fill the language from the previously used src language.

#+BEGIN_SRC elisp
(defun my-snippets/org-src-lang ()
  "Try to find the current language of the src/header at point.
Return nil otherwise."
  (save-excursion
    (pcase
        (downcase
         (buffer-substring-no-properties
          (goto-char (line-beginning-position))
          (or (ignore-errors (1- (search-forward " " (line-end-position))))
              (1+ (point)))))
      ("#+property:"
       (when (re-search-forward "header-args:")
         (buffer-substring-no-properties
          (point)
          (or (and (forward-symbol 1) (point))
              (1+ (point))))))
      ("#+begin_src"
       (buffer-substring-no-properties
        (point)
        (or (and (forward-symbol 1) (point))
            (1+ (point)))))
      ("#+header:"
       (search-forward "#+begin_src")
       (my-snippets/org-src-lang))
      (_ nil))))

(defun my-snippets/org-last-src-lang ()
  (save-excursion
    (beginning-of-line)
    (when (search-backward "#+begin_src" nil t)
      (my-snippets/org-src-lang))))
#+END_SRC
*** Config

**** Disable doom snippets / load custom snippets

#+BEGIN_SRC elisp
(use-package! yasnippet
  :init
  (require 'doom-snippets nil t))
#+END_SRC
** Project Boilerplate
*** [[https://github.com/chrisbarrett/skeletor.el#specifying-substitutions][skeletor]]

**** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! skeletor)
#+END_SRC

**** Config

#+BEGIN_SRC elisp
(use-package! skeletor
  :config
  (setq skeletor-project-directory "~/Code/Projects"))
#+END_SRC

** Search (Grep) :SEARCH:

*** Bindings

**** Wgrep Mode

#+begin_src elisp
(map!
 :map (wgrep-mode-map ivy-occur-grep-mode-map)
 :n [return] #'compile-goto-error

 :localleader
 :desc "Remove line" "d" (cmd! (let ((inhibit-read-only t))
                                 (my-buffer/delete-current-line))))
#+end_src

** Web :WEB:
*** [[https://github.com/skeeto/elfeed][Elfeed]] :DOOM:
**** Packages
***** DISABLED [[https://github.com/algernon/elfeed-goodies][algernon/elfeed-goodies: Various goodies for Elfeed]] :DISABLED:

No need, screws with entry buffer position and header display...

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! elfeed-goodies :disable t)
#+end_src

**** Functions
***** Open elfeed

#+BEGIN_SRC elisp
(defun my-elfeed|open ()
  (interactive)
  (unless (get-buffer "*elfeed-search*")
    (setq elfeed-search-filter +rss:default-search-filter))
  (elfeed)
  (my-rss|hydra/body))
#+END_SRC

***** Filter by unread

#+BEGIN_SRC elisp
(defun my-rss/filter-by-unread ()
  "Show elfeed articles tagged with unread"
  (interactive)
  (elfeed-search-set-filter "@6-months-ago +unread"))
#+END_SRC

***** Visit entry DWIM

Open the current entry:
- With the browser
- Or if it's a youtube feed, open with [[*Elfeed MPV][mpv]]

#+BEGIN_SRC elisp
(defun my-rss|visit-entry-dwim ()
  "Either open the current entry in eww or play it in mpv."
  (interactive)
  (message "")
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (patterns my-rss:visit-entry-mpv-pattern))
    (while (and patterns (not (string-match (car my-rss:visit-entry-mpv-pattern) (elfeed-entry-link entry))))
      (setq patterns (cdr patterns)))
    (if patterns
        (my-rss:play-entry-with-mpv)
      (if (eq major-mode 'elfeed-search-mode)
          (elfeed-search-browse-url)
        (elfeed-show-visit)))))
#+END_SRC

***** Visit entry with MPV

#+BEGIN_SRC elisp
(defvar my-rss:visit-entry-mpv-pattern
  '("youtu\\.?be")
  "List of regexp to match against elfeed entry link to know
whether to use mpv to visit the link.")

(defun my-rss:play-entry-with-mpv ()
  "Play entry link with mpv."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (url (elfeed-entry-link entry)))
    (my-shell/mpv-youtube-url url)))
#+END_SRC

***** Visit entry with EWW

#+BEGIN_SRC elisp
(defun my-rss::visit-entry-eww ()
  "Open the current entry with eww."
  (interactive)
  (add-hook 'eww-after-render-hook 'eww-readable nil t)
  (let ((buffer (save-window-excursion
                  (eww (elfeed-entry-link elfeed-show-entry))
                  (current-buffer))))
    (switch-to-buffer buffer)))
#+END_SRC

***** Pretty elfeed

#+BEGIN_SRC elisp
(defun my-rss/wrap-entry ()
  "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
  (let ((inhibit-read-only t)
        (inhibit-modification-hooks t))
    (setq-local truncate-lines nil)
    (setq-local shr-width 100)
    (setq-local +zen-text-scale 0.9)
    (mixed-pitch-mode)
    (writeroom-mode)
    (set-buffer-modified-p nil)))

(add-hook 'elfeed-show-mode-hook #'my-rss/wrap-entry)
#+END_SRC

***** INACTIVE Update feeds when saving org-elfeed file :ORG_MODE:

When I save the elfeed org-mode file I want to automatically update the feed list.
Update function taken from [[file:~/.emacs.d/.local/straight/repos/elfeed-org/elfeed-org.el::rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id)][elfeed package]].

⚠ Disabled for now as it leaks to other modes

#+BEGIN_SRC elisp :tangle no
(defun my-rss/update-feeds-on-save ()
  (when (and (eq major-mode 'org-mode)
             (string= buffer-file-name (car rmh-elfeed-org-files))))
  (require 'elfeed)
  (rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id))

(add-hook! 'after-save-hook #'my-rss/update-feeds-on-save)
#+END_SRC
***** Capture entry :ORG_MODE:

#+BEGIN_SRC elisp
(defun my-rss::capture/stringify-entry (entry)
  (let ((title (->> (elfeed-entry-title entry)
                    ;; Remove braces, they're just confusing to org links
                    (s-replace "[" "")
                    (s-replace "]" "")))
        (url (elfeed-entry-link entry))
        (author (->> (elfeed-meta entry :authors)
                     car
                     ((lambda (x) (plist-get x :name)))))
        (tags (-some--> (elfeed-entry-tags entry)
                (-remove-item 'unread it)
                (-map #'symbol-name it)
                (s-join ":" it)
                (s-wrap it ":" ":"))))
    (template "[[<<url>>][<<author>> - <<title>>]] <<(when tags tags)>>")))

(defun my-rss::capture|capture ()
  "Capture current entry of elfeed."
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                   elfeed-show-entry
                 (elfeed-search-selected :single)))
         (org-entry (my-rss::capture/stringify-entry entry)))
       (kill-new org-entry)
       (if (s-contains? org-entry "youtube.com")
           (org-capture nil "ew")
        (org-capture nil "er"))))
#+END_SRC

***** Hydra

#+BEGIN_SRC elisp
(defun my-rss/toggle-filter (tag)
  "Toggle elfeed filter TAG or append to filters if non-existent."
  (->> (or (-when-let* (((_ modi) (s-match (t! "\\_<\\([+-]\\)<<tag>>\\_>") elfeed-search-filter))
                        (new-modi (if (string= modi "+") "-" "+")))
             (s-replace-regexp (t! "\\_<\\<<modi>><<tag>>\\_>") (t! "<<new-modi>><<tag>>") elfeed-search-filter))
           (s-append (t! " +<<tag>>") elfeed-search-filter))
       (--tap (progn (setq elfeed-search-filter it)
                     (elfeed-search-update--force)
                     (-log (t! "Filter changed to: <<it>>"))))))

(defun my-rss|counsel-toggle-filter (&optional arg)
  "Toggles a filter in elfeed."
  (interactive "P")
  (ivy-read (t! "Filter: <<elfeed-search-filter>>") (elfeed-db-get-all-tags)
            :action #'my-rss/toggle-filter
            :caller #'my-rss|counsel-toggle-filter))

(defhydra my-rss|hydra ()
   "Elfeed"
   ("j" (evil-next-line) "Next item" :column "Navigate")
   ("k" (evil-previous-line) "Previous item")
   ("t" (my-rss|counsel-toggle-filter) "Tags" :column "Filter")
   ("0" (elfeed-search-set-filter "@2-weeksago +unread") "Unread" :column "Favorites")
   ("f" (elfeed-search-set-filter "@2-weeksago +unread -YOUTUBE -REDDIT") "Feeds")
   ("y" (elfeed-search-set-filter "@2-weeksago +unread +YOUTUBE") "Youtube")
   ("e" (elfeed-search-set-filter "@2-weeksago +unread +REDDIT =emacs") "Reddit: Emacs")
   ("n" (elfeed-search-set-filter "@2-weeksago +unread +REDDIT =nixos") "Reddit: Nixos")
   ("U" (elfeed-update) "Update" :column "actions")
   ("u" (elfeed-search-untag-all-unread) "Mark as unread")
   ("s" (elfeed-db-save) "Save DB")
   ("v" (my-rss|visit-entry-dwim) "Visit")
   ("q" nil "Quit" :color blue))
#+END_SRC
**** Config
***** elfeed-org file

#+BEGIN_SRC elisp
(setq rmh-elfeed-org-files (list (+org/expand-org-file-name "Elfeed/Elfeed.org")))
#+END_SRC

***** Disable sliced images

These don't work if you have a big line-height.

#+BEGIN_SRC elisp
(setq +rss-enable-sliced-images nil)
#+END_SRC

***** Default search

#+BEGIN_SRC elisp
(setq +rss:default-search-filter "@2-week-ago +unread -YOUTUBE")
(setq-default elfeed-search-filter +rss:default-search-filter)
#+END_SRC

**** Bindings
***** Search Mode Bindings

#+BEGIN_SRC elisp
(map!
 :after elfeed
 :map elfeed-search-mode-map
 :gn "r" #'elfeed-update
 (:prefix-map ("g" . "Go")
  :desc "Youtube" :gn "y" (cmd! (elfeed-search-set-filter "@2-week-ago +YOUTUBE +unread"))
  :desc "Normal"  :gn "n" (cmd! (elfeed-search-set-filter "@2-week-ago -YOUTUBE +unread"))
  :desc "Month"   :gn "m" (cmd! (elfeed-search-set-filter "@1-month-ago +unread"))))
#+END_SRC

***** Show Mode Bindings

#+BEGIN_SRC elisp
(map!
 :after elfeed
 :map elfeed-search-mode-map
 :gn "r" #'elfeed-update)
#+END_SRC

***** LocalLeader

#+BEGIN_SRC elisp
(map! :map (elfeed-search-mode-map elfeed-show-mode-map)
      :localleader
      :desc "Filter Hydra" "f" #'my-rss|hydra/body
      :desc "Capture"      "c" #'my-rss::capture|capture
      :desc "Open Eww"     "o" #'my-rss::visit-entry-eww
      :desc "Visit"        "v" #'my-rss|visit-entry-dwim
      (:prefix-map ("s" . "Search")
       :desc "Unread" "u" #'my-rss/filter-by-unread))
#+END_SRC
*** DISABLED IRC :DOOM:

**** Config

#+BEGIN_SRC elisp :tangle no
(after! circe
  (set-irc-server! "chat.freenode.net"
    `(:tls t
      :port 6697
      :nick "floscr"
      :sasl-username ,(+pass-get-user "Irc/freenode.net")
      :sasl-password (lambda (&rest _) (+pass-get-secret "Irc/freenode.net"))
      :channels ("#emacs" "#nixos"))))
#+End_SRC
*** [[https://www.gnu.org/software/emacs/manual/html_mono/eww.html][EWW web browser]]
**** Config
***** Pretty buffer setup

#+begin_src elisp
(defun my-eww*pretty-buffer-setup ()
  "Function docstring"
  (setq-local truncate-lines t)
  (setq-local shr-width 120)
  (setq fill-column 120)
  (setq-local visual-fill-column-center-text t)
  (visual-line-mode 1)
  (visual-fill-column-mode 1))

(add-hook! 'eww-mode-hook #'my-eww*pretty-buffer-setup)
#+end_src

***** Set the max page width

#+BEGIN_SRC elisp
(setq shr-width 100)
#+END_SRC

** Calendar :ORGANIZATION:DOOM:
*** Functions
**** Filtered Calendars
***** Personal (Without Work)

#+BEGIN_SRC elisp
(defun my-calendar::filtered|personal (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "-WORK-HIDE_CALENDAR")))
      (call-interactively #'=calendar)))
#+END_SRC

***** Personal (Just Family)

#+BEGIN_SRC elisp
(defun my-calendar::filtered|just-family (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "+FAMILY|+BIRTHDAY")))
      (call-interactively #'=calendar)))
#+END_SRC

***** Personal (Just Birthdays)

#+BEGIN_SRC elisp
(defun my-calendar::filtered|birthdays (&rest args)
  (interactive)
  (let ((org-agenda-files `(,(+org/expand-org-file-name "Main/contacts.org")))
        (org-agenda-skip-function '(+org/agenda-skip-without-match "+BIRTHDAY")))
      (call-interactively #'=calendar)))
#+END_SRC

***** Personal (Without Family)

#+BEGIN_SRC elisp
(defun my-calendar::filtered|no-family (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "-FAMILY-WORK-HIDE_CALENDAR")))
      (call-interactively #'=calendar)))
#+END_SRC

***** Work

#+BEGIN_SRC elisp
(defun my-calendar::filtered|work (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "+WORK-HIDE_CALENDAR")))
      (call-interactively #'=calendar)))
#+END_SRC
*** Config
**** Custom Holidays (Austrian)

Emacs comes with a lot of custom calendars that I don't want.
This is mostly copied from [[https://thenybble.de/projects/german-emacs-calendar.html][How to set up a german emacs calendar]].

#+begin_src elisp
(use-package! calfw
  :config
  (setq my-calendar::holidays:general
        '((holiday-fixed 1 1 "New Years")
          (holiday-fixed 5 1 "1st Mai")))
  (setq my-calendar::holidays:austria
        `((holiday-fixed 1 6 "Heilige drei Könige")
          (holiday-fixed 5 1 "Staatsfeiertag")
          (holiday-fixed 8 15 "Mariä Himmelfahrt")
          (holiday-fixed 10 26 "Nationalfeiertag")
          (holiday-fixed 11 1 "Allerheiligen")
          (holiday-fixed 12 8 "Mariä Empfängnis")
          (holiday-fixed 12 24 "Weihnachten")
          (holiday-fixed 12 25 "Christtag")
          (holiday-fixed 12 26 "Stefanitag")
          (holiday-easter-etc -2 "Karfreitag")
          (holiday-easter-etc 0 "Ostersonntag")
          (holiday-easter-etc 1 "Ostermontag")
          (holiday-easter-etc 39 "Christi Himmelfahrt")
          (holiday-easter-etc 49 "Pfingstsonntag")
          (holiday-easter-etc 50 "Pfingstmontag")
          (holiday-easter-etc 60 "Fronleichnam")))
  (setq calendar-holidays (append
                           my-calendar::holidays:general
                           my-calendar::holidays:austria
                           holiday-solar-holidays)))
#+end_src



***** General Holidays

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq general-holidays
        '((holiday-fixed 1 1 "New Years")
          (holiday-fixed 5 1 "1st Mai"))))
#+END_SRC

***** Austrian Holidays

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq austrian-holidays
        `((holiday-fixed 1 6 "Heilige drei Könige")
          (holiday-fixed 5 1 "Staatsfeiertag")
          (holiday-fixed 8 15 "Mariä Himmelfahrt")
          (holiday-fixed 10 26 "Nationalfeiertag")
          (holiday-fixed 11 1 "Allerheiligen")
          (holiday-fixed 12 8 "Mariä Empfängnis")
          (holiday-fixed 12 24 "Weihnachten")
          (holiday-fixed 12 25 "Christtag")
          (holiday-fixed 12 26 "Stefanitag")
          ;; variable
          (holiday-easter-etc -2 "Karfreitag")
          (holiday-easter-etc 0 "Ostersonntag")
          (holiday-easter-etc 1 "Ostermontag")
          (holiday-easter-etc 39 "Christi Himmelfahrt")
          (holiday-easter-etc 49 "Pfingstsonntag")
          (holiday-easter-etc 50 "Pfingstmontag")
          (holiday-easter-etc 60 "Fronleichnam"))))
#+END_SRC

***** Set calendars

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq calendar-holidays
        (append
          general-holidays
          austrian-holidays
          holiday-solar-holidays)))
#+END_SRC

**** General

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq calendar-week-start-day 1)
  (setq calendar-time-display-form
        '(24-hours ":" minutes (and time-zone (concat " (" time-zone ")"))))
  (setq calendar-abbrev-length 2))
#+END_SRC
** Calc
*** Config
**** Additional Units

#+BEGIN_SRC elisp
(setq math-additional-units '((GB "1024 * MiB" "Giga Byte")
                              (MB "1024 * KiB" "Mega Byte")
                              (KB "1024 * B" "Kilo Byte")
                              (B nil "Byte")))
#+END_SRC
** Terminal
*** [[https://www.emacswiki.org/emacs/ComintMode][Comint]]
**** Bindings
***** Allow evil enter anywhere :FIX:

Fix for comint mode, throwing an error when pressing enter in the middle of the line.

#+BEGIN_EXAMPLE
error in process filter: End of buffer
#+END_EXAMPLE

#+BEGIN_SRC elisp
(map!
 :after comint
 :map comint-mode-map
 :ni "RET" (cmd! (comint-send-input nil t))
 :n "<C-backspace>" #'comint-clear-buffer)
#+END_SRC
*** [[https://www.gnu.org/software/emacs/manual/html_mono/eshell.html][Eshell]]
**** Functions
***** Syntax highlighted cat

#+BEGIN_SRC elisp
(defun my-eshell/colorized-cat (file)
  "Like `cat' but output with Emacs syntax highlighting."
  (with-temp-buffer
    (insert-file-contents file)
    (let ((buffer-file-name file))
      (delay-mode-hooks
        (set-auto-mode)
        (if (fboundp 'font-lock-ensure)
            (font-lock-ensure)
          (with-no-warnings
            (font-lock-fontify-buffer)))))
    (buffer-string)))
#+END_SRC

**** Config
***** COMMENT Custom Aliases

#+BEGIN_SRC elisp
(setq my-eshell:aliases
  '(("q"      "exit")
    ("cat"    "my-eshell/colorized-cat $1")
    ("f"      "find-file $1")
    ("bd"     "eshell-up $1")
    ("rg"     "rg --color=always $*")
    ("ag"     "ag --color=always $*")
    ("l"      "ls -lh")
    ("ll"     "ls -lah")
    ("gs"     "git status")
    ("groot"  "cd (projectile-project-root)")
    ("gc"     "git commit")
    ("grha"   "git reset --hard; git clean -f -d")
    ("clear"  "clear-scrollback")))

(mapcar (lambda (alias)
          (set-eshell-alias! (car alias) (cadr alias)))
        my-eshell:aliases)
#+END_SRC

** Org Mode
*** Custom Packages
**** Indirect Narrow Buffers

Open org tasks in an indirect popup that can be closed via =C-c C-c=.
The indirect buffer is narrowed to the current item.
This makes visiting org tasks much more focused, without having to widen the main buffer every time.

Known Issues:
- this popup blocks the =org-todo= popup
- The =C-c C-c= binding overrides the clocking binding

***** Config

#+BEGIN_SRC elisp
(set-popup-rule! "^\\*Org Indirect" :side 'bottom :size 0.35 :quit t :ttl nil :select t :autosave)
#+END_SRC

***** Minor Mode

#+BEGIN_SRC elisp
(defvar my-org-indirect:window-mode-map (make-sparse-keymap))

(define-minor-mode my-org-indirect-window-mode
  "Open org headlines in an indirect window buffer."
  :keymap my-org-indirect:window-mode-map)
#+END_SRC

***** Bindings

#+begin_src elisp
(map! :map my-org-indirect:window-mode-map
      "C-c C-c" #'my-org-indirect|save-and-kill-window
      "C-c C-k" #'kill-buffer-and-window
      :localleader
      :desc "Show original" "+" #'my-org-indirect|show-original)
#+end_src

***** Advices
****** Close window after refiling

#+BEGIN_SRC elisp :tangle no
(defadvice! +org/org-refile-close-indirect-window (&rest _)
  "Close indirect buffer windows after refiling them."
  :after '(org-refile)
  (when (my-org-indirect-window-mode)
    (kill-buffer-and-window)))
#+END_SRC

***** Functions
****** Main

#+BEGIN_SRC elisp
(cl-defun my-org-indirect|narrow-subtree-indirect (&key visit-fn goto-parent? (popup? t))
  "Narrow to an indirect buffer in a popup."
  (interactive)
  (-let* (((src-buffer heading-text)
           (save-window-excursion
             (save-excursion
               (progn
                 (when visit-fn (funcall visit-fn))
                 ;; save-window-excursion cancels org-mode being fully loaded
                 ;; this leads to the indirect buffer not knowing where the source comes frome
                 ;; and the org cycle methods not working
                 (org-mode)
                 (list
                  (current-buffer)
                  (+org/org-heading-text))))))
          (dst-buffer-name (template "*Org Indirect <<(buffer-name src-buffer)>> <<heading-text>>*"))
          (existing-buffer (--find (s-starts-with? dst-buffer-name (buffer-name it)) (buffer-list))))
    (cond
     (existing-buffer
      (if popup?
          (pop-to-buffer (buffer-name existing-buffer))
        (switch-to-buffer buffer)))
     (t
      ;; Cleanup old indirect buffers
      (kill-matching-buffers "^\\*Org Indirect.*" nil t)
      (with-current-buffer src-buffer
        (let ((buffer (clone-indirect-buffer dst-buffer-name nil)))
          (with-current-buffer buffer
            (widen)
            (if popup?
                (pop-to-buffer buffer)
              (switch-to-buffer buffer))
            (setq header-line-format "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")
            (save-excursion
              (when goto-parent?
                (+org|org-topmost-todo-element)
                ;; Show CHILDREN without content
                (org-global-cycle 4))
              (org-narrow-to-subtree))
            ;; When the item has subtrees show only the subtrees
            (ignore-errors
              (if (save-excursion (search-forward-regexp "^\\*" nil t))
                  (org-global-cycle 10)
                ;; Otherwise show contents but not the drawers
                (org-cycle 4)))
            (my-org-indirect-window-mode 1)
            (rename-buffer (concat
                            (buffer-name)
                            (int-to-string (point-min))
                            (int-to-string (point-max))
                            "*"))
            (evil-forward-word-begin 1)
            buffer)))))))
#+END_SRC

****** Window Killing

#+BEGIN_SRC elisp
(defun my-org-indirect|save-and-kill-window ()
  "Save the buffer and close the indirect buffer and window."
  (interactive)
  (save-buffer)
  (kill-buffer-and-window))

(defun my-org-indirect/kill-buffer-maybe ()
  "Kill the window/buffer if it's indirect.
For example when archiving a task, there would be an empty window left over."
  (when (s-match "^\\*Org Indirect" (buffer-name))
    (kill-buffer-and-window)))
#+END_SRC

****** Show original

#+BEGIN_SRC elisp
(defun my-org-indirect|show-original ()
  "Show the original buffer of the indirect window."
  (interactive)
  (doom/widen-indirectly-narrowed-buffer)
  (call-interactively #'+popup/raise)
  (my-org-indirect-window-mode -1)
  (setq header-line-format nil)
  (call-interactively #'evil-scroll-line-to-center))
#+END_SRC

****** Visiting Functions

#+BEGIN_SRC elisp
(defun my-org-indirect|clock-visit-entry (&optional arg)
  "Visit currently clocked org entry in a narrowed indirect buffer."
  (interactive "P")
  (let ((org-agenda-follow-indirect t))
    (my-org-indirect|narrow-subtree-indirect :visit-fn #'org-clock-goto
                                             :goto-parent? (not arg))))

(defun my-org-indirect|agenda-visit-entry (arg)
  "Visit agenda entry in a narrowed indirect buffer."
  (interactive "P")
  (my-org-indirect|narrow-subtree-indirect :visit-fn #'org-agenda-switch-to
                                           :goto-parent? (not arg)))
#+END_SRC

****** Inserting New Items

I want to create items directly from the org agenda.
For this I will visit the current item, move to the header and add a new child at the bottom.

#+BEGIN_SRC elisp
(defun my-org-indirect|add-entry ()
  (interactive)
  (with-current-buffer (my-org-indirect|narrow-subtree-indirect :visit-fn #'org-agenda-switch-to
                                                                :goto-parent? t)
    (widen)
    (call-interactively #'+org/insert-item-below)
    (org-narrow-to-element)))
#+END_SRC

*** Packages
**** [[https://github.com/astahlman/ob-async][ob-aysnc]] :DOOM:

ob-async enables asynchronous execution of org-babel src blocks via the ~:async~ property.

***** Config

#+BEGIN_SRC elisp
(use-package! ob-async
  :after org-babel)
#+END_SRC
**** [[https://github.com/org-roam/org-roam][org-roam]]

***** Configuration

****** Directories

#+BEGIN_SRC elisp
(setq org-roam-directory (+org/expand-org-file-name "Roam"))
(setq org-roam-db-location (+org/expand-org-file-name "org-roam.db"))
#+END_SRC
**** org-protocol

#+begin_src elisp
(use-package! org-protocol)
#+end_src
**** [[https://codeberg.org/theesm/ob-nix][org-babel: nix]]

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! ob-nix :recipe (:host codeberg :repo "theesm/ob-nix") :pin "76d71b37fb")
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! ob-nix)
#+END_SRC

**** org-babel
***** Functions

****** Eval clojure org blocks with ~babashka~ :CLOJURE:

Executes clojure with [[https://babashka.org/][Babashka]] and clojurescript with [[https://github.com/babashka/nbb][babashka/nbb]].
nbb needs to be installed via npm

#+begin_src sh :tangle no
npm i -g nbb
#+end_src

#+begin_src elisp
(with-eval-after-load 'ob-clojure
  (defcustom org-babel-clojure-backend nil
    "Backend used to evaluate Clojure code blocks."
    :group 'org-babel
    :type '(choice
            (const :tag "inf-clojure" inf-clojure)
            (const :tag "cider" cider)
            (const :tag "slime" slime)
            (const :tag "bb" bb)
            (const :tag "Not configured yet" nil)))

  (defun elisp->clj (in)
    (cond
     ((listp in) (concat "[" (s-join " " (mapcar #'elisp->clj in)) "]"))
     (t (format "%s" in))))

  (defun ob-clojure-eval-with-bb (expanded params)
    "Evaluate EXPANDED code block with PARAMS using babashka."
    (unless (executable-find "bb")
      (user-error "Babashka not installed"))
    (let* ((target (a-get params :target))
           (clojurescript? (string= target 'cljs))
           (stdin (let ((stdin (cdr (assq :stdin params))))
                    (when stdin
                      (elisp->clj
                       (org-babel-ref-resolve stdin)))))
           (input (cdr (assq :input params)))
           ;; Wrap clojurescript in print statement since nbb doesn't print the last result (like node)
           (expanded (if clojurescript?
                         (format "(print %s)" expanded)
                       expanded))
           (file (make-temp-file "ob-clojure-bb" nil nil expanded))
           (executable (or (cond
                            (clojurescript? (executable-find "nbb"))
                            (t "bb --prn"))
                           (user-error "Could not find executable for target %s!" target)))
           (command (concat (when stdin (format "echo %s | " (shell-quote-argument stdin)))
                            ;; nbb has different input params...
                            (if clojurescript?
                              (format "%s %s"
                                      executable
                                      (shell-quote-argument file))
                              (format "%s %s -f %s"
                                      executable
                                      (cond
                                       ((equal input "edn") "")
                                       ((equal input "text") "-i")
                                       (t ""))
                                      (shell-quote-argument file)))))
           (result (shell-command-to-string command)))
      (s-trim result)))

  (defun org-babel-execute:clojure (body params)
    "Execute a block of Clojure code with Babel."
    (unless org-babel-clojure-backend
      (user-error "You need to customize org-babel-clojure-backend"))
    (let* ((expanded (org-babel-expand-body:clojure body params))
           (result-params (cdr (assq :result-params params)))
           result)
      (setq result
            (cond
             ((eq org-babel-clojure-backend 'inf-clojure)
              (ob-clojure-eval-with-inf-clojure expanded params))
             ((eq org-babel-clojure-backend 'cider)
              (ob-clojure-eval-with-cider expanded params))
             ((eq org-babel-clojure-backend 'slime)
              (ob-clojure-eval-with-slime expanded params))
             ((eq org-babel-clojure-backend 'bb)
              (ob-clojure-eval-with-bb expanded params))))
      (org-babel-result-cond result-params
        result
        (condition-case nil (org-babel-script-escape result)
          (error result)))))

  (customize-set-variable 'org-babel-clojure-backend 'bb))

(add-hook 'org-mode-hook (lambda () (require 'ob-clojure)))
#+end_src

**** [[https://github.com/larstvei/ox-gfm][ox-gfm]]

Export org as github flavored markdown
- ~```~ Code blocks with syntax descriptor

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! ox-gfm)
#+END_SRC

***** Functions

**** org-src-mode

***** Bindings

****** Go to source buffer instead of dired

#+begin_src elisp
(defun my-org-src-mode/goto-source-marker-buffer (&optional other-window file-name)
  "Go to the source file for a org-src-mode buffer instead of dired."
  (interactive)
  (org-goto-marker-or-bmk org-src--beg-marker))

(map!
 :map org-src-mode-map
 :m "-"  #'my-org-src-mode/goto-source-marker-buffer)
#+end_src

*** Functions
**** Link at point

Use with destructuring like this

#+BEGIN_SRC elisp :tangle no
(-let (((&plist* title) (my-org/link-at-point)))
  title)
#+END_SRC

***** Should match these kind of links

- https://example.com
- [[https://example.com][With title: example.com]]
- [[my-attach:963ed071c1ebcdff38d72356899f974b.jpeg]]

***** Source

#+BEGIN_SRC elisp
(defun my-org/link-at-point ()
  "Returns a plist '(el url title) with title as nilable.
When no link is found return nil."
  (let ((link-info (org-element-context)))
    (when (eq (org-element-type link-info) 'link)
      (let* ((type (org-element-property :type link-info))
             (url (concat type ":" (org-element-property :path link-info)))
             (title (org-element-property :title link-info)))
        (when url
          (list :el link-info
                :url url
                :title title))))))
#+END_SRC

**** Jump to definition for tangled files

Take me to the literate source file when using ~find-function~ etc.

#+BEGIN_SRC elisp
(defadvice! +org|try-org-babel-tangle-jump-to-org (&optional arg1)
  :after '(find-function
           find-variable)
  (ignore-errors
    (org-babel-tangle-jump-to-org)))
#+END_SRC

**** Get url title

Fetches the link title for the current link using the ~get_url_title~ command from [[https://github.com/floscr/dotfiles/blob/07156f2d059da2676d13d17d67eb8fed596557db/new/modules/scripts/src/get_url_title.clj][dotfiles/get_url_title.clj at 07156f2d059da2676d13d17d67eb8fed596557db · floscr/dotfiles · GitHub]]

#+begin_src elisp
(defun my-org/fetch-link-title-command (url)
  "Fetches the link title with get_url_title (https://github.com/floscr/nim-utils#get_url_title)."
  (or (my/shell-command-str "get_url_title" url "--org")
      (user-error "Error: Could not get title for url \"%s\"" url)))

(defun my-org/fetch-link-title (&optional fn)
  "Fetch the link title under the cursor."
  (-when-let* ((org-el (my-org/link-at-point)))
    (-let* ((fn (or fn #'my-org/fetch-link-title-command))
            ((&plist :el :url) org-el)
            (title (funcall fn url))
            (from (org-element-property :begin el))
            (to (org-element-property :end el)))
      (when (string= title "Could not find title in html")
        (user-error (t! "Error: Could not fetch title for url <<url>>")))
      (list :region (list (org-element-property :begin el)
                          (org-element-property :end el))
            :title title))))

(defun my-org/update-link-title (&optional fn)
  "Replace the org link under the cursor with the link with the fetched title."
  (-when-let* (((&plist :region :title) (my-org/fetch-link-title fn)))
    (apply #'delete-region region)
    (insert title)))

(defun my-org|fetch-this-org-link-rss ()
  "Fetches the title for the plain link under the cursor."
  (interactive)
  (let ((fn (lambda (url)
              (my/shell-command-str "get_url_title" "rss" url))))
    (my-org/update-link-title fn)))

(defun my-org|fetch-this-org-link-title ()
  "Fetches the title for the plain link under the cursor."
  (interactive)
  (my-org/update-link-title))

(defun my-org-agenda|fetch-this-org-link-title ()
  "Fetches the title for the plain link under the cursor."
  (interactive)
  (require 'org-ml)
  (save-window-excursion
    (org-agenda-switch-to)
    (-when-let* ((link-pos (-some->> (org-ml-parse-this-headline)
                             (org-ml-get-property :title)
                             (--find (org-ml-is-type 'link it))
                             (org-ml-get-property :begin))))
      (goto-char link-pos)
      (my-org|fetch-this-org-link-title)))
  (org-agenda-redo))
#+end_src

**** Read timestamp to string

Use the interactive timestamp interface to read an org string

#+begin_src elisp
(defun my-org/read-timestamp-inactive-str ()
  (with-temp-buffer
    (org-time-stamp-inactive)
    (buffer-substring-no-properties (point-min) (point-max))))
#+end_src

**** Copy link under Cursor

#+BEGIN_SRC elisp
;;;###autoload
(defun my-org/match-link (pos)
  "Return cons of link under point and its position.
POS to match:
0: the entire org link,
1: the url,
2: the title."
  (let ((pos (org-in-regexp org-link-bracket-re 1))
        (str (org-link-unescape (match-string-no-properties pos))))
    (cons str pos)))

;;;###autoload
(defun my-org/match-org-link-entire ()
  "Match the link under the cursor as (str . pos)"
  (my-org/match-link 0))

;;;###autoload
(defun my-org/match-org-link-url ()
  "Match the link url under the cursor as (str . pos)"
  (my-org/match-link 1))

;;;###autoload
(defun my-org/match-org-link-title ()
  "Match the link title under the cursor as (str . pos)"
  (my-org/match-link 2))

(defun my-org/copy-or-cut-link (match-fn &optional cut?)
  "Copy or cut the current link under the cursor"
  (my/kill-and-message (car (funcall match-fn)))
  (when cut?
    (-when-let ((link . (beg . end)) (my-org/match-org-link-entire))
      (delete-region beg end))))

(defun my-org|copy-entire-link (&optional cut?)
  (interactive "P")
  (my-org/copy-or-cut-link #'my-org/match-org-link-entire cut?))

(defun my-org|copy-link-url (&optional cut?)
  (interactive "P")
  (my-org/copy-or-cut-link #'my-org/match-org-link-url cut?))

(defun my-org|copy-link-title (&optional cut?)
  (interactive "P")
  (my-org/copy-or-cut-link #'my-org/match-org-link-title cut?))
#+END_SRC
**** Copy As Markdown

#+BEGIN_SRC elisp
(defun my-org/copy-as-markdown (&optional subtree-p)
  "Copy the current subtree as markdown to clipboard."
  (require 'ox-gfm)
  (let* ((org-export-with-toc nil)
         (org-export-with-special-strings nil)
         (org-export-with-smart-quotes nil)
         (md-file (make-temp-file "my-md-export"))
         (md (org-export-to-file 'gfm md-file nil subtree-p))
         (content (f-read md-file)))
    (kill-new content)
    (message "Copied buffer as markdown to clipboard.")))

(defun my-org|copy-buffer-as-markdown ()
  "Copy the entire buffer as markdown to clipboard."
  (interactive)
  (my-org/copy-as-markdown))

(defun my-org|copy-subtree-as-markdown ()
  "Copy the subtree as markdown to clipboard."
  (interactive)
  (my-org/copy-as-markdown t))
#+END_SRC

**** Add created date to headings

#+BEGIN_SRC elisp
(defun my-org|add-created-property ()
  "Add CREATED property with the current time to the current item."
  (interactive)
  (org-set-property +org-created-property (+org/inactive-timestamp)))

(defun my-org/add-created-property-automatically ()
  "Add CREATED property with the current time to the current item."
  (interactive)
  (let ((global-property (+org-get-global-property "ADD_CREATED")))
    (unless (string= global-property "nil")
      (when (+org-get-global-property "ADD_CREATED")
        (org-set-property +org-created-property (+org/inactive-timestamp))))))
#+END_SRC

#+BEGIN_SRC elisp
(advice-add '+org/insert-item-below :after (my@ignore-args #'my-org/add-created-property-automatically))
(advice-add '+org/insert-item-above :after (my@ignore-args #'my-org/add-created-property-automatically))
#+END_SRC

**** Add id to headings

- When file has global property ~#+ADD_ID: t~
- Is a file in org-directory

#+BEGIN_SRC elisp
(defun my-org/add-id-property-automatically ()
  "Add CREATED property with the current time to the current item."
  (interactive "P")
  (when (or (string= (+org-get-global-property "ADD_ID") "t")
            (f-ancestor-of? org-directory buffer-file-name))
    (call-interactively #'org-id-get-create)))
#+END_SRC

#+BEGIN_SRC elisp
(advice-add '+org/insert-item-below :after (my@ignore-args #'my-org/add-id-property-automatically))
(advice-add '+org/insert-item-above :after (my@ignore-args #'my-org/add-id-property-automatically))
#+END_SRC

*** Config

**** Org Src Language Aliases

#+begin_src elisp
(after! org-src
  (add-to-list 'org-src-lang-modes '("clj" . clojure))
  (add-to-list 'org-src-lang-modes '("cljs" . clojurescript))
  (add-to-list 'org-src-lang-modes '("tsx" . typescript))
  (add-to-list 'org-src-lang-modes '("ts" . typescript))
  (add-to-list 'org-src-lang-modes '("jsx" . js-jsx)))
#+end_src

**** Custom attachments

I truly dislike how ~org-attach~ handles attachments.

The attachments get sorted by an id of the files directory and their headline.
This is truly against the mantra of raw text files, as you have to move the file if you want to move the link.

This made me loose countless files because I just moved the link text to another headline!

My solution is to have an extra link that resolves to ONE directory with all the files in it.
I will make sure I don't override any files (easily enough...)

#+begin_src elisp
(defvar my-attach:dir "~/Documents/Org/.attach/clojure-attach")

(defun my-attach/follow (path)
  (let* ((attach-dir (expand-file-name my-attach:dir))
         (path* (expand-file-name path attach-dir)))
    (if (string-match-p (image-file-name-regexp) path)
        (find-file path*)
      (my-dired::open-external/xdg-open path*))))

(defun my-attach/image-data-fun (protocol path _for)
  (let ((attach-dir (expand-file-name my-attach:dir)))
    (when (and (display-graphic-p)
               (string-match-p (image-file-name-regexp) path))
      (let ((file (expand-file-name path attach-dir)))
        (when (and (file-exists-p file)
                   (image-type-from-file-name file))
          (with-temp-buffer
            (set-buffer-multibyte nil)
            (setq buffer-file-coding-system 'binary)
            (insert-file-contents-literally file)
            (buffer-substring-no-properties (point-min) (point-max))))))))

(org-link-set-parameters "my-attach"
                         :follow #'my-attach/follow
                         :display #'org-link
                         :image-data-fun #'my-attach/image-data-fun)

(defun my-attach|dwim ()
  (interactive)
  (-some-> (my/shell-command-str "org_attach" (current-kill 0))
           (s-trim)
           (insert)))

(defun my-attach|last-download ()
  (interactive)
  (-some->> (my-file/last-modified-file-in-dir "~/Downloads")
            (my/shell-command-str "org_attach")
            (s-trim)
            (insert)))
#+end_src
**** Use external Image Converter

- To display ~webp~ images
- [[https://xenodium.com/emacs-viewing-webp-images/][Emacs: viewing webp images]]

#+begin_src elisp
(setq image-use-external-converter t)
#+end_src

** Hydras
** Work
*** Pitch
**** Create worktree

#+begin_src elisp
(defun my-pitch|create-worktree ()
  "Creates a worktree for a branch.
Applies the custom dev script and copies over node_modules + bundle caches to reduce network/computation activity."
  (interactive)
  (when-let* ((path (call-interactively #'my-magit|create-worktree-project-from-branch)))
    ;; (my-pitch|apply-custom-dev-script)
    (let ((src (my-file/git-root))
          (dst (my-file/project-root)))
      (call-process-shell-command (t! "rsync -ravE <<src>>/node_modules <<dst>>&") nil 0 nil)
      (call-process-shell-command (t! "rsync -ravE <<src>>/desktop-app/node_modules <<dst>>/desktop-app &") nil 0 nil))))
#+end_src

#+BEGIN_SRC elisp
(after! magit
  (transient-append-suffix 'magit-worktree "b" '("p" "Pitch worktree" my-pitch|create-worktree)))
#+END_SRC

**** Start terminal

#+begin_src elisp
(defun my-pitch|start-dev-terminal ()
  (interactive)
  (let ((default-directory (my-file/project-root nil)))
    ;; (my-pitch|apply-custom-dev-script)
    (call-process-shell-command "alacritty -e $SHELL -c './scripts/pit dev --desktop'&" nil 0 nil)))
#+end_src

**** Convert to uix

#+begin_src elisp
(defun my-pitch/convert-hiccup-to-uix ()
  (interactive)
  (save-excursion
    (clojure-convert-collection-to-list)
    (forward-char 1)
    (insert "$ ")))
#+end_src

**** Convert to ~gridSize~

#+begin_src elisp
(defun my-pitch|insert-grid-size-from-px ()
  "Convert px to gridSize macro and insert result."
  (interactive)
  (let* ((size (read-number "Size: "))
         (base-size 12.0)
         (new-size (/ size base-size))
         (can-floor (not (/= new-size (floor new-size))))
         (new-size (if can-floor (floor new-size) new-size)))
    (insert (t! "gridSize(<<new-size>>)"))))
#+end_src

**** Fix Clojure

#+begin_src elisp
(defun my-pitch|autofix-clojure-buffer ()
  "Autofix the "
  (interactive)
  (let ((buffer (current-buffer)))
    (deferred:$
      (deferred:process-shell (s-join " " (list "clojure" "-M:nsorg-fix" "-M:cljfmt-fix" "<" buffer-file-name)))
      (deferred:nextc it
        (with-current-buffer buffer (revert-buffer))
        (message "Autofixed buffer!")))))
#+end_src

**** Debug

#+begin_src elisp
(defun my-pitch|debug-statement ()
  (interactive)
  (let* ((clojure-symbol (pcase (doom-thing-at-point-or-region)
                           ("" (save-excursion
                                 (lispyville-backward-sexp-begin 1)
                                 (doom-thing-at-point-or-region)))
                           (t (doom-thing-at-point-or-region))))
         (placeholder (if clojure-symbol (concat "dd-" (substring-no-properties clojure-symbol)) "dd"))
         (name (read-string "Debug var name: " placeholder))
         (suffix (-some->> (s-split-up-to "-" name 1)
                   (-second-item)
                   ((lambda (x) (s-wrap x "\"")))))
         (snippet (s-join "\n"
                          (list
                           ""
                           (t! "(defn <<name>> [x]")
                           (if suffix
                               (t! "  (js/console.log <<suffix>> x)")
                             (t! "  (js/console.log x)"))
                           (t! "  (set! js/global-debug-<<name>> x) x)")
                           ""
                           (t! "(comment js/global-debug-<<name>>)")
                           ""))))
    (save-excursion
      (lispyville-wrap-round 1)
      (insert (t! "<<name>> "))
      (lispyville-backward-function-begin)
      (previous-line 1)
      (insert snippet))))

(defun my-pitch|eval-debug-statement ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (search-forward "(comment js/global-debug" nil nil nil)
    (lispyville-up-list)
    (goto-char (- (point) 1))
    (cider-eval-last-sexp)))
#+end_src
**** Custom builder

#+begin_src elisp
(defun my-pitch|apply-custom-dev-script ()
  "Applies custom dev-script and assumes it unchanged in git."
  (interactive)
  (let* ((script-path "desktop-app/scripts/dev-all.py")
         (content (->> (f-expand "~/Code/Work/Pitch/dev-overwrite/dev-all.py")
                       f-read))
         (dst-path (f-join (my-file/git-root nil) script-path)))
    (f-write content 'utf-8 dst-path)
    (magit-assume-unchanged script-path)))
#+end_src

**** Goto l10n

#+begin_src elisp
(defun my-pitch|l10n-jump (identifier &optional arg)
  (interactive
   (list (doom-thing-at-point-or-region)
         current-prefix-arg))
  (let ((l10n-dir (f-join (projectile-project-root) "projects/l10n/src"))
        (id (->> identifier
                 substring-no-properties
                 (s-replace-regexp "^:" ""))))
    (+ivy-file-search :query id :in l10n-dir)))
#+end_src

**** Convert string to l10n

#+begin_src elisp
(defun my-clojure/string-content-at-point ()
  "Returns a list with the string content at point without quotes and the begin and end positions of the string with quotes."
  (if (clojure--in-string-p)
    (save-excursion
      (let ((beg (progn (goto-char (clojure-string-start))
                        (forward-char 1)
                        (point)))
            (end (progn
                   (search-forward-regexp "\"" (point-at-eol) nil)
                   (backward-char 1)
                   (point))))
        (list (buffer-substring-no-properties beg end) (cons (- beg 1) (+ 1 end)))))
    (user-error "Cursor not positioned on a clojure string.")))

(defvar my-pitch:l10n-key nil
  "A prefix to always use for l10n string conversion in a buffer.")
(make-local-variable 'my-pitch:l10n-key)

(defun my-pitch|set-l10n-key-from-region ()
  "Sets the l10n buffer prefix from the region."
  (interactive)
  (setq my-pitch:l10n-key (buffer-substring-no-properties (region-beginning) (region-end))))

(defun my-pitch|convert-string-to-l10n ()
  "Convert the string under the cursor to l10n"
  (interactive)
  (-let* (((original-string (original-beg . original-end)) (my-clojure/string-content-at-point))
          (clojure-key (concat ":" (s-dashed-words original-string))))
    (delete-region original-beg original-end)
    (insert clojure-key)
    (lispy-wrap-round 1)
    (insert "l10n/t")
    (search-forward ":")
    (-let* (((beg . end) (bounds-of-thing-at-point 'symbol))
            (l10n-key (->> (buffer-substring-no-properties beg end)
                           (s-replace ":" "")
                           (s-prepend my-pitch:l10n-key)
                           (read-string "l10n key: "))))
      (delete-region beg end)
      (insert ":" l10n-key)
      (kill-new (concat l10n-key " = " original-string)))))
#+end_src

**** Create pull request

#+begin_src elisp
(defun my-pitch|ghub-create-pull-request ()
  "Function docstring"
  (interactive)
  (shell-command "gh pr create --label \"Team Birch\" --web"))
#+end_src

**** Create pull request md

#+begin_src elisp
(defun my-pitch|create-pull-request-md ()
  "Create a markdown document for the currently open branch."
  (interactive)
  (let* ((branch-name (magit-get-current-branch))
         (branch-name (if (magit-name-remote-branch branch-name)
                          (->> branch-name
                               (magit-name-remote-branch)
                               (magit-split-branch-name)
                               (cdr)
                               (s-replace "florian/" ""))
                        (concat  (format-time-string "%y-%m") "-" branch-name)))
         (file (f-join "/home/floscr/Code/Work/Pitch/pr-docs" (concat branch-name ".org")))
         ;; Prevent file template being applied for file
         (+file-templates-alist nil))
    (find-file-other-window file)
    (when (eq (buffer-size) 0)
      ;; (my-snippets/insert-by-name "Pull Request Template")
      (goto-char (point-min)))))
#+end_src

**** Format buffer

#+begin_src elisp
(defun my-pitch|format-buffer ()
  "Formats the current buffer."
  (interactive)
  (let* ((bin (f-join (my-file/project-root) "./scripts/pit"))
         (cmd (cond
               ((or (eq major-mode 'clojure-mode)
                    (eq major-mode 'clojurescript-mode))
                (concat bin " fmt2 " (shell-quote-argument buffer-file-name)))
               ((eq major-mode 'rjsx-mode)
                (concat "prettier -w " (shell-quote-argument buffer-file-name))))))
    (shell-command cmd nil nil)
    (revert-buffer)))
#+end_src

**** Stylus Variables

#+begin_src elisp
(defun my-pitch/get-css-variables ()
  (let* ((path (f-join (projectile-project-root) "projects/frontend/src/app/pitch/styles/helpers.styl"))
         (content (f-read path)))
    (->> (s-lines content)
         (--filter (s-starts-with? "$" it)))))

(defun my-pitch/get-css-variables-value (line)
  (->> line
       (s-split " ")
       (car)))
#+end_src

**** Paste stylus fixed

#+begin_src elisp
(defun my-pitch|paste-stylus-fixed ()
  (interactive)
  (let* ((k (current-kill 0))
         (default-directory "/home/floscr/Code/Work/Pitch/pitch-app/.worktrees/figma-to-stylus/projects/figma-to-stylus")
         (result (shell-command-to-string (concat "./node_modules/.bin/nbb ./src/figma_to_stylus/core.cljs" (combine-and-quote-strings (s-split "\n" k))))))
    (insert result)))
#+end_src

*** Pairing mode

#+begin_src elisp
(defun my-pitch*activate-lsp-header ()
  (when lsp-mode
    (setq-local lsp-headerline-breadcrumb-segments '(symbols))
    (lsp-headerline-breadcrumb-mode 1)
    (setq lsp-headerline-arrow "→")
    (set-face-attribute 'lsp-headerline-breadcrumb-separator-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-path-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-path-error-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-path-warning-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-path-info-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-path-hint-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-project-prefix-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-unknown-project-prefix-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-symbols-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-symbols-error-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-symbols-warning-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-symbols-info-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-symbols-hint-face nil :underline 'unspecified)
    (set-face-attribute 'lsp-headerline-breadcrumb-deprecated-face nil :underline 'unspecified)))

(defvar my-pitch:pairing-mode nil)

(defun my-pitch|start-pairing ()
  (interactive)
  (shell-command "systemctl --user stop picom.service")
  (doom-big-font-mode 1)
  (add-hook! 'window-configuration-change-hook #'my-pitch*activate-lsp-header)
  (my-pitch*activate-lsp-header)
  (lsp-lens-mode -1)
  (setq my-pitch:pairing-mode t)
  (set-face-attribute 'line-number nil
                      :foreground (face-attribute 'font-lock-doc-face :foreground)))

(defun my-pitch|stop-pairing ()
  (interactive)
  (doom-big-font-mode 0)
  (remove-hook! 'window-configuration-change-hook #'my-pitch*activate-lsp-header)
  (lsp-headerline-breadcrumb-mode -1)
  (lsp-lens-mode 1)
  (setq my-pitch:pairing-mode nil)
  (doom/reload-theme))

(defun my-pitch|toggle-pairing ()
  (interactive)
  (if my-pitch:pairing-mode
      (my-pitch|stop-pairing)
    (my-pitch|start-pairing)))
#+end_src
** AI

**** package

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! chatgpt-shell :recipe (:host github :repo "xenodium/chatgpt-shell"))
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! chatgpt-shell
  :config
  (setq chatgpt-shell-openai-key
      (lambda ()
        (-> (f-read "/run/agenix/openai")
            (s-trim)))))
#+END_SRC
** Security

*** Fix GPG saving issue in Emacs 29

[[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources#problems-in-emacs-29.1][Keeping Secrets in Emacs with GnuPG and Auth Sources - Mastering Emacs]]

#+begin_src elisp
(fset 'epg-wait-for-status 'ignore)
#+end_src

* Bindings
** General

#+BEGIN_SRC elisp
(map! :g "C-±" #'+popup/raise)
#+END_SRC

*** Disable emacs-state-toggle

#+BEGIN_SRC elisp
(map! :nm "C-z" nil)
#+END_SRC

*** Auto indent bracket openings
:PROPERTIES:
:SOURCE:   [[https://xenodium.com/emacs-smartparens-auto-indent/][Emacs smartparens auto-indent]]
:END:

Automatically indent and format when opening area betwen to delimiters.

#+begin_src elisp
(defun my-text/indent-between-pair (&rest _ignored)
  (newline)
  (indent-according-to-mode)
  (forward-line -1)
  (indent-according-to-mode))

(sp-local-pair 'prog-mode "{" nil :post-handlers '((my-text/indent-between-pair "RET")))
(sp-local-pair 'prog-mode "[" nil :post-handlers '((my-text/indent-between-pair "RET")))
(sp-local-pair 'prog-mode "(" nil :post-handlers '((my-text/indent-between-pair "RET")))
#+end_src

** Super

#+BEGIN_SRC elisp
(map!
 (:map override
   :g "s-n" #'evil-buffer-new
   :g "s-;" #'eval-expression
   :g "s-a" #'mark-whole-buffer
   :g "s-s" #'save-buffer
   :g "s-v" #'yank
   :g "s-x" #'execute-extended-command
   :g "s-y" #'helm-show-kill-ring

   ;; Text scale
   :g "s-="   #'doom/increase-font-size
   :g "s--"   #'doom/decrease-font-size
   :g "s-0"   #'doom/reset-font-size))
#+END_SRC

** Evil
*** Config
**** Use global ex by default

I almost always want global search and replace, doom changed this in [[orgit-rev:~/.emacs.d/::1a6f5086400d164178016784aac12114934c8245][1a6f50864]].
To undo this behavior just add =g= flag

#+BEGIN_SRC elisp
(setq evil-ex-substitute-global t)
#+END_SRC

*** Motions
**** Additional text objects

- =q= for any type of quote
- =B= for curly braces
- =r= for square brackets

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "`")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "`")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket)
  (define-key evil-inner-text-objects-map "B" 'evil-inner-curly))
#+END_SRC

**** Up to next/previous indent

Text objects for lines after or before the current line,
that have the same or deeper indent.

#+BEGIN_SRC elisp
(defun evil-indent-plus--line-down-indent-range (&optional point)
  (require 'evil-indent-plus)
  (let* ((range (evil-indent-plus--same-indent-range point))
         (base (point))
         (begin (point)))
    (list begin (cl-second range) base)))

(evil-define-text-object evil-indent-plus-i-indent-line-down (&optional count beg end type)
  "Text object describing the block with the same (or greater) indentation as the current line,
and the line above, skipping empty lines."
  :type line
  (require 'evil-indent-plus)
  (evil-indent-plus--linify (evil-indent-plus--line-down-indent-range)))

(define-key evil-inner-text-objects-map "+" 'evil-indent-plus-i-indent-line-down)

(defun evil-indent-plus--line-up-indent-range (&optional point)
  (require 'evil-indent-plus)
  (let* ((range (evil-indent-plus--same-indent-range point))
         (base (point))
         (begin (point)))
    (list begin (cl-first range) base)))

(evil-define-text-object evil-indent-plus-i-indent-line-up (&optional count beg end type)
  "Text object describing the block with the same (or greater) indentation as the current line,
and the line above, skipping empty lines."
  :type line
  (require 'evil-indent-plus)
  (evil-indent-plus--linify (evil-indent-plus--line-up-indent-range)))

(define-key evil-inner-text-objects-map "-" 'evil-indent-plus-i-indent-line-up)
#+END_SRC

**** Little Word Motion

#+BEGIN_SRC elisp
(defun load-evil-camel-case-motion ()
  (require 'evil-little-word)
  (define-key evil-normal-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-normal-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "i M-w") 'evil-inner-little-word))

(load-evil-camel-case-motion)
#+END_SRC
**** Sort Motion

#+BEGIN_SRC elisp
(evil-define-operator +evil/sort (beg end)
  "Sort lines with motion"
  (interactive "<r>")
  (sort-lines nil beg end))

(map!
 (:after evil
    :m "gS" #'+evil/sort))
#+END_SRC

**** Case Conversion

Copied code from [[https://github.com/strickinato/evil-briefcase][strickinato/evil-briefcase]] since it's not maintained anymore.
Convert case motion via ~Z~.

Example pressing ~ZciW~ would convert the inner =Word= into =camelCase=

#+BEGIN_SRC elisp
(evil-define-operator +evil/case-upper (beg end type)
  "Convert text to upper case."
  (if (eq type 'block)
      (evil-apply-on-block #'s-upcase beg end nil)
    (let ((str (s-upcase (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-lower (beg end type)
  "Convert text to lowercase."
  (if (eq type 'block)
      (evil-apply-on-block #'s-downcase beg end nil)
    (let ((str (s-downcase (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-camel-upper (beg end type)
  "Convert text to CamelCase with a Capital C"
  (if (eq type 'block)
      (evil-apply-on-block #'s-upper-camel-case beg end nil)
    (let ((str (s-upper-camel-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-camel-lower (beg end type)
  "Convert text to camelCase with a small C"
  (if (eq type 'block)
      (evil-apply-on-block #'s-lower-camel-case beg end nil)
    (let ((str (s-lower-camel-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-snake-lower (beg end type)
  "Convert text to snake_case, slithering"
  (if (eq type 'block)
      (evil-apply-on-block #'s-snake-case beg end nil)
    (let ((str (s-snake-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-snake-upper (beg end type)
  "Convert text to SNAKE_CASE, AKA SCREAMING_SNAKE_CASE"
  (if (eq type 'block)
      (evil-apply-on-block #'s-snake-case beg end nil)
    (let ((str (s-upcase (s-snake-case (buffer-substring-no-properties beg end)))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-kebab-upper (beg end type)
  "Convert text to KEBAB-KASE, mmmm... THICK MEAT"
  (if (eq type 'block)
      (evil-apply-on-block #'s-dashed-words beg end nil)
    (let ((str (s-dashed-words (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert (upcase str)))))

(evil-define-operator +evil/case-kebab-lower (beg end type)
  "Convert text to kebab-kase, mmmm... hyphens"
  (if (eq type 'block)
      (evil-apply-on-block #'s-dashed-words beg end nil)
    (let ((str (s-dashed-words (buffer-substring-no-properties beg end))))
        (delete-region beg end)
        (insert str))))

(map!
 (:after evil
  :m "Zu" #'+evil/case-upper
  :m "Zl" #'+evil/case-lower
  :m "ZC" #'+evil/case-camel-upper
  :m "Zc" #'+evil/case-camel-lower
  :m "ZS" #'+evil/case-snake-upper
  :m "Zs" #'+evil/case-snake-lower
  :m "ZK" #'+evil/case-kebab-upper
  :m "Zk" #'+evil/case-kebab-lower))
#+END_SRC

**** Org Src Block

Matches any block with ~BEGIN_~, e.g.: SRC blocks.

#+BEGIN_SRC elisp
(defun +evil-org/src-block ()
  "Matches src blocks using org-element-context."
  (-when-let* ((ctx (org-element-context))
               (type (car ctx))
               (ctx (cond
                     ((equal type 'src-block) ctx)
                     ((equal type 'example-block) ctx)
                     ((equal type 'quote-block) ctx)
                     ;; Inside quote blocks org-element-context matches the paragraphs
                     ;; So we have to take the parent block to get the quote-block
                     ((equal type 'paragraph)
                      (-some->> ctx
                        (nth 1)
                        ((lambda (x) (doom-plist-get x :parent)))
                        (--id-when (equal (car it) 'quote-block)))))))
    ctx))

(evil-define-text-object +evil-org-inner-src-block (count &optional beg end type)
  "Select an org src/quote/example block object."
  (evil-org-select-inner-element (+evil-org/src-block)))

(evil-define-text-object +evil-org-an-src-block (count beg end type)
  "An org object.
Matches urls and table cells."
  (evil-org-select-an-element (+evil-org/src-block)))

(after! evil-org
  (evil-define-key '(visual operator) evil-org-mode-map
    "ib" #'+evil-org-inner-src-block
    "ab" #'+evil-org-an-src-block))
#+END_SRC

*** Normal Bindings
**** Window navigation

Fix window navigation for various modes.
I don't like pressing ~C-w~ or ~SPC w~ as leader to navigate,
so I have to work around it:

#+BEGIN_SRC elisp
(map!
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)

(map!
 :map (image-mode-map
       magit-diff-mode-map
       magit-revision-mode-map
       magit-status-mode-map
       eshell-mode-map
       evil-org-mode-map)
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)

(add-hook! 'eshell-first-time-mode-hook
  (map!
   :map eshell-mode-map
   :en "C-h"   #'evil-window-left
   :en "C-j"   #'evil-window-down
   :en "C-k"   #'evil-window-up
   :en "C-l"   #'evil-window-right))

(map!
 :map org-agenda-mode-map
 "C-h"  #'evil-window-left
 "C-j"  #'evil-window-down
 "C-k"  #'evil-window-up
 "C-l"  #'evil-window-right)
#+END_SRC

**** History navigation in minibuffer

#+BEGIN_SRC elisp
(define-key minibuffer-local-map "\C-p" 'previous-history-element)
(define-key minibuffer-local-map "\C-n" 'next-history-element)
#+END_SRC

**** Jump to last buffer

#+BEGIN_SRC elisp
(map! :n "gb" #'evil-switch-to-windows-last-buffer)
#+END_SRC

**** Select last paste
:PROPERTIES:
:SOURCE:   https://emacs.stackexchange.com/a/21093
:END:

#+BEGIN_SRC elisp
(defun +evil|select-pasted ()
  (interactive)
  (let ((start-marker (evil-get-marker ?\[))
        (end-marker (evil-get-marker ?\])))
    (evil-visual-select start-marker end-marker)))

(map! :n "gp" #'+evil|select-pasted)
#+END_SRC

**** Jump source dwim

#+BEGIN_SRC elisp
(map! :m "-" #'my-buffer|jump-source-dwim)
#+END_SRC

**** Visual Line Mode Navigation

#+BEGIN_SRC elisp
(map! :map visual-line-mode-map
      :nv "j" #'evil-next-visual-line
      :nv "k" #'evil-previous-visual-line)
#+END_SRC

*** Insert Bindings

Insert Mode bindings, mostly unicode insertion and workaround for german umlaut.

**** Insert from the kill ring in insert mode

#+BEGIN_SRC elisp
(map! :i "A-y" #'helm-show-kill-ring)
#+END_SRC

**** Unicode Characters

#+BEGIN_SRC elisp
(map!
 :i "C-y"   #'helm-show-kill-ring
 :i "M-`"   (cmd! (insert "°"))
 :i "M-."   (cmd! (insert "…"))
 :i "M-^"   (cmd! (insert "°"))
 :i "M-l"   (cmd! (insert "λ"))
 :i "M-w"   (cmd! (insert "⚠"))
 :i "M-i"   (cmd! (insert "ℹ")))
#+END_SRC

*** Square Bracket Bindings

Global ~[~ & ~]~ combinator bindings

**** Dumb Jump

#+BEGIN_SRC elisp
(map!
 :n "]F" #'dumb-jump-go
 :n "[F" #'dumb-jump-back)
#+END_SRC

**** Flycheck Error Jumping

#+BEGIN_SRC elisp
(map!
 :n "]e" #'flycheck-next-error
 :n "[e" #'flycheck-previous-error)
#+END_SRC

**** Projectile Alternate file finding

#+BEGIN_SRC elisp
(map!
 :n "]1" #'projectile-toggle-between-implementation-and-test
 :n "[1" #'projectile-toggle-between-implementation-and-test)
#+END_SRC
*** Comman Bindings

#+begin_src elisp
(map!
 :map (clojurescript-mode-map clojure-mode-map)
 :n ",r" #'raise-sexp
 :n ",f" #'sp-forward-barf-sexp
 :n ",b" #'sp-backward-barf-sexp
 :n ",d" #'sp-kill-sexp
 :n ",," #'sp-forward-sexp
 :n ",n" #'sp-next-sexp
 :n ",y" #'sp-clone-sexp
 :n ",<" #'transpose-sexps
 :n ",u" #'sp-backward-up-sexp
 :n ",T" #'clojure-thread
 :n ",T" #'clojure-thread)
#+end_src

*** Text Objects

Custom evil text objects mostly stolen from [[https://github.com/jerryxgh/lambda-x/blob/master/lambda-evil.el#L236][Spacemacs|define-text-object-regexp]].

**** Utils
***** Define Text Objects

#+BEGIN_SRC elisp
(defmacro +evil/define-text-object-regexp (key name start-regexp end-regexp)
  "Define a text object.
START-REGEXP and END-REGEXP are the boundaries of the text object."
  (let ((inner-name (make-symbol (concat "evil-inner-" name)))
        (outer-name (make-symbol (concat "evil-outer-" name))))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regexp ,end-regexp beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regexp ,end-regexp beg end type count t))
       (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
       (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))
#+END_SRC
**** Config

#+BEGIN_SRC elisp
(+evil/define-text-object-regexp "~" "tilde" "~" "~")
(+evil/define-text-object-regexp "=" "equal" "=" "=")
(+evil/define-text-object-regexp "|" "bar" "|" "|")
(+evil/define-text-object-regexp "*" "star" "*" "*")
(+evil/define-text-object-regexp "$" "dollar" "$" "$")
(+evil/define-text-object-regexp "%" "percent" "%" "%")
(+evil/define-text-object-regexp "/" "slash" "/" "/")
(+evil/define-text-object-regexp "_" "underscore" "_" "_")
(+evil/define-text-object-regexp "-" "hyphen" "-" "-")
#+END_SRC

**** Quotes Text Object

Changes the text matching inside quotes with ~q~ motion (e.g. ~ciq~)
Change inner bracket with ~r~

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket))
#+END_SRC
*** Ex Commands

Extend the default evil ex commands from [[file:~/.emacs.d/modules/editor/evil/+commands.el::;;; editor/evil/+commands.el -*- lexical-binding: t; -*-][+commands.el]]

#+BEGIN_SRC elisp
(after! evil-ex
  :config
  (evil-ex-define-cmd "W" #'evil-write))
#+END_SRC

*** MultiEdit

#+BEGIN_SRC elisp
(map! :nv "C-M-d" #'evil-multiedit-match-all)
#+END_SRC

*** Jump with =tab=

#+BEGIN_SRC elisp
(map! :n [tab] (general-predicate-dispatch nil
                 (and (featurep! :editor fold)
                      (save-excursion (end-of-line) (invisible-p (point))))
                 #'+fold/toggle
                 (fboundp 'evil-jump-item)
                 #'evil-jump-item)
      :v [tab] (general-predicate-dispatch nil
                 (and (bound-and-true-p yas-minor-mode)
                      (or (eq evil-visual-selection 'line)
                          (not (memq (char-after) (list ?\( ?\[ ?\{ ?\} ?\] ?\))))))
                 #'yas-insert-snippet
                 (fboundp 'evil-jump-item)
                 #'evil-jump-item))
#+END_SRC
*** TODO Paste Fix

Evil pastes at the current cursor, which I don't expect it to do.
Most of the time it requires me to move into insert mode, move one character,
and then do my function.

#+BEGIN_SRC elisp
(defun +evil/normal-mode-paste-fix (fn &optional insert-char)
  "Move forward one character and then paste."
  (interactive)
  (if (and (evil-normal-state-p)
           (my-buffer/line-contains "[^\s]"))
      (progn
        (forward-char 1)
        (when (and insert-char (looking-at insert-char))
          (insert insert-char))
        (let ((line (substring-no-properties (thing-at-point 'line))))
          (call-interactively fn)
          (when (eq line (substring-no-properties (thing-at-point 'line)))
            (delete-char 1))))
    (call-interactively fn)))
#+END_SRC

*** TODO Store all yanks in extra register

#+begin_src elisp :tangle no
(defvar +evil:last-yank nil)

(defun +evil/save-to-yank-register (&rest _rest)
  "Save the last yank to a specific register that only gets overwritten by yanks.
So deletes wont affect this register."
  (setq +evil:last-yank (evil-get-register ?\")))

(defun +evil/insert-from-yank-register ()
  "Save the last yank to a specific register that only gets overwritten by yanks.
So deletes wont affect this register."
  (-some->> +evil:last-yank
    (insert)))

;; (advice-add 'evil-yank :after #'+evil/save-to-yank-register)
#+end_src

** Leader

#+BEGIN_SRC elisp
(map!
 :leader
 "'"  #'+popup/toggle
 "au" #'undo-tree-visualize
 "-"  #'quick-calc
 "\\"   #'my-project-hydra|main)
#+END_SRC

*** Buffer

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("b" . "buffer")
  :desc "Rename Buffer"  "r" #'rename-buffer
  :desc "Rename Buffer"  "+" #'persp-add-buffer))
#+END_SRC

*** Code

#+begin_src elisp
(map!
 :leader
 (:prefix-map ("c" . "Code")
  :desc "Compile" "c"   #'my-project-compile|compile
  :desc "Rename" "r"   #'lsp-rename
  :desc "Execute code action" "a"   #'lsp-execute-code-action))
#+end_src

*** File / Goto

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("f" . "file")
  :desc "Open Private Config" "P" (cmd! (find-file (f-join doom-private-dir "config.org")))
  (:prefix-map ("g" . "goto")
   :desc "Drive"                 "/" #'my-counsel|mounted-drives
   :desc "Desktop"               "D" (cmd! (find-file "~/Desktop"))
   :desc "Config"                "." (cmd! (find-file "~/.config"))
   :desc "Code"                  "c" (cmd! (find-file "~/Code"))
   :desc "Last captured"         "C" (cmd! (org-goto-marker-or-bmk org-capture-last-stored-marker))
   :desc "Downloads"             "d" (cmd! (find-file "~/Downloads"))
   :desc "Elfeed"                "e" (cmd! (find-file (car rmh-elfeed-org-files)))
   :desc "Media"                 "m" (cmd! (find-file "~/Media"))
   :desc "Music"                 "M" (cmd! (find-file "~/Media/Music"))
   :desc "Notes"                 "n" (cmd! (find-file org-directory))
   :desc "Project Root"          "p" (cmd! (find-file (projectile-project-root)))
   :desc "Last refiled"          "r" (cmd! (org-refile-goto-last-stored))
   :desc "Tmp"                   "t" (cmd! (find-file "/tmp"))
   :desc "Home"                  "h" (cmd! (find-file "~"))
   :desc "Run (Mounted Drives)"  "r" #'my-dired|find-mounted-drive)))
#+END_SRC

*** Git

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("g" . "git")
  :desc "Amend Commit (No Message)"           "A" (cmd! (magit-commit-amend "--no-edit"))
  :desc "Blame"                               "B" #'magit-blame
  :desc "Changed Files"                       "F" #'my-magit|counsel-changed-files
  :desc "New Branch"                          "N" #'magit-branch-spinoff
  :desc "Show revision original File"         "O" #'my-magit|show-revision-original
  :desc "Map-editor Changed Files"            "T" (cmd! (my-magit|counsel-changed-files "map-editor"))
  :desc "Amend Commit"                        "a" #'magit-commit-amend
  :desc "Checkout"                            "b" #'magit-checkout
  :desc "Diff"                                "d" #'magit-diff
  :desc "Push"                                "p" #'magit-push
  :desc "Undo"                                "u" #'my-magit|git-undo
  :desc "Worktree Popup"                      "w" #'magit-worktree
  :desc "New Org Pr"                          "!" #'+MM|new-pr-from-branch
  (:prefix ("f" . "file")
   :desc "VC file"                            "F" #'vc-revision-other-window)
  (:prefix ("l" . "list")
   :desc "List gists"                         "g" #'+gist:list
   :desc "List submodules"                    "n" #'magit-list-submodules
   :desc "List issues"                        "p" #'forge-list-issues
   :desc "List pull requests"                 "r" #'forge-list-pullreqs
   :desc "List pull awaiting review requests" "R" #'forge-list-requested-reviews
   :desc "List notifications"                 "s" #'forge-list-notifications)))
#+END_SRC

*** Insert

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("i" . "insert")
   :desc "New Snippet"    "S" #'+snippets/new
   :desc "Killring"       "y" #'helm-show-kill-ring
   :desc "Comment Header" "h" #'my-comment-header|insert))
#+END_SRC

*** Open

#+BEGIN_SRC elisp
(map!
 :leader
 (:desc "open" :prefix "o"
   :desc "Calc"            :g "c" #'calc
   :desc "Calc"            :g "C" #'=calendar
   :desc "Elfeed"          :g "e" #'+eshell/toggle
   :desc "Eshell"          :g "E" #'my-elfeed|open
   :desc "Irc"             :g "i" #'=irc
   :desc "Mail"            :g "m" #'=mu4e
   :desc "Proced"          :g "p" #'proced
   :desc "Snippet"         :g "s" #'+snippets/edit
   :desc "Flycheck Errors" :g "$" #'flycheck-list-errors))
#+END_SRC

*** Projects

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("p" . "project")
  :desc "Workspace Project Files" "P" #'my-workspaces|find-workspace-project-file
  :desc "Project VC"              "v" #'my-workspaces|workspace-project-vc
  :desc "Project Bookmarks"       "RET" #'my-jumpy|launch
  :desc "Compile"                 "c" #'bbuild|list
  :desc "Recompile"               "C" #'recompile))
#+END_SRC

*** Search

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("s" . "search")
  :desc "Imenu" "i" (cmd!
                     (pcase major-mode
                       ('stylus-mode (call-interactively #'my-stylus|imenu-top-level-classes))
                       (_ (call-interactively #'counsel-imenu))))
  :desc "Search Marks" "r" #'evil-show-marks
  :desc "Project for symbol" "P" #'+default/search-project-for-symbol-at-point
  :desc "Occur" "o" #'occur
  :desc "Web Lookup" "w" #'+lookup/online
  :desc "Web Lookup with prompt" "W" #'+lookup/online-select))
#+END_SRC

*** Toggle

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("t" . "toggle")
   :desc "Theme Dark/Light" "t" #'my-ui|toggle-theme
   :desc "Auto Completion" "c" #'+company/toggle-auto-completion
   :desc "Comment Header Fold" "<" #'my-comment-header|fold-all))
#+END_SRC

*** Window

#+BEGIN_SRC elisp
(map!
 :leader
 :desc  "Split Vertical"        "|"    #'evil-window-vsplit
 :desc  "Split Horizontal"      "-"    #'evil-window-split

 (:prefix-map ("w" . "window")
  :desc  "Delete"               "d"    #'delete-window
  :desc  "Ace Delete Windo"     "D"    #'ace-delete-window
  :desc  "New"                  "n"    #'evil-window-new

  :desc  "Undo"                 "u"    #'winner-undo
  :desc  "Redo"                 "r"    #'winner-redo
  :desc  "Enlargen"             "o"    #'doom/window-enlargen

  :desc  "Toggle Split"         "T"    #'+window|toggle-split-direction

  :desc  "Split Vertical"       "|"    #'evil-window-vsplit
  :desc  "Split Horizontal"     "_"    #'evil-window-split

  :desc  "Move Left"            "H"    #'+evil/window-move-left
  :desc  "Move Down"            "U"    #'+evil/window-move-down
  :desc  "Move Up"              "K"    #'+evil/window-move-up
  :desc  "Move Right"           "L"    #'+evil/window-move-right

  :desc  "Set Height"           "C-_"  #'evil-window-set-height
  :desc  "Set Height"           "C-|"  #'evil-window-set-width

  :desc  "Swap"                 "SPC"  #'ace-swap-window
  :desc  "Toggle Locked"        "#"    #'my|toggle-window-dedicated
  :desc "Toggle Locked"         "."    #'+popup/raise))
#+END_SRC

*** Workspace

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("TAB" . "workspace")
  :desc "Switch to"     "." #'my-workspaces/switch-to
  :desc "Close others"  "o" #'my-workspaces|close-others
  :desc "Create"        "c" #'my-workspaces/new-named
  :desc "Rename"        "," #'+workspace/rename
  :desc "Project Files" "p" #'my-workspaces|find-workspace-project-file
  :desc "Project VC"    "v" #'my-workspaces|workspace-project-vc
  :desc "Clone"         "C" (cmd!
                             (+workspace/new (format "Clone: %s" (+workspace-current-name)) t)
                             (message "Cloned current workspace %s" (+workspace-current-name)))
  :desc "Switch to last workspace" "0"   #'+workspace/other))
#+END_SRC

*** TODO Yank

#+BEGIN_SRC elisp
(defun +yank/execute-action (x &optional insert)
  "Copy the the yank or insert it during insert mode."
  (interactive)
  (cond
   ((or (evil-insert-state-p) insert) (insert x))
   (t (my/kill-and-message x)))
  x)

(defun +yank/dired-path ()
  "Returns the current dired entry or the buffer directory."
  (or (dired-file-name-at-point) dired-directory))

(defun +yank/buffer-filename ()
  "Returns the current buffers file name if possible."
  (cond ((doom-dired-buffer-p (current-buffer)) (+yank/dired-path))
        (buffer-file-name buffer-file-name)
        (org-src-source-file-name org-src-source-file-name)
        (t nil)))

(defun +yank/buffer-path ()
  "Returns the current buffers path."
  (or (+yank/buffer-filename) default-directory))

(defun +yank|filename (&optional insert)
  "Yank the buffer file name."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-filename)
     ;; When pointing at a directory at dired, I still take the directory
     ((lambda (x) (if (f-file? x)
                      (concat (f-base x) "." (f-ext x))
                    (f-base (file-name-directory x)))))
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|base (&optional insert)
  "Yank the buffer files base name."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-filename)
     (file-name-base)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|directory (&optional insert)
  "Yank the buffer files directory."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     (file-name-directory)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|path (&optional insert)
  "Yank the buffer files path."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|relative-to-project (&optional insert)
  "Yank the buffer path relative to the projectile-project-root."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     (f-full)
     ((lambda (x)
        (or
         (->> (s-replace (projectile-project-root) "" x)
              (-id-when #'s-present?))
         x)))
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(map!
 :leader
 (:prefix-map ("y" . "Yank")
  :desc "filename"            "f" #'+yank|filename
  :desc "base"                "b" #'+yank|base
  :desc "directory"           "d" #'+yank|directory
  :desc "path"                "p" #'+yank|path
  :desc "path"                "y" #'+yank|path
  :desc "relative to project" "r" #'+yank|relative-to-project))
#+END_SRC
*** Work

#+begin_src elisp
(map!
 :leader
 (:prefix-map ("0" . "Work")
  :desc "Open dev terminatl" "0" #'my-pitch|start-dev-terminal
  :desc "Format buffer"      "f" #'my-pitch|format-buffer))
#+end_src

** Local-Leader
*** Eshell

#+BEGIN_SRC elisp
(defun my-eshell/init-keymap ()
  "Setup additional custom eshell keybindings to already existing doom bindings. This must be done in a hook because eshell-mode
redefines its keys every time `eshell-mode' is enabled."
  (map! :map eshell-mode-map
        :in "C-p"         #'eshell-previous-input
        :in "C-n"         #'eshell-next-input

        :localleader "l"  #'eshell/clear))

(add-hook 'eshell-first-time-mode-hook #'my-eshell/init-keymap)
#+END_SRC

*** Elisp

#+BEGIN_SRC elisp
(map! :map emacs-lisp-mode-map
      :n "s-k"   (cmd! (sp-transpose-sexp)
                     (evil-previous-line))
      :n "s-j"   (cmd! (sp-push-hybrid-sexp)
                     (evil-next-line))
      :n "s-r" #'eval-buffer
      :n "g]"  #'sp-slurp-hybrid-sexp
      :n "g["  #'sp-forward-barf-sexp
      :localleader
      :desc "Jump to tangled source"  "j"  #'org-babel-tangle-jump-to-org
      :desc "Raise sexp"              "<" #'raise-sexp
      :desc "Barf Sexp"               ">" #'barf-sexp)
#+END_SRC

*** Clojure / Clojurescript

#+BEGIN_SRC elisp
(map! :map clojurescript-mode-map
      :localleader
      (:prefix ("d" . "debug")
       :desc "Add debug statement" "a" #'my-pitch|debug-statement
       :desc "Add debug statement" "d" #'my-pitch|eval-debug-statement))

(map! :map (clojure-mode-map clojurescript-mode-map)
      :localleader
      (:prefix ("i" . "insert")
       :desc "Namespace" "n" #'my-clojure|update-ns-dwim))
#+END_SRC

*** Haskell

#+BEGIN_SRC elisp
(map! :map haskell-mode-map
      :localleader
      :desc "Stylish" "s" #'my-haskell|autofix)
#+END_SRC

*** Bash

#+BEGIN_SRC elisp
(map! :map sh-mode-map
      :localleader
      :desc "Eval Region"  "e" #'sh-execute-region
      :desc "Eval Region"  "E" #'executable-interpret)
#+END_SRC

*** Git

#+BEGIN_SRC elisp
(map! :map magit-mode-map
      :localleader
      :desc "Toggle Magit Buffer Lock" "#" #'magit-toggle-buffer-lock)
#+END_SRC

*** Reasonml

#+BEGIN_SRC elisp
(map! :map reason-mode-map
      :localleader
      :desc "Eval Region"  "r" #'refmt)
#+END_SRC

*** Mail

#+BEGIN_SRC elisp
(map! :map (mu4e-view-mode-map mu4e-headers-mode-map)
      :localleader
      :g "x" (cmd!
              (require 'org-mu4e)
              (org-mu4e-store-and-capture)))
#+END_SRC

*** mail

#+BEGIN_SRC elisp
(map! :map (mu4e-view-mode-map mu4e-headers-mode-map)
      :localleader
      :g "x" (cmd!
              (require 'org-mu4e)
              (org-mu4e-store-and-capture)))
#+END_SRC
*** Images

#+BEGIN_SRC elisp
(map! :map 'image-mode-map
      :desc "Zoom in" :gn "+" #'image-increase-size
      :desc "Zoom in" :gn "-" #'image-decrease-size
      :desc "Zoom in" :gn "0" (cmd! (image-transform-set-scale 1)))
#+END_SRC

*** Wgrep Mode

#+BEGIN_SRC elisp
(map! :map 'wgrep-mode-map
      :localleader
      :desc "Occur" :gn "o" #'my-ivy-occur|evil-mutliedit-last-search
      :desc "Occur" :gn "s" #'my-ivy-occur|evil-ex-last-search)
#+END_SRC

*** Org Mode

#+begin_src elisp
(map! :map org-mode-map
      :localleader
      :desc "Copy Buffer To Markdown"  "Y" #'my-org|copy-buffer-as-markdown
      :desc "Fetch url title"          "u" #'my-org|fetch-this-org-link-title
      :desc "Fetch rss feed from link" "r" #'my-org|fetch-this-org-link-rss
      (:prefix-map ("i" . "Insert")
       :desc "Created Property"        "c" #'my-org|add-created-property
       :desc "Last download"           "d" #'my-attach|last-download))
#+end_src

*** Org Mode Agenda

#+begin_src elisp
(map! :map org-agenda-mode-map
      :localleader
      :desc "Fetch url title" "u" #'my-org-agenda|fetch-this-org-link-title)
#+end_src


** Minibuffer
*** Copy and Paste from the minibuffer

Since the minibuffer has no evil mode, i've got these bindings to help out:
- ~M-c~: Copy the minibuffer line
- ~M-v~: Paste from clipboard to minibuffer (Same as ~C-r 0~)
         This also removes trailing newlines

#+BEGIN_SRC elisp
(defun my-evil|paste-pruned ()
  "Paste the current clipboard pruned from newlines"
  (interactive)
  (insert (s-trim (shell-command-to-string "pbpaste")))
  (doom/forward-to-last-non-comment-or-eol))

(defun my-minibuffer|copy-line ()
  "Copies the minibuffer content to the clipboard"
  (interactive)
  (save-excursion
    (doom/forward-to-last-non-comment-or-eol)
    (set-mark-command nil)
    (doom/backward-to-bol-or-indent)
    (kill-ring-save (mark) (point))))

(defun my-minibuffer/setup-copy-bindings ()
  "Set up keybindings for the minibuffer"
  (local-set-key (kbd "s-v") 'my-evil|paste-pruned)
  (local-set-key (kbd "s-c") 'my-minibuffer|copy-line))

(add-hook 'minibuffer-setup-hook 'my-minibuffer/setup-copy-bindings)

;; (define-key! :keymaps +default-minibuffer-maps
;;   "C-w" 'sp-backward-delete-word)
#+END_SRC

* Hacks
** Override default browser

Why does this not work out of the box?

#+BEGIN_SRC elisp
(defun browse-url-brave (url &optional _new-window)
  "Ask the Chromium WWW browser to load URL.
Default to the URL around or before point.  The strings in
variable `browse-url-chromium-arguments' are also passed to
Chromium.
The optional argument NEW-WINDOW is not used."
  (interactive (browse-url-interactive-arg "URL: "))
  (setq url (browse-url-encode-url url))
  (let* ((process-environment (browse-url-process-environment)))
    (apply #'start-process
           (concat "brave " url) nil
           "brave"
           (append
            browse-url-chromium-arguments
            (list url)))))

(pcase (getenv "BROWSER")
  ("brave" (setq browse-url-browser-function 'browse-url-brave))
  ("chromium" (setq browse-url-browser-function 'browse-url-chromium))
  ("firefox" (setq browse-url-browser-function 'browse-url-firefox)))
#+END_SRC

** Fix ~evil-org-mode-map~

Fixes =(void-function ad-Advice-newline-and-indent)= error for now.
I honestly don't know where this comes from.

#+BEGIN_SRC elisp
(map!
 :map evil-org-mode-map
 :after org
 :i [return] #'org-return-and-maybe-indent)
#+END_SRC
** Prevent ~woman defvaralias~ error

I'm using ~woman~ for manuals, but it throws this error on first launch

#+BEGIN_QUOTE
Warning (defvaralias): Overwriting value of ‘woman-topic-history’ by aliasing to ‘Man-topic-history’
#+END_QUOTE

Solution from here: [[https://discord.com/channels/406534637242810369/406554085794381833/703782241766998067][Doom Discord question]]

#+BEGIN_SRC elisp
(add-to-list 'warning-suppress-types '(defvaralias))
#+END_SRC

** Stupid workaround where splitting a window with evil-ex-results breaks emacs...

#+BEGIN_SRC elisp
(advice-add 'evil-window-vsplit :after #'evil-force-normal-state)
(advice-add 'evil-window-split :after #'evil-force-normal-state)
#+END_SRC
** Emacs 28 Head Workaround

#+begin_src elisp
(with-no-warnings
      (defclass xref-location () ()
        :documentation "(Obsolete) location represents a position in a file or buffer."))
#+end_src
** Make optional

#+begin_src elisp
(defmacro define-obsolete-function-alias ( obsolete-name current-name &optional when
                                           docstring)
  "Set OBSOLETE-NAME's function definition to CURRENT-NAME and mark it obsolete.

\(define-obsolete-function-alias \\='old-fun \\='new-fun \"22.1\" \"old-fun's doc.\")

is equivalent to the following two lines of code:

\(defalias \\='old-fun \\='new-fun \"old-fun's doc.\")
\(make-obsolete \\='old-fun \\='new-fun \"22.1\")

WHEN should be a string indicating when the function was first
made obsolete, for example a date or a release number.

See the docstrings of `defalias' and `make-obsolete' for more details."
  (declare (doc-string 4))
  `(progn
     (defalias ,obsolete-name ,current-name ,docstring)
     (make-obsolete ,obsolete-name ,current-name ,when)))
#+end_src
** Fix Flycheck for emacs 29

#+begin_src elisp
(defun +flycheck/fix-emacs-29-save (&rest args)
  (flycheck-clear)
  (flycheck-buffer))

(advice-add #'flycheck-handle-save :after #'+flycheck/fix-emacs-29-save)
#+end_src
* Temp

#+begin_src elisp
(defun my-dired-unzip-and-convert-cbz-to-pdf ()
  "Unzip a CBZ file and convert its extracted JPG files to PDF asynchronously."
  (interactive)
  (let ((cbz-file (dired-get-filename)))
    (when (and cbz-file (string-match "\\.cbz$" cbz-file))
      (setq cbz-dir (file-name-sans-extension cbz-file))
      (async-shell-command (format "unzip %s -d %s && convert %s/**/*.jpg %s.pdf"
                                   (shell-quote-argument cbz-file)
                                   (shell-quote-argument cbz-dir)
                                   (shell-quote-argument cbz-dir)
                                   (shell-quote-argument cbz-dir))
                           (get-buffer-create "*CBZ Unzip and Convert Output*"))
      (message "CBZ file extraction and conversion initiated.")
      (notifications-notify :title "CBZ Conversion" :body "Conversion process initiated." :timeout 2000))))
#+end_src
