#+TITLE: Doom Emacs configuration
#+AUTHOR: floscr
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: org-startup-folded: showall
#+DISABLE_SPELLCHECKER: t
#+TODO: TODO(t) ACTIVE(a) | INACTIVE(i)

* Docs
** Code style

Most of the code here will follow a functional mindset using [[https://github.com/magnars/dash.el][dash.el]] and [[https://github.com/magnars/s.el][s.el]].
I will prefer those functions over built in functions if they are nicer to use.

I often use my helper function [[file:autoload.org::*Template Literals][(template)]] for template strings.

** Variable Naming

All my private functions have the prefix ~my~.
It's the only prefix where you can assume that packages or emacs won't override it and vice-versa.

*** Schema

- ~my::namespace~
  Its not pretty, but it's the only way to work with emacs-lisps global scope for everything.
  - ~my::namespace::sub-namespace~
- ~my:variable~: Variable
- ~my/function~: Private function
  - ~my::namespace/function~: Private function with namespace
- ~my|function~: Interactive function
  - ~my::namespace|function~: Interactive function
- ~my@function~: Macro

*** Exceptions

There are only a few exceptions, which I'm keeping without the prefix for ease of writing/reading:

- [[*Dash Extensions][Dash Extensions]]
  Prefixed with a ~-~
- [[*Template Literals][Template Literals]]
  ~template~ or ~t~ macros

* Tangle Headers

#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
#+END_SRC

* My Standard Library
:PROPERTIES:
:header-args: :tangle "autoload.el" :comments link
:END:

Macros & Functions that extend my elisp standard library.
If you copy any of my emacs-lisp code, you will need these functions.

Tangles to [[file:autoload.el][autoload.el]]

** Required Package

Packages and utilities needed for this config.

- [[https://github.com/magnars/dash.el][magnars/dash.el: List Manipulation]]
- [[https://github.com/magnars/s.el][magnars/s.el: String Manipulation]]

#+BEGIN_SRC elisp
(require 'dash)
(require 's)
(require 'f)
(require 'noflet)
#+END_SRC

** Macros
*** Template Literals
:PROPERTIES:
:SOURCE:   https://gist.github.com/cbowdon/012d623920bd28453bf8
:END:

#+BEGIN_SRC elisp :tangle no
(template "2 = <<(+ 1 1)>>")
#+END_SRC

#+RESULTS:
: 2 = 2

#+BEGIN_SRC elisp
;;;###autoload
(defmacro template (text)
  "Template literals"
  (let ((pattern "<<\\(.*?\\)>>"))
    ;; The regexp matches anything between delimiters, non-greedily
    (with-temp-buffer
      (save-excursion (insert text))
      (let ((matches '()))
        (while (re-search-forward pattern nil t)
          (push (match-string 1) matches)
          (replace-match "%s" t t))
        `(format ,(buffer-string) ,@(reverse (mapcar 'read matches)))))))

;;;###autoload
(defalias 't! 'template)
#+END_SRC

*** Ignore Arguments
:PROPERTIES:
:SOURCE:   https://emacs.stackexchange.com/a/33063
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defmacro my@ignore-args (fn)
  "Return function that ignores its arguments and invokes FN."
  `(lambda (&rest _rest)
     (funcall ,fn)))
#+END_SRC

** General
*** Noop

#+BEGIN_SRC elisp
;;;###autoload
(defun my/noop (&optional args) nil)
#+END_SRC

*** Without undo

#+BEGIN_SRC elisp
;;;###autoload
(defmacro my/without-undo (&rest forms)
  "Executes FORMS with a temporary buffer-undo-list that is discarded afterwards.
Taken from http://www.emacswiki.org/emacs/UndoCommands with some
modifications."
  `(let* ((buffer-undo-list)
          (modified (buffer-modified-p))
          (inhibit-read-only t))
     (unwind-protect
         (progn ,@forms)
       (set-buffer-modified-p modified)) ()))
#+END_SRC
*** INACTIVE String match or original

#+BEGIN_SRC elisp :tangle no
;;;###autoload
(defun my/s-match-or (regex x)
  "Return match groups or original"
  (interactive)
  (-if-let ((match (s-match regex x)))
      (cdr match)
    (list x)))

;;;###autoload
(defun my/s-match-or-1 (regex x)
  "Return 1st match group or original."
  (interactive)
  (-if-let ((match (s-match regex x)))
      (car (cdr match))
    x))
#+END_SRC
** Buffer
*** Check if buffer has line

#+BEGIN_SRC elisp
(defun my::buffer/contains-line (string)
  (save-excursion
    (save-match-data
      (goto-char (point-min))
      (search-forward string nil t))))
#+END_SRC

*** Get current line indentation

#+BEGIN_SRC elisp
;;;###autoload
(defun my::buffer/line-indent ()
  "Get the indent of the current line."
  (interactive)
  (or (-some->> (substring-no-properties (thing-at-point 'line))
        (s-match "^\\(\s*\\).*\n$")
        (nth 1)
        (length))
      0))
#+END_SRC

*** Check current line for regex

#+BEGIN_SRC elisp
;;;###autoload
(defun my::buffer/line-contains (regexp)
  "Check for REGEXP at current line."
  (save-excursion
    (goto-char (point-at-bol))
    (search-forward-regexp regexp (point-at-eol) t)))
#+END_SRC

*** Delete current line

#+BEGIN_SRC elisp
;;;###autoload
(defun my::buffer/delete-current-line ()
  "Delete (not kill) the current line."
  (interactive)
  (save-excursion
    (delete-region
     (progn (forward-visible-line 0) (point))
     (progn (forward-visible-line 1) (point)))))
#+END_SRC

*** INACTIVE Map buffer lines

#+BEGIN_SRC elisp :tangle no
;;;###autoload
(defun my::buffer/map-lines (fun &optional start end)
  "Map lines in buffer with FUN, fn gets called with the line contents."
  (let ((start (or start (point-min)))
        (end (or end (point-max)))
        (lines (list)))
    (save-excursion
      (goto-char start)
      (while (< (point) end)
        (add-to-list 'lines
          (funcall fun (buffer-substring (line-beginning-position) (line-end-position))))
        (forward-line 1))
      (erase-buffer)
      (->> lines
           reverse
           (s-join "\n")
           insert))))
#+END_SRC
** Shell Commands & Aliases
*** Async Command No Window
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/a/47910509/2298462][How to avoid pop-up of *Async Shell Command* buffer in Emacs?]]
:END:

Prevent ~async-shell-command~ displaying a popup or a buffer.

#+BEGIN_SRC elisp
(defun my::shell/async-command-no-window (command)
  "Execute async command without showing the result buffer."
  (interactive)
  (let ((display-buffer-alist (list (cons "\\*Async Shell Command\\*.*" (cons #'display-buffer-no-window nil)))))
    (async-shell-command command)))
#+END_SRC

*** Shell command to list

#+BEGIN_SRC elisp
(defun my::shell/command-to-list (cmd)
  "Split output from shell-command to list"
  (split-string (shell-command-to-string cmd) "\n" t))
#+END_SRC

*** Start process that stays alive

I don't want some processes to exit, when I close emacs.

#+BEGIN_SRC elisp
;;;###autoload
(defun my::shell/no-exit-command (cmd &optional &rest args)
  "Launch a shell command, without opening a message buffer.
The proram persists when emacs is closed."
  (let ((args-str (or (-some->> args
                        (s-join " "))
                      "")))
    (call-process-shell-command
       (template "nohup 1>/dev/null 2>/dev/null <<cmd>> <<args-str>> &") nil nil)))
#+END_SRC

*** Open youtube link with MPV

#+BEGIN_SRC elisp
;;;###autoload
(defun my::shell/mpv-youtube-url (url)
  (-when-let* ((quality-val
                (-some->> (completing-read
                            "Max height resolution (0 for unlimited): "
                            '("720" "0" "480" "1080"))
                  (string-to-number)))
               (quality-arg (if (> 0 quality-val)
                                (template "--ytdl-format=\"[height<=?<<quality-val>>]\"")
                              "")))
    (message (template "Opening <<url>> at <<quality-val>> with mpv…"))
    (my::shell/no-exit-command "mpv" quality-arg (s-wrap url "\""))))
#+END_SRC
** Files
*** Get file timestamp

#+BEGIN_SRC elisp
;;;###autoload
(defun my::file/timestamp (path)
  (->> (file-attributes path)
       (nth 5)))
#+END_SRC

*** Get the last modified file in directory
:PROPERTIES:
:SOURCE:   https://stackoverflow.com/a/30886283
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defun my::file/last-modified-file-in-dir (path)
  (->> (f-entries path)
       (-sort (lambda (a b) (not (time-less-p (my::file/timestamp a)
                                              (my::file/timestamp b)))))
       (car)))
#+END_SRC

*** Chmod current file

#+BEGIN_SRC elisp
;;;###autoload
(defun my::file|chmod-this-file ()
  "Chmod +x the current file."
  (interactive)
  (shell-command (template "chmod +x \"<<(buffer-file-name)>>\"")))
#+END_SRC
*** Dir has hidden entry

#+BEGIN_SRC elisp
(defun my::file/dir-has-hidden-entries (dir)
  "Check if a DIR has any hidden entries.
Return the first found file when one is found."
  (--find (s-starts-with-p "." (f-filename it)) (f-entries dir)))
#+END_SRC

*** Find project root

#+BEGIN_SRC elisp
(defun my::file/project-root ()
  "Find the project root either via projectile (not available in certain buffers like dired)
or manually traverse upwards until the .git directory is found."
  (interactive)
  (or
   projectile-project-root
   (f--traverse-upwards (f-exists? (f-expand ".git" it)))))
#+END_SRC
** Debugging / Logging
*** Kill and Message

#+BEGIN_SRC elisp
;;;###autoload
(defun my/kill-and-message (x)
  "Executes kill-new but with a message log side effect."
  (kill-new x)
  (message "Copied to clipboard: %s" x))
#+END_SRC

*** Convert boolean to enabled/disabled string

#+BEGIN_SRC elisp
(defun my/bool-to-enabled-string (x)
  "Convert bool X to string for messaging.
t   -> \"Enabled\")
nil -> \"Disabled\""
  (if x "Enabled" "Disabled"))
#+END_SRC

*** Variable t/nil toggle message

#+BEGIN_SRC elisp
(defun my/bool-state-message (x)
  "Log message if a bool is enabled or not"
  (interactive)
  (message (t! "<<(symbol-name x)>>: <<(my/bool-to-enabled-string (symbol-value x))>>")))
#+END_SRC

** Dash Extensions
*** -tap

Run a side effect ~fn~ on the initial input ~x~.
But Return the original input ~x~.

#+BEGIN_SRC elisp
;;;###autoload
(defun -tap (fn x)
  "Function docstring"
  (funcall fn x)
  x)

;;;###autoload
(defmacro --tap (fn it)
  "Anaphoric form of `-tap'."
  `(-tap (lambda (it) ,fn) ,it))
#+END_SRC

*** -log

Log the current input without breaking the pipe.

#+BEGIN_SRC elisp
;;;###autoload
(defun -log (x)
  "Function docstring"
  (--tap (message "%s" it) x))
#+END_SRC

*** -when

#+BEGIN_SRC elisp
;;;###autoload
(defun -when (pred fn x)
  "When FN equals t forward X."
  (if pred
      (funcall fn x)
    x))

;;;###autoload
(defmacro --when (pred form xs)
  "Anaphoric form of -id-when"
  (declare (debug (form form)))
  `(let ((it ,xs))
     (if ,pred
         ,form
       ,xs)))
#+END_SRC

*** -id-when

#+BEGIN_SRC elisp
;;;###autoload
(defun -id-when (fn x)
  "When FN equals t forward X."
  (when (funcall fn x) x))

;;;###autoload
(defmacro --id-when (form xs)
  "Anaphoric form of -id-when"
  (declare (debug (form form)))
  `(let ((it ,xs))
     (when ,form ,xs)))
#+END_SRC

*** -append

#+BEGIN_SRC elisp
;;;###autoload
(defun -append (elem list)
  "Append ELEM to the end of list.

This is like -snoc but it takes the ELEM as the first argument for easier composition"
  (-snoc list elem))
#+END_SRC

*** -shuffle
:PROPERTIES:
:SOURCE:   [[http://kitchingroup.cheme.cmu.edu/blog/2014/09/06/Randomize-a-list-in-Emacs/][Randomize a list in Emacs]]
:END:

#+BEGIN_SRC elisp
(defun swap-list-items (LIST el1 el2)
  "in LIST swap indices EL1 and EL2 in place"
  (let ((tmp (elt LIST el1)))
    (setf (elt LIST el1) (elt LIST el2))
    (setf (elt LIST el2) tmp)))

;;;###autoload
(defun -shuffle (LIST)
  "Shuffle the elements in LIST.
shuffling is done in place."
  (loop for i in (reverse (number-sequence 1 (1- (length LIST))))
        do (let ((j (random (+ i 1))))
             (swap-list-items LIST i j)))
  LIST)
#+END_SRC

*** -f-join

#+BEGIN_SRC elisp
;;;###autoload
(defun -f-join (x path)
  "Reversed argument order for f-join"
  (f-join path x))
#+END_SRC

*** -f-tildify

#+BEGIN_SRC elisp
;;;###autoload
(defun f-tildify (path)
  "Replace the HOME directory in path"
  (s-replace-regexp (t! "^<<(getenv \"HOME\")>>") "~" path))
#+END_SRC





* Default Configuration
** Temp

Include colons as delimiters for now

#+begin_src elisp
(modify-syntax-entry ?: "w" emacs-lisp-mode-syntax-table)
(modify-syntax-entry ?: "w" org-mode-syntax-table)
(modify-syntax-entry ?: "w" grep-mode-syntax-table)
#+end_src

** Secrets

Config files that I don't want to share with the world.
They will be stored in here:

#+BEGIN_SRC elisp
(defvar my::secrets:config-file nil
  "My private config file.")
(setq my::secrets:config-file "~/.config/secrets.el")
#+END_SRC

And I will load them on system start:

#+BEGIN_SRC elisp
(defun my::secrets/load-config-file ()
  (-some->> my::secrets:config-file
    (-id-when 'file-exists-p)
    (load-library)))

(my::secrets/load-config-file)
#+END_SRC
** Custom Variables
*** Directories
**** Downloads

#+BEGIN_SRC elisp
(defcustom my::directories:downloads-dir "~/Downloads"
  "Downloads Directory"
  :type 'string)
#+END_SRC

**** Repositories

#+BEGIN_SRC elisp
(defcustom my::directories:repositories-dir "~/Code/Repositories"
  "Downloads Directory"
  :type 'string)
#+END_SRC

** Emacs
*** Move items to trash on delete

#+BEGIN_SRC elisp
(setq
 trash-directory "~/.Trash/"
 delete-by-moving-to-trash t)
#+END_SRC

*** Automatically reload tags files

#+BEGIN_SRC elisp
(setq tags-revert-without-query 1)
#+END_SRC

*** Disable blinking cursor

#+BEGIN_SRC elisp
(blink-cursor-mode -1)
(setq blink-matching-paren nil)
(setq visible-cursor nil)
#+END_SRC
*** Safe local variables

Variables that I want to safely set from ~.dir-locals~ files.

#+BEGIN_SRC elisp
(put '+file-templates-dir 'safe-local-variable #'stringp)
#+END_SRC

*** Buffer naming

#+BEGIN_SRC elisp
(setq uniquify-buffer-name-style 'forward)
#+END_SRC

*** Load ~.authinfo.gpg~ for authentication :AUTH:

#+BEGIN_SRC elisp
(add-to-list 'auth-sources "~/.config/gnupg/.authinfo.gpg")
#+END_SRC

*** Disable ~dcl~ mode for password files :AUTH:FIX:

Since it has the regex matching ~.com~ it's enabled for all my password files,
which I name after the matching url.

#+BEGIN_SRC elisp
(setq auto-mode-alist (rassq-delete-all 'dcl-mode auto-mode-alist))
#+END_SRC

** Doom
*** Popups

#+BEGIN_SRC elisp
(set-popup-rules!
  '(("^\\*Org Agenda" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*Org Src" :ignore t)
    ("^\\*Org QL View: \\(Work \\)?Projects*" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*PDF-Occur*" :side right :size 0.5 :select t :modeline t)
    ("^\\*WoMan " :side right :size 0.5 :select t :modeline t :ttl nil :quit nil)
    ("^\\*helm" :vslot -100 :size 0.32 :ttl nil)
    ("^\\*helpful command" :side right :size 0.5 :select t :modeline t :ttl nil :quit nil)
    ("^\\*nodejs" :side right :size 0.55 :select t :modeline t :ttl nil :quit nil)
    ("^\\*jest" :select nil)
    ("^\\*projectile-files-errors" :ignore t)
    ("^\\*elfeed-entry" :modeline t :ttl nil)
    ("^\\*Flycheck checker" :size 0.2 :select nil)))
#+END_SRC

*** Garbage collection

Set it to =32 MiB=.

#+BEGIN_SRC elisp
(setq doom-gc-cons-threshold 33554432)
#+END_SRC

** Evil
*** Enable fine undo

Whether evil actions like =cw= are undone in several steps.
This is sometimes annoying, as it might need you to press =u= multiple times.
But I prefer the fine grained control, as I'm often staying longer in insert mode,
and don't want one single undo action for the whole "session".

#+BEGIN_SRC elisp
(setq evil-want-fine-undo t)
#+END_SRC

** Hacks
*** Override default browser

Why does this not work out of the box?

#+BEGIN_SRC elisp
(defun browse-url-brave (url &optional _new-window)
  "Ask the Chromium WWW browser to load URL.
Default to the URL around or before point.  The strings in
variable `browse-url-chromium-arguments' are also passed to
Chromium.
The optional argument NEW-WINDOW is not used."
  (interactive (browse-url-interactive-arg "URL: "))
  (setq url (browse-url-encode-url url))
  (let* ((process-environment (browse-url-process-environment)))
    (apply #'start-process
           (concat "brave " url) nil
           "brave"
           (append
            browse-url-chromium-arguments
            (list url)))))

(pcase (getenv "BROWSER")
  ("brave" (setq browse-url-browser-function 'browse-url-brave))
  ("chromium" (setq browse-url-browser-function 'browse-url-chromium))
  ("firefox" (setq browse-url-browser-function 'browse-url-firefox)))
#+END_SRC



* Custom Packages
** TODO Custom Bookmarks
*** Config
**** Disable Emacs bookmarks

#+BEGIN_SRC elisp
(setq bookmark-save-flag nil)

;; Can't set to nil as bookmarks are still set up to hooks
;; Instead I'll keep it in this file which will be trashed on every reboot
(setq bookmark-file "/tmp/emacs-bookmarks-file")
#+END_SRC
**** Main Bookmarks

#+begin_src elisp
(setq
 +bookmarks:main
 '(((file . "~/.config/doom/modules/private/work/config.org")
    (name . "Config: Work")
    (goto . "* Configuration")
    (goto-bol . t)
    (disable-relocation . t))
   ((file . "~/.config/dotfiles/config/xmonad/xmonad.hs")
    (name . "Xmonad"))
   ((file . "~/.config/doom/autoload.org")
    (name . "Config: Autoloads"))
   ((file . "~/.config/doom/modules/private/org/config.org")
    (name . "Config: Org"))
   ((fn . (lambda () (find-file +bookmarks:local-bookmarks-file)))
    (name . "Bookmarks: Local"))
   ((file . "~/.config/doom/config.org")
    (name . "Bookmarks: Main")
    (goto . "*** Main Bookmarks")
    (goto-bol . t))
   ((fn . (lambda () (find-file (getenv "HISTFILE"))))
    (name . "Shell History")
    (goto-bol . t))
   ((file . "~/.config/doom/modules/private/work/config.org")
    (name . "Bookmarks: Work")
    (goto . "*** Bookmarks")
    (goto-bol . t))
   ((file . "/etc/dotfiles/modules/desktop/common.nix")
    (name . "Mimeapps")
    (goto . "### Mimeapps")
    (goto-bol . t))
   ((file . "~/.config/weechat/xfer")
    (name . "Weechat Xfer"))
   ((file . "/run/media/floscr/tolino")
    (name . "Tolino"))
   ((org . "[[orgit:/ssh:mm-web-vagrant:/home/vagrant/mindmeister/][/ssh:mm-web-vagrant:/home/vagrant/mindmeister/ (magit-status)]]")
    (name . "Vagrant: mindmeister magit status"))
   ((org . "[[orgit:/ssh:mm-web-vagrant:/home/vagrant/mindmeister-web/][/ssh:mm-web-vagrant:/home/vagrant/mindmeister-web/ (magit-status)]]")
    (name . "Vagrant: mindmeister-web magit status"))
   ((file . "~/Documents/Scans/Scans.org")
    (name . "Scans"))
   ((fn . org-capture-goto-last-stored)
    (name . "Capture: Last Stored Marker"))))
#+end_src
*** Functions

#+BEGIN_SRC elisp
(defun +bookmarks|main ()
  (interactive)
  (+bookmarks (-concat +bookmarks:main (+bookmarks/local/list))))
#+END_SRC

Bookmarks for projects with using a [[file:bookmarks.json][bookmarks.json]] file at the project root.

#+BEGIN_SRC elisp
(defvar +bookmarks:local-bookmarks-file nil)
(setq +bookmarks:local-bookmarks-file (f-join doom-local-dir "bookmarks.json"))

(defun +bookmarks/find-bookmarks (x &optional &key other-window?)
  "Jump to a X relative to the project root, go to character POS."
  (require 'link-hint)
  (-when-let* ((find-fn (if other-window? 'find-file-other-window 'find-file))
               (item (car x)))
    (let* ((file (-some->> (alist-get 'file item)
                   (--when (alist-get 'relative item)
                           (f-join (projectile-project-root) it))))
           (buffer-is-open (when file (get-file-buffer file))))
      (when file
        (funcall find-fn file)
        (+workspaces-add-current-buffer-h))
      (when-let ((fn (alist-get 'fn item)))
        (funcall fn))

      ;; org item
      (-some--> (alist-get 'org item)
        (link-hint--open-org-link it)
        ((lambda ()
           (when (alist-get 'narrow item)
             (org-narrow-to-element)))))

      ;; goto, disable-relocation
      ;; Go to a location matched by regex
      ;; Unless disable-relocation is enabled and the file is already visited
      (-some--> (alist-get 'goto item)
        (--id-when (or (not buffer-is-open)
                       (not (alist-get 'disable-relocation item))) it)
        (--tap (progn
                 (goto-char (point-min))
                 (cond
                  ((eq 'integer (type-of it))
                   (goto-line it))
                  ((eq 'string (type-of it))
                   (search-forward it))))
               it))
      ;; action
      ;; Execute a function after find file
      (-some--> (alist-get 'action item)
        (call-interactively it))
      ;; goto-bol
      ;; Go to the beginning, since the regex search
      ;; will leave the cursor at the end of the search
      (-some--> (alist-get 'goto-bol item)
        (evil-first-non-blank)))))

(defun +bookmarks/local/save (xs)
  "Save an alist as json to the +bookmarks:local-bookmarks-file"
  (->> xs
       (json-encode)
       ((lambda (x) (f-write x 'utf-8 +bookmarks:local-bookmarks-file)))))

(defun +bookmarks/find-bookmarks-other-window (x)
  "Open bookmark X in other window, used with ivy action 'j'."
  (+bookmarks/find-bookmarks (cdr x) :other-window? t))

(defun +bookmarks/local|save ()
  (interactive)
  (let ((entry `((file . ,(buffer-file-name))
                 (goto . ,(line-number-at-pos))
                 (name . ,(read-string "Bookmark Name: ")))))
    (->> (+bookmarks/local/list)
      (-append entry)
      (+bookmarks/local/save))))

(defun +bookmarks/local/kill (x)
  (->>
   (--remove (cl-equalp (car (cdr x)) it) (+bookmarks/local/list))
   (+bookmarks/local/save)))

(defun +bookmarks/local/rename (x)
  (require 'a)
  (-let ((item (car (cdr x))))
    (-log (a-get (cdr item) :name))
    (->>
     (+bookmarks/local/list)
     (--map-first (cl-equalp item it) (a-update it 'name (lambda (x) (read-string "Rename Bookmark: " x))))
     (+bookmarks/local/save))))

(defun +bookmarks/local/list ()
  (-some->> +bookmarks:local-bookmarks-file
    (-id-when #'f-exists?)
    (json-read-file)
    (-map 'identity)))

;;;###autoload
(defun +bookmarks (&optional bookmarks-list)
  "Either take alist BOOKMARKS-LIST or look for bookmarks.json in project root.
If found, show an ivy window with the bookmarks"
  (interactive)
  (-if-let*
      ((bookmarks
        (or bookmarks-list
            (+bookmarks/local/list)))
       (bookmarks (--map (list (alist-get 'name it) it) bookmarks)))
      (ivy-read "Bookmark: " bookmarks
                :action (lambda (x) (+bookmarks/find-bookmarks (cdr x)))
                :caller #'+bookmarks|find-bookmarks)
    (user-error "No bookmarks file found at project root.")))

(after! ivy
  (ivy-set-actions
   '+bookmarks|find-bookmarks
   '(("j" +bookmarks/find-bookmarks-other-window "open in other window")
     ("k" +bookmarks/local/kill "Remove")
     ("r" +bookmarks/local/rename "Rename"))))
#+END_SRC
** TODO LY: Evil Lisp Navigation

A navigation system for lisp languages that I'm comfortable with,
like evil but with a more =sexp= based navigation.

Alternatives I've used:

- [[https://github.com/countvajhula/symex.el][countvajhula/symex.el]]
  My main inspiration.
  Too tree based for my taste, I after have to think about the code structure before I can execute actions.

*** Minor Mode

#+BEGIN_SRC elisp
(set-frame-parameter nil 'internal-border-width 15)
(defvar +ly-mode-map (make-sparse-keymap))

(define-minor-mode +ly-mode
  "Open org headlines in an indirect window buffer."
  :keymap +ly-mode-map)

(map! :map +ly-mode-map
      :n "gj"     #'evil-next-line
      :n "gk"     #'evil-previous-line
      :n "M-j"    #'+ly|forward-line
      :n "M-k"    #'+ly|backward-line
      :n "M-u"    #'+ly|up-atom
      :n "M-f"    #'+ly|forward-atom
      :n "M-b"    #'+ly|backward-atom
      :n "M-l"    #'+ly|forward-brace
      :n "M-h"    #'+ly|backward-brace
      :n "M-,"    #' symex-shift-backward
      :n "M-."    #'symex-shift-forward
      :n "M-o"    #'symex-open-line-after
      :ni "<C-return>" #'+ly|add-atom
      :n "M-RET" (cmd!
                  (parinfer-toggle-mode)
                  (parinfer-lispy:newline)
                  (parinfer-toggle-mode))
      :n "M-Y" (cmd!
                (symex-yank)
                (symex-paste-after)
                (symex-insert-newline)))

;; HACK: map not working intially
(defun +ly/activate-mode-hook ()
  (require 'symex)
  (evil-insert-state)
  (evil-normal-state))

;; Mappings only get applied after reinserting normal mode
(add-hook '+ly-mode-hook #'+ly/activate-mode-hook)
#+END_SRC

*** Utils
**** Sexp Navigation

#+BEGIN_SRC elisp
(setq +ly:brace-regexp "([^() ]")
(setq +ly:atom-regexp "[^() ]")

(defun +ly|forward-atom ()
  "Go to next atom."
  (interactive)
  (require 'symex)
  (symex-traverse-forward)
  (while (or (eq ?\( (char-after)))
    (symex-traverse-forward)))

(defun +ly|backward-atom ()
  "Go to next atom."
  (interactive)
  (require 'symex)
  (symex-traverse-backward)
  (while (or (eq ?\( (char-after)))
    (symex-traverse-backward)))

(defun +ly|forward-brace ()
  "Go to next sexp brace."
  (interactive)
  (require 'symex)
  (symex-go-up)
  (search-forward-regexp +ly:brace-regexp nil t)
  (backward-char 2))

(defun +ly|backward-brace ()
  "Go to previous sexp brace."
  (interactive)
  (require 'symex)
  (unless (eq ?\( (char-after))
    (symex-go-down))
  (search-backward-regexp +ly:brace-regexp nil t))

(defun +ly|up-atom ()
  "Go up the tree"
  (interactive)
  (require 'symex)
  (symex-go-down))
#+END_SRC

**** Line Navigation

#+BEGIN_SRC elisp
(defun +ly|forward-line ()
  "Function docstring"
  (interactive)
  (next-line 1)
  (goto-char (point-at-bol))
  (search-forward-regexp "\s*[^\s]" nil t)
  (backward-char 1))

(defun +ly|backward-line ()
  "Function docstring"
  (interactive)
  (previous-line 1)
  (goto-char (point-at-bol))
  (search-forward-regexp "\s*[^\s]" nil t)
  (backward-char 1))
#+END_SRC
**** List Modification

***** Add to list

#+BEGIN_SRC elisp
(defun +ly/inside-string? ()
  "Returns non-nil if inside string, else nil.
Result depends on syntax table's string quote character."
  (nth 3 (syntax-ppss)))

(defun +ly|add-atom (&optional same-line?)
  "Add atom in the current sexp. If the cursor is under a string match the type and insert another string."
  (interactive "P")
  (let ((was-parinfer-list-mode (eq 'paren parinfer--mode)))
    (up-list 1 t)
    (unless same-line?
      (parinfer-lispy:newline))
    (when same-line? (insert " "))
    (cond ((+ly/inside-string?)
           (insert (t! "\"\""))
           (backward-char 1)))
    (evil-insert-state)))
#+END_SRC

*** Hydra

#+BEGIN_SRC elisp
(defhydra +ly|hydra ()
   "Ly Navigation"
   ("f" (+ly|forward-brace) "Forward ()" :column "Navigate")
   ("b" (+ly|backward-brace) "Backward ()")
   ("f" (+ly|forward-brace) "forward ()" :column "Navigate")
   ("b" (+ly|backward-brace) "Backward ()")
   ("j" (+ly|forward-line) "Next Line")
   ("k" (+ly|backward-line) "Backward Line"))
#+END_SRC

** TODO Indirect Indent Mode

Adds minor mode for editing indented source code in an indirect buffer,
with the indentation reset to 0.
Saving and committing keeps the indentation in the source buffer.

#+BEGIN_SRC elisp
(defvar-local +indirect-indent 0)

(defvar +indirect-indent-mode-map (make-sparse-keymap))

(define-minor-mode +indirect-indent-mode
  "Editing indented source code without the indent in an indirect buffer."
  :keymap +indirect-indent-mode-map)

(map! :map +indirect-indent-mode-map
      :gni "s-s" #'edit-indirect-save)

(add-hook! +indirect-indent-mode
           (defun +indirect-indent/init-hook ()
             (setq header-line-format
                   "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")))

(advice-add #'edit-indirect-commit :before #'+indirect-indent/restore-indentation)
(advice-add #'edit-indirect-save :after #'+indirect-indent/remove-indentation)
(advice-add #'edit-indirect-save :before #'+indirect-indent/restore-indentation)

(defun +indirect-indent/restore-indentation ()
  (when (and (bound-and-true-p +indirect-indent-mode)
             (not (eq +indirect-indent 0)))
    (my/without-undo
      (indent-rigidly (point-min) (point-max) (+ +indirect-indent)))))

(defun +indirect-indent/remove-indentation ()
  (when (and (bound-and-true-p +indirect-indent-mode)
             (not (eq +indirect-indent 0)))
    (my/without-undo
      (indent-rigidly (point-min) (point-max) (- +indirect-indent)))))

(defun +indirect-indent|edit (beg end &optional with-mode)
  "Edit script in an indirect buffer."
  (interactive)
  (edit-indirect-region beg end t)
  (let ((indent (indent-rigidly--current-indentation (point-min) (point-max))))
    (unless (eq indent 0)
      (my/without-undo
       (indent-rigidly (point-min) (point-max) (- indent)))
      ;; Local variables get undone when calling a mode
      ;; So we have to define the major mode before
      (funcall with-mode)
      (+indirect-indent-mode 1)
      (setq +indirect-indent indent))))
#+END_SRC


* New Package Configuration
** Emacs :EMACS:
*** Libraries

Packages that enhance or fix ~emacs-lisp~.

**** [[https://github.com/nicferrier/emacs-noflet][noflet]] :FIX:

Override functions like variables with using ~(flet ((#'my-fn)))~

Since ~flet~ was deprecated, I'm using this for now.
Pretty much only used in [[*Expand snippet by name][Expand snippet by name]].

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! noflet)
#+END_SRC
*** Completion
**** [[https://github.com/raxod502/prescient.el][company-prescient]] :EMACS:

Better sorting for company

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! prescient)
(package! company-prescient)
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! prescient
  :config
  (prescient-persist-mode 1))

(use-package! company-prescient
  :after company
  :config
  (company-prescient-mode 1))
#+END_SRC
*** Spell Checking
**** Flyspell
***** Defer flyspell until first ~evil-insert-state~

Flyspell most of the time is an annoyance when opening a file just for reading.
I mostly only need it when writing text (sometimes when reviewing, but then I can toggle it manually).

So I defer it until the first text change has been done (or the first insert state).
I've tried it on the ~first-change-hook~, but that is also affected by changing todo states for example in ~org-mode~.

#+begin_src elisp
(defun +flyspell/load-after-first-insert--activate ()
  "Turns on flyspell after the first buffer change or evil-insert state."
  (remove-hook! '(first-change-hook evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert)
  (remove-hook! '(first-change-hook evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert--activate)
  (spell-fu-mode 1))

(defun +flyspell/load-after-first-insert ()
  "Turns on flyspell after the first buffer evil-insert state.
Exception for org mode when the header property \"DISABLE_SPELLCHECKER\" is set."
  (cond ((and (equal major-mode 'org-mode) (+org/get-global-property "DISABLE_SPELLCHECKER")) nil)
        (t (add-hook! '(evil-insert-state-entry-hook) :local #'+flyspell/load-after-first-insert--activate))))

(use-package! flyspell
  :init
  (remove-hook! '(org-mode-hook markdown-mode-hook) #'flyspell-mode)
  (remove-hook! '(org-mode-hook markdown-mode-hook text-mode-hook) #'spell-fu-mode)
  (add-hook! '(org-mode-hook markdown-mode-hook) :local #'+flyspell/load-after-first-insert))
#+end_src

*** LSP
** Text Editing :TEXT:
*** Packages
**** [[https://github.com/btford/write-good][btford/write-good: Naive linter for English prose]] :LINTING:DOOM:
***** Config
****** Disable doom defined hooks for writegood mode

#+BEGIN_SRC elisp
(use-package! writegood-mode
  :hook 'nil)
#+END_SRC

****** Disable ~writegood-mode~ with ~spell-fu~ mode

#+BEGIN_SRC elisp
(defun +spell-fu/activate-writegood-mode-hook ()
  "Toggle writegood mode with spell-fu mode."
  (cond
   (spell-fu-mode (writegood-mode 1))
   (t (writegood-mode -1))))

(add-hook! 'spell-fu-mode-hook :after #'+spell-fu/activate-writegood-mode-hook)
#+END_SRC
**** [[https://github.com/joostkremers/writeroom-mode][joostkremers/writeroom-mode: Writeroom-mode: distraction-free writing for Emacs.]] :DOOM:

***** Config

****** Custom Design :FIX:

#+BEGIN_SRC elisp
(defun my::writeroom/setup ()
  (if writeroom-mode
      (my::writeroom/load)
    (my::writeroom/unload)))

(defun my::writeroom/load ()
  (setq-local line-spacing 0.4)
  (setq-local +writeroom:faceremaps
              (list
               (face-remap-add-relative
                'org-link `(:foreground ,(face-attribute 'default :foreground)
                            :underline ,(face-attribute 'default :foreground)
                            :weight normal))
               (face-remap-add-relative
                'default `(:foreground ,(doom-blend
                                         (face-attribute 'default :background)
                                         (face-attribute 'default :foreground)
                                         0.1))))))

(defun my::writeroom/unload ()
  (kill-local-variable 'line-spacing)
  (mapc #'face-remap-remove-relative +writeroom:faceremaps)
  (kill-local-variable '+writeroom:faceremaps))

(add-hook! 'writeroom-mode-hook #'my::writeroom/setup)
#+END_SRC

** Programming :PROGRAMMING:
*** General Purpose
**** INACTIVE [[https://github.com/emacs-tree-sitter/elisp-tree-sitter][tree-sitter]] :EMACS:

***** Package

#+BEGIN_SRC emacs-lisp :tangle no
(package! tree-sitter)
(package! tree-sitter-langs)
#+end_src

***** Config

#+begin_src emacs-lisp :tangle no
(use-package! tree-sitter
  :config
  (require 'tree-sitter-langs)
  ;; (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src
**** [[https://github.com/chubin/cheat.sh][cheat-sh]] :CLI:

Community collection of snippets for command line tools.

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! cheat-sh)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package cheat-sh
  :commands (cheat-sh)
  :config
  (setq cheat-sh-topic-mode-map
        '((awk-mode . "awk")
          (c++-mode . "cpp")
          (c-mode . "c")
          (clojure-mode . "clojure")
          (clojurescript-mode . "clojure")
          (dockerfile-mode . "docker")
          (emacs-lisp-mode . "elisp")
          (fish-mode . "fish")
          (go-mode . "go")
          (haskell-mode . "haskell")
          (hy-mode . "hy")
          (java-mode . "java")
          (js-jsx-mode . "javascript")
          (js-mode . "javascript")
          (js-mode . "js")
          (lisp-interaction-mode . "elisp")
          (lisp-mode . "lisp")
          (objc-mode . "objectivec")
          (pike-mode . "pike")
          (powershell-mode . "powershell")
          (python-mode . "python")
          (rust-mode . "rust")
          (sh-mode . "bash")
          (nim-mode . "nim"))))
#+END_SRC
**** [[https://github.com/smihica/emmet-mode][emmet-mode]] :CSS:
***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! emmet-mode)
#+end_src

***** Functions
****** Indent or Yase Emmet Expand

Source: [[file:~/.emacs.d/modules/lang/web/autoload/html.el::defun +web/indent-or-yas-or-emmet-expand (][Doom: modules/lang/web/autoload/html.el]]

#+begin_src emacs-lisp
(defun my:emmet/indent-or-yas-or-emmet-expand ()
  "Do-what-I-mean on TAB.

Invokes `indent-for-tab-command' if at or before text bol, `yas-expand' if on a
snippet, or `emmet-expand-yas'/`emmet-expand-line', depending on whether
`yas-minor-mode' is enabled or not."
  (interactive)
  (call-interactively
   (cond ((or (<= (current-column) (current-indentation))
              (not (eolp))
              (not (or (memq (char-after) (list ?\n ?\s ?\t))
                       (eobp))))
          #'indent-for-tab-command)
         ((featurep! :editor snippets)
          (require 'yasnippet)
          (if (yas--templates-for-key-at-point)
              #'yas-expand
            #'emmet-expand-yas))
         (#'emmet-expand-line))))
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! emmet-mode
  :preface (defvar emmet-mode-keymap (make-sparse-keymap))
  :hook (css-mode web-mode html-mode haml-mode nxml-mode)
  :config
  (when (require 'yasnippet nil t)
    (add-hook 'emmet-mode-hook #'yas-minor-mode-on))
  (setq emmet-move-cursor-between-quotes t)
  (map! :map emmet-mode-keymap
        :v [tab] #'emmet-wrap-with-markup
        [tab] #'my:emmet/indent-or-yas-or-emmet-expand
        "M-E" #'emmet-expand-line))
#+END_SRC
**** [[https://elpa.gnu.org/packages/rainbow-mode.html][rainbow-mode]] :UI:

Pretty print colors string with the color as the background.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! rainbow-mode)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package rainbow-mode
  :commands (rainbow-mode)
  :config
  ;; Always enable rgb, etc colors
  (setq rainbow-html-colors t))
#+END_SRC

*** Database
**** Packages

***** TODO [[https://github.com/kiwanami/emacs-edbi][kiwanami/emacs-edbi: Database Interface for Emacs Lisp]]

****** Config

#+BEGIN_SRC elisp
(use-package! package)
#+END_SRC

****** Bridge

Add nix-shell headers to the bridge

Use with header ~:tangle "edbi-bridge.pl"~

#+BEGIN_SRC perl :tangle no
#! /usr/bin/env nix-shell
#! nix-shell -i perl -p mysql -p perlPackages.DBDmysql perlPackages.RPCEPCService perlPackages.DBDPg perlPackages.DBI

use strict;
use RPC::EPC::Service;
use Data::Dumper;
use DBI;

our $dbh = undef;
our $sth = undef;

sub edbi_connect {
  my ($args) = @_;
  my ($data_source,$username,$auth) = @$args;

  # No input _probably_ means "no password" rather than empty string
  $auth = undef if($auth eq "");

  if ($dbh) {
    eval {
      $dbh->disconnect();
    }
  }

  our $dbh = DBI->connect($data_source, $username, $auth)
      or die("Could not connect to database:
Data Source ($data_source)
User Name: ($username):
DBI error: ($DBI::errstr)
");

  return $dbh->get_info(18);
}

sub edbi_do {
  return undef unless $dbh;
  my ($args) = @_;
  my ($sql, $params) = @$args;
  my $rows = $dbh->do($sql, undef, @$params);
  return $rows;
}

sub edbi_select_all {
  return undef unless $dbh;
  my ($args) = @_;
  my ($sql, $params) = @$args;
  my $rows = $dbh->selectall_arrayref($sql, undef, @$params);  return $rows;
}

sub edbi_prepare {
  return undef unless $dbh;
  $sth->finish() if $sth;
  my ($sql) = @_;
  our $sth = $dbh->prepare($sql) or return undef;
  return 'sth';
}

sub edbi_execute {
  return undef unless $sth;
  my ($params) = @_;
  return $sth->execute(@$params) or return undef;
}

sub edbi_fetch_columns {
  return undef unless $sth;
  return $sth->{NAME};
}

sub edbi_fetch {
  return undef unless $sth;
  my ($num) = @_;
  if ($num eq undef) {
    return $sth->fetchall_arrayref();
  } else {
    my $ret = [];
    for (my $i = 0; $i < $num; $i++) {
      my $row = $sth->fetchrow_arrayref();
      last if $row eq undef;
      push @$ret, [@$row];
    }
    return $ret;
  }
}

sub edbi_auto_commit {
  return undef unless $dbh;
  my ($flag) = @_;
  if ($flag eq "true") {
    $dbh->{AutoCommit} = 1;
    return 1;
  } else {
    $dbh->{AutoCommit} = 0;
    return 0;
  }
}

sub edbi_commit {
  return undef unless $dbh;
  $dbh->commit();
  return 1;
}


sub edbi_rollback {
  return undef unless $dbh;
  $dbh->rollback();
  return 1;
}

sub edbi_disconnect {
  return undef unless $dbh;
  $dbh->disconnect();
  return 1;
}

sub edbi_status {
  return undef unless $dbh;
  return [$dbh->err, $dbh->errstr, $dbh->state];
}

sub edbi_type_info_all {
  return undef unless $dbh;
  my $ret = $dbh->type_info_all;
  print STDERR Dumper $ret;
  return $dbh->type_info_all;
}

sub edbi_table_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table, $type) = @$args;
  $sth = $dbh->table_info( $catalog, $schema, $table, $type );
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_column_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table, $column) = @$args;
  $sth = $dbh->column_info( $catalog, $schema, $table, $column );
  return [[],[]] unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_primary_key_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($catalog, $schema, $table) = @$args;
  $sth = $dbh->primary_key_info( $catalog, $schema, $table );
  return undef unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub edbi_foreign_key_info {
  return undef unless $dbh;
  eval {
    $sth->finish() if $sth;
  };
  my ($args) = @_;
  my ($pkcatalog, $pkschema, $pktable, $fkcatalog, $fkschema, $fktable) = @$args;
  $sth = $dbh->foreign_key_info( $pkcatalog, $pkschema, $pktable,
                                 $fkcatalog, $fkschema, $fktable );
  return undef unless $sth;
  return [$sth->{NAME}, $sth->fetchall_arrayref()];
}

sub main {
  my $methods =
    {
     'connect' => [\&edbi_connect,"data_source, username, auth", ""],
     'do' => [\&edbi_do, "sql, params", ""],
     'select-all' => [\&edbi_select_all, "sql, params", ""],
     'prepare' => [\&edbi_prepare, "sql", ""],
     'execute' => [\&edbi_execute, "params", ""],
     'fetch-columns' => [\&edbi_fetch_columns, "", ""],
     'fetch' => [\&edbi_fetch, "[number]", ""],
     'auto-commit' => [\&edbi_auto_commit, "false/true", ""],
     'commit' => [\&edbi_commit, "", ""],
     'rollback' => [\&edbi_rollback, "", ""],
     'disconnect' => [\&edbi_disconnect, "", ""],
     'status' => [\&edbi_status, "", ""],
     'type-info-all' => [\&edbi_type_info_all, "", ""],
     'table-info' => [\&edbi_table_info, "catalog, schema, table, type", ""],
     'column-info' => [\&edbi_column_info, "catalog, schema, table, column", ""],
     'primary-key-info' => [\&edbi_primary_key_info, "catalog, schema, table", ""],
     'foreign-key-info' => [\&edbi_foreign_key_info, "pk_catalog, pk_schema, pk_table, fk_catalog, fk_schema, fk_table", ""],
    };
    my $server = RPC::EPC::Service->new(0, $methods);
    $server->start;
}

main;

#+END_SRC

#+BEGIN_SRC elisp
(after! edbi
  (setq edbi:driver-info
        (list
         "nix-shell" "-p"
         "perl"
         "-p" "perlPackages.DBI"
         "-p" "perlPackages.RPCEPCService"
         "-p" "perlPackages.DBDPg"
         "-p" "perlPackages.DBDmysql"
         "--run"
         (f-join doom-private-dir "edbi-bridge.pl"))))
#+END_SRC

*** Javascript :JAVASCRIPT:
**** Packages :PACKAGE:
***** [[https://github.com/aaronjensen/eslintd-fix][eslintd-fix]] :LINTING:AUTOFIX:

A javascript auto-fixer that isn't slow.
Needs [[https://www.npmjs.com/package/eslint_d][eslint_d]] binary in ~$PATH~.

****** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! eslintd-fix)
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(use-package! eslintd-fix
  :after js2-mode
  :config
  (setq
   flycheck-javascript-eslint-executable (executable-find "eslint_d")
   flycheck-disabled-checkers '(javascript-jshint javascript)))
#+END_SRC

****** Functions
******* Enable eslintd for writable buffers

#+begin_src elisp
(defun my:js/start-eslint ()
  "Start eslint on writable buffers.

When enabling on read-only buffers it will throw an error."
  (unless buffer-read-only
    (eslintd-fix-mode)))

(add-hook 'js2-mode-hook #'my:js/start-eslint)
#+end_src
***** [[https://github.com/floscr/js-import][floscr/js-import]] :AUTOFIX:FORK:

****** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! js-import :recipe (:host github :repo "floscr/js-import"))
#+END_SRC

****** Config

#+BEGIN_SRC elisp
(put 'js-import-alias-map 'safe-local-variable (lambda (x) t))
#+END_SRC

*** Nix :NIXOS:NIX:
**** Nixpkgs Fmt :AUTOFIX:
***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! nixpkgs-fmt)
#+END_SRC

***** Config

#+begin_src elisp
(use-package nixpkgs-fmt
  :after nix-mode
  :config
  (setq nixpkgs-fmt-on-save-mode t)
  :init
  (add-hook! nix-mode #'nixpkgs-fmt-on-save-mode))
#+end_src
*** Emacs Lisp (Elisp) :ELISP:
*** MySQL

** System :SYSTEM:
*** Packages
**** [[https://github.com/emacs-straight/disk-usage][disk-usage]]

Explore disk usage in emacs

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! disk-usage)
#+end_src

***** Config

#+BEGIN_SRC elisp
(use-package! disk-usage
  :commands (disk-usage)
  :config
  (map! :map disk-usage-mode-map
        :n "-" #'disk-usage-up))
#+END_SRC
**** [[https://github.com/alpha22jp/atomic-chrome][atomic-chrome]] :BROWSER:

Edit browser input fields with emacs.

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! atomic-chrome)
#+END_SRC
***** Config

#+begin_src elisp
(use-package! atomic-chrome
  :commands (atomic-chrome-start-server)
  :config
  (setq
   atomic-chrome-url-major-mode-alist
   '(("github\\.com" . gfm-mode))))
#+end_src

**** [[https://github.com/cbowdon/daemons.el][cbowdon/daemons.el Systemd UI]] :LINUX:

Manage systemd from emacs

***** Package

#+BEGIN_SRC elisp :tangle "packages.el" :comments link
(package! daemons)
#+END_SRC
***** Config

#+begin_src elisp
(use-package! daemons
  :commands (daemons))
#+end_src

** Git :GIT:
*** [[https://github.com/floscr/browse-at-remote][browse-at-remote]] :FORK:

Package override that fixes multiple remotes:
[[https://github.com/floscr/browse-at-remote/commit/9294ed82398457d2af5fcbf9090132f4693e4068][Add option to define preferred remote [*] · floscr/browse-at-remote@9294ed8]]

**** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! browse-at-remote :pin "9294ed82398457d2af5fcbf9090132f4693e4068" :recipe (:host github :repo "floscr/browse-at-remote"))
#+end_src
*** [[https://github.com/freesteph/elescope][freesteph/elescope: Search and clone Git repos directly within Emacs.]]

**** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! elescope)
#+END_SRC

**** Config

#+BEGIN_SRC elisp
(use-package elescope
  :commands (elescope-checkout)
  :config
  (setq elescope-root-folder my::directories:repositories-dir)
  :init
  (defalias '+git|clone 'elescope-checkout))
#+END_SRC

** Dired :DIRED:
*** Packages
**** [[https://github.com/Fuco1/dired-hacks#dired-filter][dired-hacks - dired-filter]]

Filter current dired buffer by query/extension etc.
Trigger with ~g/.~ in ~normal-mode~.

***** Package

#+BEGIN_SRC emacs-lisp :tangle "packages.el" :comments link
(package! dired-filter)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! dired-filter
  :after dired
  :config
  (setq dired-filter-saved-filters
        (quote (("images"
                 (extension "jpg" "png" "gif"))
                ("media"
                 (extension "mp3" "mp4" "MP3" "MP4" "avi" "mpg" "flv" "ogg" "wmv" "mkv" "mov" "wma"))
                ("archives"
                 (extension "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
                ("documents"
                 (extension "doc" "docx" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub")))))
  (dired-filter-define created-today
      "Show only files that are newer than today."
    (:description "created-today")
    (let ((case-fold-search nil))
      (time-less-p (time-subtract (current-time) (* 60 60 24))
                   (file-attribute-modification-time (file-attributes file-name))))))
#+END_SRC
**** [[https://github.com/Fuco1/dired-hacks#dired-subtree][dired-hacks/dired-subtree]]

***** Config

#+BEGIN_SRC elisp
(use-package! dired-subtree
  :after dired
  :config
  (evil-define-key 'normal dired-mode-map
    (kbd "<tab>") (cmd! () (dired-subtree-toggle)
                      ;; Fix for dired-all-the-icons not showing up
                      (dired-revert))
    (kbd "<backtab>") (cmd! () (dired-subtree-cycle)
                          (dired-revert))
    (kbd "gh") 'dired-subtree-up))
#+END_SRC
*** Config
**** Listing Switches / Sorting

#+BEGIN_SRC elisp
(defconst my::dired:default-listing-switches
  "-ahl -t --group-directories-first")

(setq dired-listing-switches my::dired:default-listing-switches)
#+END_SRC

**** Omit files types in dired

#+begin_src elisp
(use-package! dired
  :config
  (setq dired-omit-files
        (concat dired-omit-files
                ;; Apple files
                "\\|\\.com.apple.timemachine.donotpresent$"
                "\\|\\.Spotlight-V100$"
                "\\|\\.fseventsd$"
                "\\|\\.DocumentRevisions-V100$"
                "\\|\\.TemporaryItems$"
                ;; Windows files
                "\\|\\System Volume Information$")))
#+end_src

**** Automatically revert dired buffers
:PROPERTIES:
:SOURCE:   [[https://www.reddit.com/r/emacs/comments/1acg6q/how_to_configure_dired_to_update_instantly_when/][How to configure dired to update instantly when files/folders change? : emacs]]
:END:

#+BEGIN_SRC elisp
(add-hook 'dired-mode-hook 'auto-revert-mode)
#+END_SRC

**** Automatically create directories when moving/copying items :ADVICE:
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/12994164/allow-dired-do-copy-and-dired-do-rename-to-create-new-dir-on-the-fly][emacs - Allow dired-do-copy and dired-do-rename to create new dir on the fly - Stack Overflow]]
:END:

#+BEGIN_SRC elisp
(after! dired
  (defadvice dired-mark-read-file-name (after rv:dired-create-dir-when-needed (prompt dir op-symbol arg files &optional default) activate)
    (when (member op-symbol '(copy move))
      (let ((directory-name (if (< 1 (length files))
                                ad-return-value
                              (file-name-directory ad-return-value))))
        (when (and (not (file-directory-p directory-name))
                   (y-or-n-p (format "directory %s doesn't exist, create it?" directory-name)))
          (make-directory directory-name t))))))
#+END_SRC
**** Enable Async Mode

#+BEGIN_SRC elisp
(after! async
  (dired-async-mode 1))
#+END_SRC
*** Functions
**** Kill all dired buffers

#+BEGIN_SRC elisp
(defun my::dired|kill-dired-buffers ()
  "Kills all dired buffers."
  (interactive)
  (mapc (lambda (buffer)
          (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
            (kill-buffer buffer)))
        (buffer-list)))
#+END_SRC

**** Go to mounted drive :COUNSEL:

#+begin_src elisp
(defun my::dired|find-mounted-drive ()
  "Browse mounted disk.
When the mounted drive has only 1 partition, select this one otherwise show listing of disks."
  (interactive)
  (let ((dir (f-join "/run/media/" user-login-name)))
    (counsel-find-file
     (-some->> dir
       (f-directories)
       (--id-when (eq 1 (length it)))
       (car))
     (f-join "/run/media/" user-login-name))))
#+end_src

**** Unparent directory at point

#+BEGIN_SRC elisp
(defun my::dired|ungroup-directory ()
  "Move all files and directories to the current directory,
If everything goes well and the directory is empty, safely delete it.
It might not work out though, when any of the entries has the same name,
in that case throw a warning."
  (interactive)
  (->> (dired-get-marked-files)
       (-map (lambda (x)
               (let ((cmd (if (my::file/dir-has-hidden-entries x)
                              "mv -n ./* ./.* ../"
                            "mv -n ./* ../")))
                 (shell-command (t! "cd \"<<x>>\"; <<cmd>>"))
                 (when (f-empty? x)
                   (dired-delete-file x))))))
  (revert-buffer))
#+END_SRC
**** TODO Mouse navigation of the heading directory
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/13354/dired-heading-directory-with-text-properties-to-jump-to-parent-directories][breadcrumbs - Dired heading directory with text-properties to jump to parent directories - Emacs Stack Exchange]]
:END:

Allows to click on the header bar to got to navigate tree breadcrumbs in the dired header bar.

#+begin_src elisp
(defface dired-mouseover-face
  '((t (:foreground "green")))
  "Face for `dired-mouseover-face'."
  :group 'dired)

(defvar dired-mouse-map
  (let ((map (make-sparse-keymap)))
    (define-key map [mouse-2] 'dired-follow-link)
    (define-key map [return] 'dired-follow-link)
    (define-key map [follow-link] 'mouse-face)
    map)
  "Keymap for mouse when in `dired-mode'.")

;; Author:  Drew Adams -- http://emacs.stackexchange.com/a/13411/2287
(defun dired-follow-link (event)
  "Follow the link in the dired directory heading, causing a new
dired buffer to be opened.
When clicking on the current directory always go one directory upwards."
  (interactive (list last-nonmenu-event))
  (run-hooks 'mouse-leave-buffer-hook)
  (with-current-buffer (window-buffer (posn-window (event-start event)))
    (let ((path  (get-text-property (posn-point (event-start event)) 'breadcrumb)))
      (if (f-equal? dired-directory path)
          (dired-up-directory)
        (dired path)))))

(defun dired-propertize-directory-heading ()
  (interactive)
  (unless (buffer-narrowed-p)
    (let* (
           p beg end path peol
           (inhibit-read-only t))
      (save-excursion
        (goto-char (point-min))
        (setq peol (point-at-eol))
        (set-text-properties (point) peol nil)
        (re-search-forward "\\([^/\\]+\\)[/\\]" peol t)
        (when (looking-back "\\(^ +\\)\\([a-zA-Z]:\\)?/")
          (setq p (match-end 1))
          (setq path (if (match-string 2) (concat (match-string 2) "/") "/"))
          (add-text-properties (point-min) (1- (match-end 0)) (list
                                                               'breadcrumb path
                                                               'mouse-face 'dired-mouseover-face
                                                               'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                                               'keymap dired-mouse-map)))
        (while (re-search-forward "\\([^/\\]+\\)[/\\]" peol t)
          (setq beg (match-beginning 1))
          (setq end (match-end 1))
          (setq path (buffer-substring-no-properties p end))
          (add-text-properties beg end (list
                                        'breadcrumb path
                                        'mouse-face 'dired-mouseover-face
                                        'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                        'keymap dired-mouse-map)))
        (setq path (buffer-substring-no-properties p (1- peol)))
        (add-text-properties (point) (1- peol) (list
                                                'breadcrumb path
                                                'mouse-face 'dired-mouseover-face
                                                'help-echo (format "mouse-2, RET: Follow the link to \"%s\"." path)
                                                'keymap dired-mouse-map))))))

(add-hook 'dired-after-readin-hook 'dired-propertize-directory-heading)
#+end_src
**** Get marked file size
:PROPERTIES:
:SOURCE:   https://www.emacswiki.org/emacs/DiredGetFileSize
:END:

#+BEGIN_SRC elisp
 (defun my::dired|get-marked-file-size ()
   "Get the file size of all marked dired entries."
   (interactive)
   (let ((files (dired-get-marked-files)))
     (with-temp-buffer
       (apply 'call-process "du" nil t nil "-sch" files)
       (message
        "Size of all marked files: %s"
        (progn (re-search-backward "\\(^[0-9.,]+[A-Za-z]+\\).*total$") (match-string 1))))))
#+END_SRC

**** Toggle sorting

When you toggle the sorting via ~dired-sort-toggle-or-edit~ the cursor stays at the current file, which is very disorienting.
With this function the cursor stays on the current line.
~save-excursion~ does not work in this function, it just throws to the top of the buffer.
The dired-line jumps at the end are used to jump the filename again.

#+BEGIN_SRC elisp
(defun my::dired|toggle-sorting (&optional arg)
  "Change sorting but stay on the same line."
  (interactive "P")
  (let ((pos (point)))
    (cond
     ((eq arg 3)
      (setq dired-listing-switches (symbol-value 'my::dired:default-listing-switches))
      (setq dired-actual-switches (symbol-value 'my::dired:default-listing-switches))
      (dired-sort-set-mode-line)
      (revert-buffer))
     ((eq arg 2)
      (setq dired-listing-switches
            (read-string "Global ls switches (must contain -l): " dired-listing-switches))
      (setq dired-actual-switches (symbol-value 'dired-listing-switches))
      (dired-sort-set-mode-line)
      (revert-buffer))
     (arg
      (setq dired-actual-switches
            (read-string "Buffer ls switches (must contain -l): " dired-actual-switches)))
     (t (dired-sort-toggle-or-edit)))
    (goto-char pos)
    (dired-next-line 1)
    (dired-previous-line 1)))
#+END_SRC
**** Open file externally
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/cgbpvl/opening_media_files_straight_from_gnu_emacs_dired/eufxc9j/
:END:

***** Config

#+begin_src elisp
(defvar my::dired::open-external:extensions nil
  "Which files to open externally by default when pressing enter.")

(setq my::dired::open-external:extensions
      '(
        ;; Video
        "mov" "mpv" "mkv"
        ;; Audio
        "mp4" "mp3" "ogg"))
#+end_src

***** Function

#+BEGIN_SRC elisp
(defun my::dired::open-external/mouse-open (event)
  "Open marked dired file(s) at point with an external application. Open directories normally"
  (interactive "e")
  (my::dired::open-external/mouse-open event))

(defun my::dired::open-external/mouse-open (event &optional find-file-func find-dir-func)
  "In Dired, visit the file or directory name you click on.
The optional arguments FIND-FILE-FUNC and FIND-DIR-FUNC specify
functions to visit the file and directory, respectively.  If
omitted or nil, these arguments default to `find-file' and `dired',
respectively."
  (interactive "e")
  (or find-file-func (setq find-file-func 'my::dired::open-external/xdg-open))
  (or find-dir-func (setq find-dir-func 'dired))
  (let (window pos file)
    (save-excursion
      (setq window (posn-window (event-end event))
            pos (posn-point (event-end event)))
      (if (not (windowp window))
          (error "No file chosen"))
      (set-buffer (window-buffer window))
      (goto-char pos)
      (setq file (dired-get-file-for-visit))
      (if (file-directory-p file)
          (or (and (cdr dired-subdir-alist)
                   (dired-goto-subdir file))
              (progn
                (select-window window (funcall find-dir-func file))))
        (select-window window)
        (funcall find-file-func)))))

(defun my::dired::open-external/xdg-open (&optional file)
  "Open marked dired file(s) at point with an external application."
  (let ((file-list (or file (dired-get-marked-files)))
        (process-connection-type nil))
    (--map (my::shell/no-exit-command "xdg-open" (s-wrap (expand-file-name it) "\"")) file-list)))

(defun my::dired::open-external|open-dwim (&optional file)
  (interactive)
  (let ((file-list (or file (dired-get-marked-files)))
        (process-connection-type nil))
    (-each file-list (lambda (x)
                       (message "%s" x)
                       (let* ((path (expand-file-name x))
                              (ext (f-ext path)))
                         (if (-contains? my::dired::open-external:extensions ext)
                             (my::shell/no-exit-command "xdg-open" (s-wrap path "\""))
                           (dired-find-file)))))))
#+END_SRC
**** Convert Images
:PROPERTIES:
:SOURCE:   [[http://xenodium.com/enrich-your-dired-batching-toolbox/index.html][Enrich Emacs direds batching toolbox]]
:END:

#+BEGIN_SRC elisp
(defun my::dired|convert-image (&optional arg)
  "Convert image files to other formats."
  (interactive "P")
  (assert (executable-find "convert") nil "Install imagemagick")
  (let* ((dst-fpath)
         (src-fpath)
         (src-ext)
         (last-ext)
         (dst-ext))
    (mapc
     (lambda (fpath)
       (setq src-fpath fpath)
       (setq src-ext (downcase (file-name-extension src-fpath)))
       (when (or (null dst-ext)
                 (not (string-equal dst-ext last-ext)))
         (setq dst-ext (completing-read "to format: "
                                        (seq-remove (lambda (format)
                                                      (string-equal format src-ext))
                                                    '("jpg" "png")))))
       (setq last-ext dst-ext)
       (setq dst-fpath (format "%s.%s" (file-name-sans-extension src-fpath) dst-ext))
       (message "convert %s to %s ..." (file-name-nondirectory dst-fpath) dst-ext)
       (set-process-sentinel
        (start-process "convert"
                         (generate-new-buffer (format "*convert %s*" (file-name-nondirectory src-fpath)))
                         "convert" src-fpath dst-fpath)
        (lambda (process state)
          (if (= (process-exit-status process) 0)
              (message "convert %s ✔" (file-name-nondirectory dst-fpath))
            (message "convert %s ❌" (file-name-nondirectory dst-fpath))
            (message (with-current-buffer (process-buffer process)
                       (buffer-string))))
          (kill-buffer (process-buffer process)))))
     (dired-map-over-marks (dired-get-filename) arg))))
#+END_SRC
*** Bindings

#+BEGIN_SRC elisp
(map! :after dired
      :map dired-mode-map
      ;; Mouse controls
      :ng (kbd "<mouse-2>") 'my::dired::open-external|open-dwim
      :ng (kbd "<mouse-8>") 'dired-up-directory


      :n "q" (cmd! (kill-buffer))
      :n "Q" #'my::dired|kill-dired-buffers

      :ng "RET" 'my::dired::open-external|open-dwim
      :gn "o" 'my::dired|toggle-sorting
      :n "gg" 'my::dired|goto-top
      :localleader
      (:prefix ("s" . "search")
       "i"  #'dired-goto-subdir))

(define-key dired-mode-map (kbd "<down-mouse-1>") 'dired-mouse-find-file)
#+END_SRC

**** Go to top =gg= evil fix :EVIL:

When I do =gg= in dired, I mostly want to go to the first entry.
This function first goes to the first entry and then to the top of the buffer.

#+BEGIN_SRC elisp
(defun my::dired|goto-top ()
  "Go to first directory, when already there go to first line."
  (interactive)
  (if (<= (line-number-at-pos) 3)
      (goto-char (point-min))
    (goto-line 3)
    (dired-next-dirline 1)
    (dired-prev-dirline 1)))
#+END_SRC
**** Wdired mode evil fix :EVIL:

Stay in normal mode when switching to wdired

#+BEGIN_SRC elisp
(defun my::dired|evil-wdired-mode ()
  "Stay in normal mode when switching to wdired."
  (interactive)
  (wdired-change-to-wdired-mode)
  (evil-normal-state))

(map! :after dired
      :map dired-mode-map
      :n "\\" #'my::dired|evil-wdired-mode)
#+END_SRC

**** Use same window for copying/renaming with prefix

I've set ~dired-dwim-target~ to ~t~, so it uses the other window as the target destination.
I undo this option with the interactive prefix argument, which can be accessed via ~SPC ucopy R/U~.

#+BEGIN_SRC elisp
(defun my::dired/dired-target-from-prefix (fn)
  (let ((dired-dwim-target (if (eq (prefix-numeric-value current-prefix-arg) 4) ;; Single C-u
                              nil
                            dired-dwim-target)))
      (call-interactively fn)))

(map! :after dired
      :map dired-mode-map
      :n "R" (cmd! (my::dired/dired-target-from-prefix #'dired-do-copy))
      :n "C" (cmd! (my::dired/dired-target-from-prefix #'dired-do-rename)))
#+END_SRC

**** Dired Paste DWIM

#+BEGIN_SRC elisp
(defun my::dired|paste-dwim ()
  "Paste data in the current directory."
  (interactive)
  (let ((file (read-string "Filename: "))
        (last-clip-type (->> (shell-command-to-string "greenclip print")
                             (s-split "\n")
                             (-first-item))))
    (unless (string= "" file)
      (cond
       ((s-matches? "^image\\/png" last-clip-type)
        (shell-command-to-string (template "xclip -selection clipboard -t image/png -o > <<file>>")))))
    (dired-revert)))

(map! :after dired
      :map dired-mode-map
      :n "p" 'my::dired|paste-dwim)
#+END_SRC
** Projectile :PROJECTILE:
*** Config
**** Ignored Projects

Dont add packages inside ~~.emacs.d~ to projectile, as I often browse the source for a package,
but I dont want them added to my ~projectile-known-projects~.

#+BEGIN_SRC elisp
(use-package! projectile
  :init
  (setq projectile-ignored-projects '("~/"
                                      "/tmp"
                                      "~/.emacs.d/.local/straight/repos/")))
#+END_SRC

**** Scan directory for repositories

#+BEGIN_SRC elisp
(use-package! projectile
  :init
  (setq projectile-project-search-path '("~/Code/Dotfiles"
                                         "~/Code/Repositories"
                                         "~/Code/Projects"
                                         "~/Code/Tools"
                                         "~/Code/Meisterlabs"
                                         "~/Code/Meisterlabs/mindmeister-web/.worktrees"))
  :config
  ;; Auto discover when running switch project for the first time
  (add-transient-hook! 'counsel-projectile-switch-project
    (projectile-cleanup-known-projects)
    (projectile-discover-projects-in-search-path)))
#+END_SRC

** Evil :EVIL:
*** Packages
**** INACTIVE [[https://github.com/tarao/evil-plugins][tarao/evil-plugins]]
***** Package

#+BEGIN_SRC emacs-lisp :tangle no
(package! evil-plugin :recipe (:host github :repo "tarao/evil-plugins"))
#+END_SRC
**** [[https://github.com/emacsmirror/evil-replace-with-register][evil-replace-with-register: Replace with register motion]]

Replace the current selection with a register.
Press =gr= with a following motion character like =w=.

***** Package

#+BEGIN_SRC emacs-lisp :tangle no
(package! evil-replace-with-register)
#+END_SRC

***** Config

#+BEGIN_SRC elisp
(use-package! evil-replace-with-register
  :config
  (setq evil-replace-with-register-key (kbd "gr"))
  (define-key evil-normal-state-map
    evil-replace-with-register-key 'evil-replace-with-register)
  (define-key evil-visual-state-map
    evil-replace-with-register-key 'evil-replace-with-register))
#+END_SRC
**** [[https://github.com/urbint/evil-text-objects-javascript][evil-text-objects-javascript: Javascript motions]]

- "f" - function
- "c" - single-line comment
- "C" - multi-line comment

***** Package

#+BEGIN_SRC emacs-lisp :tangle no
(package! evil-text-objects-javascript :recipe (:host github :repo "urbint/evil-text-objects-javascript"))
#+END_SRC




** Pdf :PDF:
*** Config

**** TODO Fix midnight colors for doom-one theme

#+BEGIN_SRC elisp
;; Fix midnight colors for doom-one theme
(setq pdf-view-midnight-colors '("#BBC2CD" . "#282C34"))
#+END_SRC

*** Bindings

#+BEGIN_SRC elisp
(map!
 :map pdf-occur-buffer-mode-map
 :gn [tab] (cmd! (pdf-occur-goto-occurrence t)))
#+END_SRC
** Flycheck :LINTING:
*** Config
**** Disabled Checkers
***** Elisp

#+BEGIN_SRC elisp
(add-hook! 'emacs-lisp-mode-hook :append
  (setq flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC

***** Nim

#+BEGIN_SRC elisp
(add-hook! 'nim-mode-hook :append
  (setq flycheck-disabled-checkers '(nim-nimsuggest))
  (flycheck-select-checker 'nim-1-6-0))
#+END_SRC




* Needs to be restrucutred
** Packages
:PROPERTIES:
:header-args: :tangle "packages.el" :comments link
:END:

*** General Packages
**** UI
***** Narrow to an indirect buffer

#+BEGIN_SRC elisp
(package! narrow-indirect :recipe (:host github :repo "emacsmirror/narrow-indirect"))
#+END_SRC

***** Colorized hex strings


***** Centered buffers, doom does not support this anymore.

#+BEGIN_SRC elisp
(package! visual-fill-column)
#+END_SRC
***** Ivy Avy

Move to ivy candidate with =C-'=

#+BEGIN_SRC elisp
(package! ivy-avy)
#+END_SRC

***** Doom Themes

#+BEGIN_SRC elisp :tangle no
(package! doom-themes
  :recipe (:host github :repo "floscr/emacs-doom-themes" :files ("*.el" "themes/*.el"))
  :pin nil)
#+END_SRC

**** Dired
***** Open subtrees directly in the current view

#+BEGIN_SRC elisp
(package! dired-subtree)
#+END_SRC
**** Programming

#+BEGIN_SRC elisp
(package! edbi)
#+END_SRC

**** Etc
***** Narrow Proced Buffers

#+BEGIN_SRC elisp
(package! proced-narrow)
#+END_SRC

*** Language Packages
**** Elisp

[[https://github.com/countvajhula/symex.el][Symex]] for editing emacs lisp by structure.

#+BEGIN_SRC elisp
(package! symex)
#+END_SRC

**** Beancount

#+BEGIN_SRC elisp
(package! beancount :recipe (:host github :repo "cnsunyour/beancount.el"))
#+END_SRC

**** Javascript
***** Indium: Javascript debugging environment

#+BEGIN_SRC elisp
(package! indium)
#+END_SRC

***** Impatient Mode: Live editing of html

#+BEGIN_SRC elisp
(package! impatient-mode)
#+END_SRC

***** Jest: Test Runner

#+BEGIN_SRC elisp
(package! jest :recipe (:host github :repo "floscr/emacs-jest"))
#+END_SRC
**** Nim

#+BEGIN_SRC elisp
(package! inim :recipe (:host github :repo "SerialDev/inim-mode"))
#+END_SRC

**** Graphql

#+BEGIN_SRC elisp
(package! graphql)
#+END_SRC

**** Git

Show changes in current branch

#+BEGIN_SRC elisp
(package! git-lens)
#+END_SRC

Quickly download and browser repositories from github

#+BEGIN_SRC elisp
(package! elescope)
#+END_SRC

**** Ebooks

#+BEGIN_SRC elisp
(package! nov)
#+END_SRC
**** Literate Calc Mode

Inline Calculation

#+BEGIN_SRC elisp
(package! literate-calc-mode)
#+END_SRC

*** Overrides
**** Doom Snippets

#+BEGIN_SRC elisp
(package! doom-snippets :ignore t)
(package! my-doom-snippets
  :recipe (:host github
           :repo "floscr/doom-snippets"
           :files ("*.el" "*")))
#+END_SRC

**** Posframe

#+BEGIN_SRC elisp
(package! flycheck-posframe :pin "6eea204138721f511051af5138326fecaad237b7")
#+END_SRC

**** Calfw
Continuous events are broken in the current calfw source,
also it seems it isn't maintained anymore.
[[https://github.com/floscr/emacs-calfw/commit/3d17649c545423d919fd3bb9de2efe6dfff210fe][This Commit]] fixes the behavior.

#+BEGIN_SRC elisp
(package! calfw :recipe (:host github :repo "floscr/emacs-calfw") :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-org :recipe (:host github :repo "floscr/emacs-calfw") :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-ical :pin "e3d04c253230ed0692f161f527d4e42686060f62")
(package! calfw-cal :disable t)
(package! org-gcal :disable t)
#+END_SRC

**** json-proces-client

This package is originally hosted on https://gitea.petton.fr/nico/json-process-client.git/
But this private repository host went down a few times, so I'll stick to github.

#+BEGIN_SRC elisp
(package! json-process-client
  :recipe (:host github :repo "emacsmirror/json-process-client")
  :pin "373b2cc7e3d26dc00594e0b2c1bb66815aad2826")
#+END_SRC
**** merlin

#+BEGIN_SRC elisp
(package! merlin :pin "e4791e22986993c36c3f5c91e8dff93494cc232e")
#+END_SRC

*** Disabled Packages
**** Remove those annoying LSP interface plugins

#+BEGIN_SRC elisp
(package! lsp-ui :disable t)
(package! merlin-eldoc :disable t)
#+END_SRC
**** Elfeed-Goodies

No need, screws with entry buffer position and header display...

#+begin_src elisp
(package! elfeed-goodies :disable t)
#+end_src

** UI

#+BEGIN_SRC elisp
(defun +ui/adjust-font (size line-space &optional font-family weight)
  (let* ((font-family (or font-family)))
    (setq-default line-spacing line-space)
    (setq-default doom-font (font-spec :family font-family :size size :weight weight))
    (setq-default doom--font-scale nil)
    (set-frame-font doom-font 'keep-size t)
    (doom/reload-font)
    (run-hooks 'after-setting-font-hook)))

(defun +ui/get-screens ()
  "Get a list of all connected screens."
  (-> "xrandr | grep ' connected ' | cut -d ' ' -f 1"
      (shell-command-to-string)
      (split-string "\n")
      (reverse)
      (cdr)
      (reverse)
      (cl-sort (lambda (a b)
                 (cond ((string-match-p "^eDP" a) t)
                       ((string-match-p "^eDP" b) nil)
                       (t nil))))))

(defun +ui/has-screen-connected? (screen)
  "Check if SCREEN is connected."
  (-contains? (+ui/get-screens) screen))

(defun +ui|adjust-ui-to-display ()
  "Adjust the UI to the current attached display."
  (interactive)
  (cond
   ((string= (system-name) "mbair")
    ;; Not actually a retina display, but this looks best
    (+ui/adjust-font 13 5 "Fira Code"))
   ((string= (system-name) "Florians-iMac.local")
    (+ui/adjust-font 14 10 "Menlo"))
   ((string= (system-name) "thinknix")
    (if (+ui/has-screen-connected? "DP2")
        (+ui/adjust-font 18 7 "Fira Code" 'medium)
      (+ui/adjust-font 15 4 "Fira Code" 'medium)))
   ((string= (system-name) "Florians-MacBook-Air.local")
    (+ui/adjust-font 14 10 "Menlo"))))
#+END_SRC
** Window management
*** Toggle split style
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/46664/switch-between-horizontal-and-vertical-splitting][Switch between horizontal and vertical splitting? - Emacs Stack Exchange]]
:END:

#+BEGIN_SRC elisp
;;;###autoload
(defun my|toggle-window-split-direction ()
  "Toggle current window split between horizontal and vertical."
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+END_SRC

*** Toggle dedicated
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/2189/how-can-i-prevent-a-command-from-using-specific-windows][buffers - How can I prevent a command from using specific windows? - Emacs Stack Exchange]]
:END:

Lock a window so the buffer can't be changed or it cant be deleted.

#+BEGIN_SRC elisp
;;;###autoload
(defun my|toggle-window-dedicated ()
  "Control whether or not Emacs is allowed to display another
buffer in current window."
  (interactive)
  (let* ((window (get-buffer-window (current-buffer)))
         (is-locked (window-dedicated-p window))
         (txt (if is-locked "Window unlocked" "Window locked")))
    (set-window-dedicated-p window (not is-locked))
    (message (template "<<(current-buffer)>>: <<txt>>!"))))
#+END_SRC


* Configuration
** Custom Functions & Modes
*** Unfill Paragraph

Fix a paragraph that was formatted to a fill column.

#+BEGIN_SRC elisp
(defun my|unfill-paragraph ()
  "Fix a paragraph that was formatted to a fill column."
  (interactive)
  (let ((fill-column (point-max)))
    (fill-paragraph nil)))
#+END_SRC

*** Jump to definition for tangled files

Take me to the literate source file when using ~find-function~ etc.

#+BEGIN_SRC elisp
(defadvice! +org|try-org-babel-tangle-jump-to-org (&optional arg1)
  :after '(find-function
           find-variable)
  (ignore-errors
    (org-babel-tangle-jump-to-org)))
#+END_SRC

*** Hydras
**** Line Spacing

Change and reset line-spacing for all buffers.

#+BEGIN_SRC elisp
(defvar +ui-default-line-spacing line-spacing)
(defvar +ui-default-line-spacing-increment 1)
(defvar +ui-big-line-spacing-increment 10)

(defun +ui/set-line-spacing (&optional increment)
  "Set the line spacing
When no line spacing is given is the default-line-spacing"
  (setq-default line-spacing (+ (or increment +ui-default-line-spacing-increment) line-spacing)))

(defun +ui|reset-line-spacing ()
  (interactive)
  (setq-default line-spacing +ui-default-line-spacing))

(defun +ui|increase-line-spacing ()
  (interactive)
  (+ui/set-line-spacing))

(defun +ui|decrease-line-spacing ()
  (interactive)
  (+ui/set-line-spacing (- +ui-default-line-spacing-increment)))

(defun +ui|increase-line-spacing-big ()
  (interactive)
  (+ui/set-line-spacing +ui-big-line-spacing-increment))

(defun +ui|decrease-line-spacing-big ()
  (interactive)
  (+ui/set-line-spacing (- +ui-big-line-spacing-increment)))

(evil-define-key 'normal 'global (kbd "]z") #'+line-spacing/step/body)

;;;###autoload (autoload '+common-lisp/macrostep/body "lang/common-lisp/autoload/hydras" nil nil)
(defhydra +line-spacing/step (:exit nil :hint nil :foreign-keys run :color pink)
  "
Macro Expansion
^^Definitions                           ^^Compiler Notes             ^^Stickers
^^^^^^─────────────────────────────────────────────────────────────────────────────────────
[_r_] Reset
[_]_] Expand
[_[_] Collapse
[_}_] Expand Big
[_{_] Collapse Big
"
  ("r" +ui|reset-line-spacing)
  ("]" +ui|increase-line-spacing)
  ("[" +ui|decrease-line-spacing)
  ("}" +ui|increase-line-spacing-big)
  ("{" +ui|decrease-line-spacing-big)
  ("q" nil "cancel" :color blue))
#+END_SRC

**** Expand Region
:PROPERTIES:
:SOURCE:   https://www.reddit.com/r/emacs/comments/also27/second_trial_for_a_weekly_tipstricksetc_thread/efi7pbj/
:END:

Expand visual region using a hydra.
Double press ~v~ to enable.

#+BEGIN_SRC elisp
(defhydra hydra-expand-region ()
   "region: "
   ("f" er/mark-defun "defun")
   ("v" er/expand-region "expand")
   ("V" er/contract-region "contract"))

(evil-define-key 'visual 'global (kbd "v") #'hydra-expand-region/body)
#+END_SRC
*** Custom Modes
**** Evil edit register

Edit registers with ~+evil-edit-register|counsel~.
Mostly used to edit the macro registers ~q~.

#+BEGIN_SRC elisp
(defvar +evil-edit-register:register "")
(defvar +evil-edit-register-mode-map (make-sparse-keymap))

(define-minor-mode +evil-edit-register-mode
  "Edit evil register and save it back to the register."
  :keymap +evil-edit-register-mode-map)

(map! :map +evil-edit-register-mode-map
      "C-c C-c" #'+evil-edit-register|save-and-exit
      "C-c C-k" #'kill-buffer-and-window)

(defun +evil-edit-register|save-and-exit (&optional arg)
  "Save the buffer content back to the register register"
  (interactive)
  (evil-set-register
   (string-to-char +evil-edit-register:register)
   (buffer-substring-no-properties (point-min) (point-max)))
  (kill-buffer-and-window))

(defun +evil-edit-register|counsel (register-string)
  "Edit evil register in register"
  (require 'noflet)
  (interactive (noflet ((counsel-evil-registers-action (x) x))
                 (list (counsel-evil-registers))))
  (-when-let* ((register-string (substring-no-properties register-string))
               (buffer (generate-new-buffer (t! "*Evil Register Edit: <<register-string>>*")))
               ((_ reg register) (s-match "^\\[\\(.\\)\\]: \\(.*\\)$" register-string)))
    (pop-to-buffer buffer)
    (with-current-buffer buffer
      (+evil-edit-register-mode 1)
      (setq-local +evil-edit-register:register reg)
      (setq header-line-format "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")
      (save-excursion
        (insert register)))))
#+END_SRC
** UI
*** Zen Mode & Variable Pitch Fonts

#+BEGIN_SRC elisp
(setq +zen-text-scale 1.5)

(let ((height 140)
      (size 23))
  (setq doom-variable-pitch-font (font-spec :family "IBM Plex Sans" :size size)
        doom-serif-font (font-spec :family "IBM Plex Sans" :size size)))
#+END_SRC

*** Frame padding

#+BEGIN_SRC elisp
(add-hook! '(window-setup-hook after-make-frame-functions)
  (defun +ui/init-frame-ui (&optional frame)
    (interactive)
    "Re-enable menu-bar-lines in GUI frames."
    (when-let (frame (or frame (selected-frame)))
      (when (display-graphic-p frame)
        (set-frame-parameter frame 'internal-border-width 15)))))
#+END_SRC

*** System specific window modifications

Resize the window font size etc according to the system.
This will be disabled in terminal mode.

#+BEGIN_SRC elisp
(when (display-graphic-p) (+ui|adjust-ui-to-display))
#+END_SRC

*** Theme Toggle

Toggle between a light and a dark theme.
Bound to ~SPC t t~.

#+BEGIN_SRC elisp
(defconst light-theme 'doom-one)
(defconst dark-theme  'doom-one-light)

(defun +doom|toggle-theme ()
  "Toggle between light and dark themes."
  (interactive)
  (cond ((eq doom-theme dark-theme)
         (message "Toggling to light-theme: %s" light-theme)
         (setq doom-theme light-theme)
         (doom/reload-theme))
        ((eq doom-theme light-theme)
         (message "Toggling to dark-theme: %s" dark-theme)
         (setq doom-theme dark-theme)
         (doom/reload-theme))
        (t (message "Toggling theme is not possible. Theme is not currently light-theme (%s) or dark-theme (%s)." light-theme dark-theme))))
#+END_SRC

*** Theme Modifications
**** General

#+BEGIN_SRC elisp
(add-hook 'doom-load-theme-hook #'*doom-themes-custom-set-faces)
#+END_SRC

***** Function Start

#+BEGIN_SRC elisp
(defun *doom-themes-custom-set-faces ()
  (set-face-attribute 'fringe nil
                      :foreground (face-background 'default)
                      :background (face-background 'default))
  (custom-set-faces!
#+END_SRC

***** Bookmarks

#+BEGIN_SRC elisp
'(bookmark-face :background nil)
#+END_SRC


***** Dired Output

Remove the rainbow colors from dired.

#+BEGIN_SRC elisp
'(diredfl-read-priv :foreground "#80899E")
'(diredfl-write-priv :foreground "#80899E")
'(diredfl-exec-priv :foreground "#80899E")
'(diredfl-other-priv :foreground "#80899E")

'(all-the-icons-dired-dir-face :foreground "#80899E")

'(diredfl-dir-priv :foreground "#282C34")
'(diredfl-k-modified :foreground "#FF8E90")

'(diredfl-number :foreground "#80899E")
'(diredfl-date-time :foreground "#49505F")
`(diredfl-dir-name :foreground "#2DADF2")
#+END_SRC

***** Mu4E

Switch the highlight.

#+BEGIN_SRC elisp
'(mu4e-highlight-face :inherit mu4e-unread-face)
#+END_SRC

***** Org Mode

Remove the ugly grey background

#+BEGIN_SRC elisp
'(org-column :background nil)
#+END_SRC

***** Function End

#+BEGIN_SRC elisp
))
#+END_SRC
**** Hooks

***** Diff Highlighting

#+BEGIN_SRC elisp
(add-hook! '(diff-hl-margin-minor-mode-hook)
  (progn
    (set-face-attribute 'smerge-refined-added nil
                        :foreground (doom-blend "#98be65" "#3e493d" 0.15)
                        :background (doom-lighten "#98bb5d" 0.2))
    (set-face-attribute 'smerge-refined-removed nil
                        :foreground (doom-blend "#ff6c6b" "#4f343a" 0.2)
                        :background (doom-lighten "#ff6c6b" 0.1))))

(add-hook! '(magit-status-mode-hook magit-diff-mode-hook)
           (progn
                   (set-face-attribute 'diff-refine-added nil
                                       :foreground (doom-blend "#98be65" "#3e493d" 0.15)
                                       :background (doom-lighten "#98bb5d" 0.2))
                   (set-face-attribute 'diff-refine-removed nil
                                       :foreground (doom-blend "#ff6c6b" "#4f343a" 0.2)
                                       :background (doom-lighten "#ff6c6b" 0.1))))
#+END_SRC

*** Scrolloff

Start scrolling X lines before the end of a screen.
Disable for certain modes (terminal & ivy) where the window is to small.

#+BEGIN_SRC elisp
(setq scroll-conservatively 10)
(setq scroll-margin 10)

(add-hook 'term-mode-hook (cmd! (setq-local scroll-margin 0)))
(add-hook 'ivy-mode-hook (cmd! (setq-local scroll-margin 0)))
#+END_SRC

*** (Visual) Fill Column

#+BEGIN_SRC elisp :tangle no
(setq-default fill-column 110)
(setq fill-column 110)
(setq visual-fill-column-width fill-column)

(setq visual-fill-column-center-text t
      visual-fill-column-width fill-column)
#+END_SRC

*** Disable trailing whitespace warning

#+BEGIN_SRC elisp :tangle no
(setq-hook! 'prog-mode-hook show-trailing-whitespace nil)
#+END_SRC

*** Fix underline

Draw the underline at the bottom of the text, not at the end of line-spacing.

#+BEGIN_SRC elisp
(setq x-underline-at-descent-line nil)
#+END_SRC

** Language Config
*** Haskell
**** Formatter

#+begin_src elisp
(defun format-haskell-with-brittany-and-stylish-haskell ()
  "Function formats haskell buffer with brittany on save."
  (interactive)
  (when (eq major-mode 'haskell-mode)
    (shell-command-to-string (format "brittany --write-mode inplace %s" buffer-file-name))
    (revert-buffer :ignore-auto :noconfirm)
    (haskell-mode-stylish-buffer)
    (save-buffer)))
#+end_src
*** Javascript
**** Utils

#+BEGIN_SRC elisp
(defun +js/match-const-function-name (line)
  "Matches a line to the word after the declaration"
  (nth 2 (s-match
          "\\(const\\|let\\|class\\)\s\\(.+?\\)\s"
          line)))

(defun +js/const-function-at-point ()
  "Returns the current function name at the current line"
  (+js/match-const-function-name (thing-at-point 'line t)))
#+END_SRC

**** Functions
***** Export default variable

#+BEGIN_SRC elisp
(defun js2r-export-default ()
  "Exports the current declaration at the end of the file"
  (interactive)
  (save-excursion
    (let* ((name (+js/const-function-at-point)))
      (goto-char (point-max))
      (insert "\n")
      (insert (template "export default <<name>>;")))))
#+END_SRC

***** Extract constant to file

Extract the ~const~ under the cursor into a new file.

#+BEGIN_SRC elisp
(defun js2r-extract-const-to-file ()
  "Extracts function to external file"
  (interactive)
  (let* ((name (+js/const-function-at-point))
         (path (concat "./" name ".js")))
    (evil-digit-argument-or-evil-beginning-of-line)
    (js2r-kill)
    (f-write-text "" 'utf-8 path)
    (find-file path)
    (yank)))
#+END_SRC

***** Generate ~index.js~ file index

Generate a file index in the current file for every other file in the current directory.

#+BEGIN_SRC elisp
(defun +js/index-file-names (&optional dir)
  "Get filenames from current buffers directory."
  (let ((fs (directory-files (or dir default-directory) nil ".*\\.js")))
    (mapcar 'f-no-ext
            (remove "index.js" fs))))

(defun +js|generate-index (&optional dir ignore-list is-old-es-style)
  "Generate an index import file for files in directory.
Pass DIR for directory, falls back to default-directory
Pass IGNORE-LIST for a list of files
Pass IS-OLD-ES-STYLE for using the non-esm style exports"
  (interactive)
  (erase-buffer)
  (let* ((dir (or dir default-directory))
         (fs (->>
              (+js/index-file-names dir)
              (-log)
              (--reject (s-ends-with-p ".test" it))
              (--when ignore-list (--remove (-contains? ignore-list it) it)))))
    (message "%s" fs)
    (cond (is-old-es-style
           (progn
             (mapc (lambda (f) (insert "import " f " from './" f "';\n")) fs)
             (insert "\n")
             (insert "export default {\n")
             (mapc (lambda (f) (insert "    " f ",\n")) fs)
             (insert "};")))
          (t
           (mapc (lambda (f) (insert "export { default as " f " } from './" f "';\n")) fs)))))
#+END_SRC

***** Convert expression into template string

Converts an expression into a template string.

Example:
When you would call the function on the ~foo~ inside the console.log,
It would wrap it like this ~console.log(`${foo}`)~.

#+BEGIN_SRC js :tangle no
const foo = 'Foo'
console.log(`${foo}`)
#+END_SRC

#+BEGIN_SRC elisp
(defun +js|convert-sexp-to-template-string ()
  "Wrap sexp into a template string"
  (interactive)
  (kill-sexp)
  (insert (concat "`${" (substring-no-properties (car kill-ring)) "}`"))
  (pop kill-ring))
#+END_SRC

***** Split / Join JSX Tag Node

Stolen from the vscode extension: [[https://github.com/dannyconnell/vscode-split-html-attributes][dannyconnell/vscode-split-html-attributes]]
I don't want to translate this to elisp, and js works as well.

Split/Joins a JSX tags by seperating the attributes

#+BEGIN_SRC js :tangle "./.cache/split-join-tag.js"
const useSpacesForTabs = true;
const tabSize = 4;
const sortOrder = [];
const closingBracketOnNewLine = true;

let input = process.argv[2]

// count the number of lines initally selected
let lineCount = input.split('\n').length
let lineText = input

// get the initial white space at the start of the line
let initialWhitespaceRegex = /\s*/i
let initialWhitespace = lineText.match(initialWhitespaceRegex)[0]

// get the opening tag
let openingTagRegex = /^[^\s]+/
let openingTag = input.match(openingTagRegex)[0]

// remove opening tag and trim
input = input.replace(openingTagRegex, '')
input = input.trim()

// get the ending bracket (if it's a "/>")
let endingBracket = ''
if (input.endsWith('/>')) {
    endingBracket = '/>'
}
else {
    endingBracket = '>'
}

// remove ending bracket and trim
if (endingBracket == '/>') {
    input = input.replace('/>', '')
}
else {
    input = input.substring(0, input.length - 1)
}
input = input.trim()

// create the indentation string
let indentationString
if (useSpacesForTabs == false) {
    indentationString = '\t'
}
else {
    indentationString = ' '.repeat(tabSize)
}

// regex to select all spaces that aren't within quotes
let spacesRegex = /\s+(?=([^"]*"[^"]*")*[^"]*$)/g

// get attributes into an array
let attributesString = input.replace(spacesRegex, '\n')
let attributesArray = attributesString.split('\n')

// sort the attributes array
let sortedAttributesArray = []
if (sortOrder.length) {

    // loop through sortOrder array
    sortOrder.forEach(search => {
        // loop through attributesArray
        let itemsToMove = []
        attributesArray.forEach((item, index) => {
            if (item.match(search)) {
                itemsToMove.push(index)
                // attributesArray.splice(index, 1)
            }
        })
        // move matched items from attributesArray to sortedAttributesArray (and sort them)
        let tempMatchedItems = []
        itemsToMove.forEach(indexItem => {
            tempMatchedItems.push(attributesArray[indexItem])
        })
        tempMatchedItems.sort()
        sortedAttributesArray.push(...tempMatchedItems)

        // remove matched items from attributesArray
        for (var i = itemsToMove.length - 1; i >= 0; --i) {
            attributesArray.splice(itemsToMove[i], 1)
        }
    })

    // sort remaining attributes and add to sortedAttributesArray
    attributesArray.sort()
    sortedAttributesArray.push(...attributesArray)
}
else {
    sortedAttributesArray = attributesArray
}

// add the opening tag
let result = openingTag

// set the join character based on number of lines initially selected
// (newLine if one line, space if more)
let joinCharacter = lineCount > 1 ? ' ' : '\n'

// if there are no attributes, set joinCharacter to ''
if (sortedAttributesArray.length == 1 && sortedAttributesArray[0] == '') {
    joinCharacter = ''
}

// add the sorted attributes to the textSplit string
if (lineCount > 1) {
    sortedAttributesArray.forEach(item => {
        result += joinCharacter + item
    })
}
else {
    sortedAttributesArray.forEach(item => {
        result += joinCharacter + initialWhitespace + indentationString + item
    })
}

// configure ending bracket (new line or not new line)
if (lineCount > 1) {
    if (endingBracket == '/>') {
        endingBracket = ' ' + endingBracket
    }
}
else {
    if (closingBracketOnNewLine) {
        endingBracket = '\n' + initialWhitespace + endingBracket
    }
    else if (endingBracket == '/>') {
        endingBracket = ' ' + endingBracket
    }
}

// add the ending bracket
result = result + endingBracket

console.log(result)
#+END_SRC

#+BEGIN_SRC elisp
(defun +rjsx/find-opening-closing-tag ()
  "Return the opening and closing carent character positions for a tag under the cursor."
  (save-excursion
    (let* ((is-evil-normal-state (evil-normal-state-p))
           (opening
            (or (-some->> (rjsx--tag-at-point)
                  (js2-node-abs-pos))
                ;; Fallback when js2-node-abs-pos parser fails
                (save-excursion (search-backward "<"))))
           (closing (progn
                      (when is-evil-normal-state
                        (evil-insert-state))
                      (while (and
                              (re-search-forward "[^=]>" (point-max) t nil)
                              (progn (backward-char 1) t)
                              (rjsx--tag-at-point)
                              (not (eq (js2-node-abs-pos (rjsx--tag-at-point)) opening))
                              (progn (forward-char 1) t)))
                      (when is-evil-normal-state
                        (evil-normal-state))
                      (forward-char 2)
                      (point))))
      (cons opening closing))))

(defun +rjsx/split-join ()
  "Function docstring"
  (interactive)
  (when (eq ?> (char-after))
    (backward-char 1))
  (-let* ((bounds (cond
                   ((use-region-p) (cons (region-beginning) (region-end)))
                   (t (+rjsx/find-opening-closing-tag))))
          ((beg . end) bounds)
          (input (->> (buffer-substring-no-properties beg end)
                   (s-replace "\n" "\\n")
                   (s-replace "'" "\\'")))
          (output (->> (shell-command-to-string (t! "node <<doom-private-dir>>/.cache/split-join-tag.js  $'<<input>>'"))
                    (s-trim-right))))
    (delete-region beg end)
    (insert output)
    (indent-region beg
                   ;; End position might be filled by whitespace, so we search again for the ending carent
                   (save-excursion (progn
                                     (goto-char (cdr (+rjsx/find-opening-closing-tag))))))))
#+END_SRC

***** Expand self closing tag

Converts self closing JSX tags to closing tags.
~<Foo />~ -> ~<Foo>|</Foo>~

#+BEGIN_SRC elisp
(defun +rjsx|expand-insert-self-closing-tag ()
  "Opens the current tag at any position of the cursor and starts insert mode"
  (interactive)
  (search-forward "/>")
  (evil-backward-char)
  (call-interactively #'delete-backward-char)
  (call-interactively #'rjsx-electric-gt)
  (newline)
  (call-interactively #'evil-indent-line)
  (call-interactively #'evil-open-above))
#+END_SRC

***** Extract Props from function arguments to body

#+BEGIN_SRC elisp
(defun +js|extract-props ()
  "Extract props object under the cursor."
  (interactive)
  (save-excursion
    (let* ((point-start (search-backward "{"))
           (point-end (search-forward "}"))
           (text (buffer-substring-no-properties point-start point-end)))
      (delete-region point-start point-end)
      (insert "props")
      (evil-open-below 1)
      (insert (template "const <<text>> = props;"))
      (search-backward "}")
      (js2r-expand-node-at-point)))
  (evil-normal-state))
#+END_SRC

***** Company Files

Remove the ~js~ extension for ~company-files~.

#+BEGIN_SRC elisp :tangle no
(defun company-js-files (command &optional arg &rest ignored)
  "Company complete path. Remove extension after completion"
  (interactive (list 'interactive))
  (require 'company)
  (cl-case command
    (interactive (company-begin-backend 'company-js-files))
    (prefix (company-files--grab-existing-name))
    (candidates (company-files--complete arg))
    (location (cons (dired-noselect
                     (file-name-directory (directory-file-name arg))) 1))
    (post-completion (when (s-matches? "\.js$" arg) (delete-backward-char 3)))
    (sorted t)
    (no-cache t)))

(map! :map js2-mode-map
      :i "C-x C-f" #'company-js-files)
#+END_SRC

***** Import JS File

#+BEGIN_SRC elisp :tangle no
(defun +js/import-file (file)
  (let ((cursor-postion (point))
        (filename (f-no-ext file)))
    (insert (template "import  from '<<filename>>';"))
    (goto-char cursor-postion)
    (forward-char 7)
    (evil-insert-state)))

(defun +js|ivy-import-file (&optional action)
  (interactive)
  (let* ((local-files
          (-->
           (-concat (list find-program) counsel-file-jump-args)
           (string-join it " ")
           shell-command-to-string
           split-string))
         (node-packages
          (-->
           (concat "jq -r '.dependencies | keys | .[]' " (concat (projectile-project-root) "package.json"))
           shell-command-to-string
           split-string))
         (imports (append local-files node-packages)))
    (ivy-read "Import file " imports :action (or action '+js/import-file))))
 #+END_SRC

***** Switch Ternary

#+BEGIN_SRC elisp
(defun js2r-ternary-switch-statements ()
  "Switch expressions in a ternary."
  (interactive)
  (js2r--guard)
  (js2r--wait-for-parse
   (save-excursion
     (let* ((ternary (js2r--closest 'js2-cond-node-p))
            (test-expr (js2-node-string (js2-cond-node-test-expr ternary)))
            (true-expr (js2-node-string (js2-cond-node-true-expr ternary)))
            (false-expr (js2-node-string (js2-cond-node-false-expr ternary)))
            (stmt (js2-node-parent-stmt ternary))
            (stmt-pre (buffer-substring (js2-node-abs-pos stmt) (js2-node-abs-pos ternary)))
            (stmt-post (s-trim (buffer-substring (js2-node-abs-end ternary) (js2-node-abs-end stmt))))
            (beg (js2-node-abs-pos stmt)))
       (goto-char beg)
       (delete-char (js2-node-len stmt))
       (insert "return " test-expr)
       (newline)
       (insert "? " false-expr)
       (newline)
       (insert ": " true-expr ";")
       (indent-region beg (point))))))
#+END_SRC

***** Ignore Flycheck error on line

#+BEGIN_SRC elisp
(defun +js|eslint-fix-ignore-error ()
  "Adds an ignore with the current flycheck error."
  (interactive)
  (if-let ((error-id (flycheck-copy-errors-as-kill (point) #'flycheck-error-id)))
    (save-excursion
      (previous-line)
      (end-of-line)
      (newline-and-indent)
      (insert (template "// eslint-disable-next-line <<error-id>>")))))
#+END_SRC
***** Find file from package.json root

#+BEGIN_SRC elisp
(defun +javscript|package-root-files ()
  "Find any file relative to the upmost package.json,
useful for repos that contain multiple packages."
  (interactive)
  (let ((default-directory
          (f--traverse-upwards (f-exists? (f-expand "package.json" it)))))
    (+default/find-file-under-here)))
#+END_SRC


***** Find node_modules package

Go to a package from the node_modules directory.

#+BEGIN_SRC elisp
(defun +javascript/find-npm-package-goto (package)
  "Go to directory by package name"
  (-some->> (f-join (projectile-project-root) "node_modules")
    (-id-when #'f-exists?)
    (-f-join package)
    (find-file)))

(defun +javascript|find-npm-package ()
  "Find package in node_modules directory."
  (interactive)
  (-when-let* ((json (-some->> (f-join (projectile-project-root) "package.json")
                       (-id-when #'f-exists?)
                       (json-read-file)))
               ((&alist 'dependencies dependencies
                        'devDependencies devDependencies) json)
               (packages (->> (-concat dependencies devDependencies)
                              (-map #'car))))
    (ivy-read "Go to package directory: " packages
              :action #'+javascript/find-npm-package-goto)))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after js2-mode
 :map js2-mode-map
 :desc "Goto parent function" :n "gh" (cmd! (js2-beginning-of-defun))
 :localleader
 :desc "Goto NPM Package" "m" #'+javascript|find-npm-package
 :desc "Package Root Files" "SPC" #'+javscript|package-root-files
 (:prefix-map ("c" . "Create")
  :desc "Import File" "i" #'js-import))

(map!
 :after rjsx-mode
 :map rjsx-mode-map
 :localleader
 (:desc "Open Self-Closing Tag" :n ">" #'+rjsx|expand-insert-self-closing-tag)
 (:desc "Rename Tag" :n "," #'rjsx-rename-tag-at-point)
 (:desc "Collapse/Expand Tag" :n "<" #'+rjsx/split-join))
#+END_SRC

***** Evil Function Text Object Motion

Adds text objects for functions in javascript.
So you can press ~daf~ to delete a function.

#+BEGIN_SRC elisp
(add-hook! js-mode
  (require 'evil-text-objects-javascript)
  (evil-text-objects-javascript/install))
#+END_SRC

***** Evil Method Text Object Motion

Overwrite ~evil-text-objects-javascript~ to also accepts methods.

I mainly changed the function marking helper.

#+BEGIN_SRC diff :tangle no
- (call-interactively #'mark-defun)
+ (call-interactively #'js2-mark-defun)
#+END_SRC

#+BEGIN_SRC elisp
(after! evil-text-objects-javascript
  (evil-define-text-object
    evil-inner-javascript-function (count &optional beg end type)
    "inner text object for all javascript functions."
    (call-interactively #'js2-mark-defun)
    (narrow-to-region (region-beginning) (region-end))
    (goto-char (point-min))
    (let* ((beg (save-excursion
                  (search-forward "(")
                  (backward-char)
                  (evil-jump-item)
                  (search-forward-regexp "[({]")
                  (point)))
           (end (save-excursion
                  (goto-char beg)
                  (evil-jump-item)
                  (point))))
      (evil-range beg end type)))

  (evil-define-text-object
    evil-outer-javascript-function (count &optional beg end type)
    "Outer text object for all Javascript functions."
    (call-interactively #'js2-mark-defun)
    (narrow-to-region (region-beginning) (region-end))
    (goto-char (point-min))
    (let* ((beg (save-excursion
                  (when (looking-at "[[:space:]]")
                    (evil-forward-word-begin))
                  (point)))
           (end (save-excursion
                  (goto-char beg)
                  (search-forward "(")
                  (backward-char)
                  (evil-jump-item)
                  (search-forward-regexp "[({]")
                  (evil-jump-item)
                  (forward-char)
                  (if (save-excursion
                        (progn
                          (forward-char)
                          (when (looking-at ",") (point))))
                    (point)))))
      (evil-range beg end type))))
#+END_SRC
*** Nim
**** Config

#+begin_src elisp
(use-package nim-mode
  :ensure t
  :hook
  (nim-mode . lsp)
  :config
  (setq nim-compile-default-command '("c"
                                      "-r"
                                      "--verbosity:0"
                                      "--hint[Processing]:off"
                                      "--hint[XDeclaredButNotUsed]:off"
                                      "--hint[DuplicateModuleImport]:off"
                                      "--excessiveStackTrace:on"
                                      "--outdir:/tmp/nimbins")))
#+end_src

**** Nimpretty

#+begin_src elisp
(defcustom nimpretty-command "nimpretty"
  "The 'nimpretty' command."
  :type 'string
  :group 'nim)

(defcustom nimpretty-show-errors 'buffer
  "Where to display nimpretty error output.
It can either be displayed in its own buffer, in the echo area, or not at all.

Please note that Emacs outputs to the echo area when writing
files and will overwrite nimpretty's echo output if used from inside
a `before-save-hook'."
  :type '(choice
          (const :tag "Own buffer" buffer)
          (const :tag "Echo area" echo)
          (const :tag "None" nil))
  :group 'nim)

(defcustom nimpretty-args nil
  "Additional arguments to pass to nimpretty."
  :type '(repeat string)
  :group 'nim)

(defun nim--goto-line (line)
  (goto-char (point-min))
  (forward-line (1- line)))

(defalias 'nim--make-nearby-temp-file
  (if (fboundp 'make-nearby-temp-file) #'make-nearby-temp-file
    (lambda (prefix &optional dir-flag suffix)
      (let ((temporary-file-directory (nim--temporary-file-directory)))
        (make-temp-file prefix dir-flag suffix)))))

(defalias 'nim--temporary-file-directory
  (if (fboundp 'temporary-file-directory) #'temporary-file-directory
    (lambda ()
      (let ((remote (file-remote-p default-directory)))
        (if remote
            ;; Assume that /tmp is a temporary directory on the remote host.
            ;; This won’t work on Windows.
            (concat remote "/tmp")
          temporary-file-directory)))))

(defalias 'nim--file-local-name
  (if (fboundp 'file-local-name) #'file-local-name
    (lambda (file) (or (file-remote-p file 'localname) file))))

(defun nimpretty--kill-error-buffer (errbuf)
  (let ((win (get-buffer-window errbuf)))
    (if win
        (quit-window t win)
      (kill-buffer errbuf))))

(defun nimpretty--process-errors (filename tmpfile errbuf)
  (with-current-buffer errbuf
    (if (eq nimpretty-show-errors 'echo)
        (progn
          (message "%s" (buffer-string))
          (nimpretty--kill-error-buffer errbuf))
      ;; Convert the nimpretty stderr to something understood by the compilation mode.
      (goto-char (point-min))
      (insert "nimpretty errors:\n")
      (let ((truefile tmpfile))
        (while (search-forward-regexp
                (concat "^\\(" (regexp-quote (nim--file-local-name truefile))
                        "\\):")
                nil t)
          (replace-match (file-name-nondirectory filename) t t nil 1)))
      (compilation-mode)
      (display-buffer errbuf))))

(defun nim--delete-whole-line (&optional arg)
  "Delete the current line without putting it in the `kill-ring'.
Derived from function `kill-whole-line'.  ARG is defined as for that
function."
  (setq arg (or arg 1))
  (if (and (> arg 0)
           (eobp)
           (save-excursion (forward-visible-line 0) (eobp)))
      (signal 'end-of-buffer nil))
  (if (and (< arg 0)
           (bobp)
           (save-excursion (end-of-visible-line) (bobp)))
      (signal 'beginning-of-buffer nil))
  (cond ((zerop arg)
         (delete-region (progn (forward-visible-line 0) (point))
                        (progn (end-of-visible-line) (point))))
        ((< arg 0)
         (delete-region (progn (end-of-visible-line) (point))
                        (progn (forward-visible-line (1+ arg))
                               (unless (bobp)
                                 (backward-char))
                               (point))))
        (t
         (delete-region (progn (forward-visible-line 0) (point))
                        (progn (forward-visible-line arg) (point))))))

(defun nim--apply-rcs-patch (patch-buffer)
  "Apply an RCS-formatted diff from PATCH-BUFFER to the current buffer."
  (let ((target-buffer (current-buffer))
        ;; Relative offset between buffer line numbers and line numbers
        ;; in patch.
        ;;
        ;; Line numbers in the patch are based on the source file, so
        ;; we have to keep an offset when making changes to the
        ;; buffer.
        ;;
        ;; Appending lines decrements the offset (possibly making it
        ;; negative), deleting lines increments it. This order
        ;; simplifies the forward-line invocations.
        (line-offset 0)
        (column (current-column)))
    (save-excursion
      (with-current-buffer patch-buffer
        (goto-char (point-min))
        (while (not (eobp))
          (unless (looking-at "^\\([ad]\\)\\([0-9]+\\) \\([0-9]+\\)")
            (error "Invalid rcs patch or internal error in nim--apply-rcs-patch"))
          (forward-line)
          (let ((action (match-string 1))
                (from (string-to-number (match-string 2)))
                (len  (string-to-number (match-string 3))))
            (cond
             ((equal action "a")
              (let ((start (point)))
                (forward-line len)
                (let ((text (buffer-substring start (point))))
                  (with-current-buffer target-buffer
                    (cl-decf line-offset len)
                    (goto-char (point-min))
                    (forward-line (- from len line-offset))
                    (insert text)))))
             ((equal action "d")
              (with-current-buffer target-buffer
                (nim--goto-line (- from line-offset))
                (cl-incf line-offset len)
                (nim--delete-whole-line len)))
             (t
              (error "Invalid rcs patch or internal error in nim--apply-rcs-patch")))))))
    (move-to-column column)))

(defun nimpretty ()
  "Format the current buffer according to the formatting tool.

The tool used can be set via ‘nimpretty-command’ (default: nimpretty) and additional
arguments can be set as a list via ‘nimpretty-args’."
  (interactive)
  (let ((tmpfile (nim--make-nearby-temp-file "nimpretty" nil ".nim"))
        (patchbuf (get-buffer-create "*Nimpretty patch*"))
        (errbuf (if nimpretty-show-errors (get-buffer-create "*Nimpretty Errors*")))
        (coding-system-for-read 'utf-8)
        (coding-system-for-write 'utf-8)
        our-nimpretty-args)

    (unwind-protect
        (save-restriction
          (widen)
          (if errbuf
              (with-current-buffer errbuf
                (setq buffer-read-only nil)
                (erase-buffer)))
          (with-current-buffer patchbuf
            (erase-buffer))

          (write-region nil nil tmpfile)

          (setq our-nimpretty-args
                (append our-nimpretty-args nimpretty-args
                        (list (file-local-name tmpfile))))
          (message "Calling nimpretty: %s %s" nimpretty-command our-nimpretty-args)
          (if (zerop (apply #'process-file nimpretty-command nil errbuf nil our-nimpretty-args))
              (progn
                ;; There is no remote variant of ‘call-process-region’, but we
                ;; can invoke diff locally, and the results should be the same.
                (if (zerop (let ((local-copy (file-local-copy tmpfile)))
                             (unwind-protect
                                 (call-process-region
                                  (point-min) (point-max) "diff" nil patchbuf
                                  nil "-n" "-" (or local-copy tmpfile))
                               (when local-copy (delete-file local-copy)))))
                    (message "Buffer is already nimprettied")
                  (nim--apply-rcs-patch patchbuf)
                  (message "Applied nimpretty"))
                (if errbuf (nimpretty--kill-error-buffer errbuf)))
            (message "Could not apply nimpretty")
            (if errbuf (nimpretty--process-errors (buffer-file-name) tmpfile errbuf))))

      (kill-buffer patchbuf)
      (delete-file tmpfile))))

(use-package! nim-mode
  :config
  (map!
    :localleader
    :map nim-mode-map
    "p" #'nimpretty))
#+end_src
**** Flycheck for ~v.1.6.0~

Nim has different output for v1.6.0 for linting, so this broke flycheck

The error output for 1.6.0 is

#+BEGIN_QUOTE
FILENAME:3:8 Hint: duplicate import of 'osproc'; previous import here: FILENAME:1:8 [DuplicateModuleImport]
FILENAME:73:14 Error: expression 'getCacheDir()' is of type 'string' and has to be used (or discarded)
#+END_QUOTE


#+begin_src elisp
(after! nim-mode
  (flycheck-define-checker nim-1-6-0
    "A syntax checker for the nim programming language.
v1.6.0 has a different output style than previously

See http://nim-lang.org"
    :command ("nim" "check"
              (option-flag "--experimental" flycheck-nim-experimental)
              (option-flag "--threads:on" flycheck-nim-threads)
              (option "--hints:" flycheck-nim-hints concat)
              (option "--warnings:" flycheck-nim-warnings concat)
              (eval (--map (format "--hint[%s]:%s" (car it) (cadr it))
                           flycheck-nim-specific-hints))
              (eval (--map (format "--warning[%s]:%s" (car it) (cadr it))
                           flycheck-nim-specific-warnings))
              (eval flycheck-nim-args)
              ;; Must use source-inplace so relative imports and
              ;; qualified references to local variables resolve correctly
              source-inplace)
    :error-patterns
    ((error line-start (file-name) ":" line ":"
            column " Error:"
            (message (one-or-more not-newline)
                     (optional
                      (and "\nbut expected one of:"
                           (minimal-match (one-or-more anything)) "\n\n"))))
     (warning line-start (file-name) ":" line ":"
              column " " (or "Hint:" "Warning:") (message) line-end))
    :error-filter
    (lambda (errors)
      (flycheck-sanitize-errors (flycheck-increment-error-columns errors)))
    :modes (nim-mode nimrod-mode)
    :predicate (lambda () (not org-src-mode)))

  (add-to-list 'flycheck-checkers 'nim-1-6-0))
#+end_src
**** Import Nim Package

Finds packages either from nims std lib or your nim packages.

- Requires evil for inserting
- Requires ~$NIM_UNWRAPPED_DIR~ to be set to nims source repository on your disk
- Searches for nimble dir in either ~$NIMBLE_DIR~ or your users home directory

To set a nimble directory via nix shell add this snippet:

#+begin_src nix :tangle no
{ pkgs, packages, nimpkgs, buildInputs }:

pkgs.mkShell {
  shellHook = ''
    export NIMBLE_DIR="$PWD/.nimble"
  '';
};
#+end_src


#+begin_src elisp
(defun +nim|import/add-std-import-statement (import)
  "Insert stdlib import below last stdin statement."
  (goto-char (point-max))
  (cond ((search-backward-regexp "^import std/.+$" 0 t)
         (evil-insert-newline-below))
        ((goto-char (point-min)) (evil-insert-newline-above)))
  (insert (t! "import std/<<import>>")))

(defun +nim|import/add-lib-import-statement (import)
  "Insert package import below all import statements."
  (goto-char (point-max))
  (cond ((search-backward-regexp "^import .+$" 0 t)
         (evil-insert-newline-below))
        ((goto-char (point-min)) (evil-insert-newline-above)))
  (insert (t! "import <<import>>")))

(defun +nim|import ()
  "Add import from nims stdlib or your nimble packages."
  (interactive)
  (let* ((nim-src-dir (-some->> (getenv "NIM_UNWRAPPED_DIR")
                        (-f-join "nim/lib/pure")
                        (-id-when #'f-exists?)))
         (libs (->> (f-entries nim-src-dir (lambda (x) (f-ext? x "nim")) t)
                    (--map (->> (f-relative it nim-src-dir)
                                (f-no-ext)
                                ((lambda (x) (cons x 'libs)))))))
         (nim-deps-dir (-some->> (or (getenv "NIMBLE_DIR")
                                     (f-expand "~/.nimble"))
                         (-f-join "pkgs")
                         (-id-when #'f-exists?)))
         (deps (->> (f-directories nim-deps-dir)
                    (--map (-some->>
                               (f-files it (lambda (x) (f-ext? x "nim")))
                             (car)
                             (f-base)
                             (s-replace-regexp "-[0-9\\.]+$" "")
                             ((lambda (x) (cons x 'deps))))))))
    (ivy-read "Import: " (-concat libs deps)
              :action (lambda (import)
                        (save-excursion
                          (pcase import
                            (`(,x . deps) (+nim|import/add-lib-import-statement x))
                            (`(,x . libs) (+nim|import/add-std-import-statement x))))))))
#+end_src
**** Bindings

#+BEGIN_SRC elisp
(map!
 :after nim-mode
 :map nim-mode-map
 :localleader
 (:prefix-map ("c" . "Create")
  :desc "Import File" "i" #'+nim|import))
#+END_SRC

** Package Config
*** Beancount
**** Config

#+BEGIN_SRC elisp
(use-package! beancount
  :defer t
  :mode
  ("\\.bean\\(?:count\\)?\\'" . beancount-mode)
  :config
  (setq beancount-accounts-files
        (directory-files "~/Documents/Beancount"
                         'full
                         (rx ".beancount.gpg" eos))))
#+END_SRC

**** Functions

***** Helpers

#+BEGIN_SRC elisp
(defun +beancount/collect-accounts ()
  "Collect accounts from beancount files."
  (beancount-collect beancount-account-regexp 0 beancount-accounts-files))

(defvar +beancount:income-accounts nil
  "Prefixes for expense accounts.")
(setq +beancount:income-accounts '("Assets" "Liabilities"))

(defun +beancount/collect-expense-accounts (accounts)
  "Collect accounts from list ACCOUNTS."
  (-filter (lambda (x) (--find (s-starts-with? it x) +beancount:income-accounts)) accounts))

(defun +beancount/date-string ()
  "Function docstring"
  (format-time-string "%Y-%m-%d"))
#+END_SRC

***** Open Main File

#+BEGIN_SRC elisp
(defun +beancount|open-main ()
  "Open the main beancount-accounts-files file."
  (interactive)
  (find-file (car beancount-accounts-files)))
#+END_SRC

***** Balance
:PROPERTIES:
:SOURCE:   https://github.com/CanftIn/dotfiles/blob/cd919c6e3f4970ba56248ac68ab072111a00049f/.doom.d/config%20copy.el
:END:

#+BEGIN_SRC elisp
(defun +beancount|balance ()
    "Show the current balances."
    (interactive)
    (let ((compilation-read-command nil))
      (beancount--run "bean-report"
                      (file-relative-name buffer-file-name) "bal")))
#+END_SRC

***** Add expense

Manually add an expense to the Cash Book.

#+BEGIN_SRC elisp
(defun +beancount|add-expense ()
  "Add expense to the bottom of the file."
  (interactive)
  (and-let* ((accounts (+beancount/collect-accounts))
             (from (ivy-read "From: " (+beancount/collect-expense-accounts accounts)))
             (to (ivy-read "To: " accounts))
             (subject (read-string "Subject: "))
             (amount (read-number "Amount: ")))
      (goto-char (point-max))
      (newline 1)
      (insert (template "<<(+beancount/date-string)>> * \"<<subject>>\"
  <<from>> -<<amount>> EUR
  <<to>> <<amount>> EUR
"))
      (beancount-align-to-previous-number)))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map! :map beancount-mode-map
      :localleader
      :n "a" #'+beancount|add-expense
      :n "c" #'beancount-check
      :n "q" #'beancount-query
      :n "b" #'+beancount|balance)
#+END_SRC

*** RSS with Elfeed
**** Utils
***** Open

#+BEGIN_SRC elisp
(defun +rss|open ()
  (interactive)
  (unless (get-buffer "*elfeed-search*")
    (setq elfeed-search-filter +rss:default-search-filter))
  (elfeed)
  (+rss|hydra/body))
#+END_SRC

***** Custom Filters
****** All unread

#+BEGIN_SRC elisp
(defun +rss|search-unread ()
  "Show elfeed articles tagged with unread"
  (interactive)
  (elfeed-search-set-filter "@6-months-ago +unread"))
#+END_SRC

***** Visit

Open the current entry:
- With the browser
- Or if it's a youtube feed, open with [[*Elfeed MPV][mpv]]

#+BEGIN_SRC elisp
(defun +rss|visit-dwim ()
  "Either open the current entry in eww or play it in mpv."
  (interactive)
  (message "")
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (patterns +rss:mpv-patterns))
    (while (and patterns (not (string-match (car +rss:mpv-patterns) (elfeed-entry-link entry))))
      (setq patterns (cdr patterns)))
    (if patterns
        (+rss|play-with-mpv)
      (if (eq major-mode 'elfeed-search-mode)
          (elfeed-search-browse-url)
        (elfeed-show-visit)))))
#+END_SRC

***** Open with EWW

#+BEGIN_SRC elisp
(defun +rss|open-eww ()
  "Open the current entry with eww."
  (interactive)
  (add-hook 'eww-after-render-hook 'eww-readable nil t)
  (let ((buffer (save-window-excursion
                  (eww (elfeed-entry-link elfeed-show-entry))
                  (current-buffer))))
    (switch-to-buffer buffer)))
#+END_SRC

***** Wrap Elfeed

#+BEGIN_SRC elisp
(defun +rss|elfeed-wrap ()
  "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
  (let ((inhibit-read-only t)
        (inhibit-modification-hooks t))
    (setq-local truncate-lines nil)
    (setq-local shr-width 100)
    (setq-local +zen-text-scale 0.9)
    (mixed-pitch-mode)
    (writeroom-mode)
    (set-buffer-modified-p nil)))

(add-hook 'elfeed-show-mode-hook #'+rss|elfeed-wrap)
#+END_SRC

***** Elfeed open video with MPV

Play youtube entries via MPV

#+BEGIN_SRC elisp
(defvar +rss:mpv-patterns
  '("youtu\\.?be")
  "List of regexp to match against elfeed entry link to know
whether to use mpv to visit the link.")

(defun +rss|play-with-mpv ()
  "Play entry link with mpv."
  (interactive)
  (let ((entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single)))
        (url (elfeed-entry-link entry)))
    (my::shell/mpv-youtube-url url)))
#+END_SRC

***** Capture Elfeed Entries

#+BEGIN_SRC elisp
(defun +rss/stringify-entry (entry)
  (let ((title (->> (elfeed-entry-title entry)
                    ;; Remove braces, they're just confusing to org links
                    (s-replace "[" "")
                    (s-replace "]" "")))
        (url (elfeed-entry-link entry))
        (author (->> (elfeed-meta entry :authors)
                     car
                     ((lambda (x) (plist-get x :name)))))
        (tags (-some--> (elfeed-entry-tags entry)
                (-remove-item 'unread it)
                (-map #'symbol-name it)
                (s-join ":" it)
                (s-wrap it ":" ":"))))
    (template "[[<<url>>][<<author>> - <<title>>]] <<(when tags tags)>>")))

(defun +rss|capture ()
  "Capture current entry of elfeed."
  (interactive)
  (let* ((entry (if (eq major-mode 'elfeed-show-mode)
                   elfeed-show-entry
                 (elfeed-search-selected :single)))
         (org-entry (+rss/stringify-entry entry)))
       (kill-new org-entry)
       (if (s-contains? org-entry "youtube.com")
           (org-capture nil "ew")
        (org-capture nil "er"))))

;; (map!
;;  :after elfeed
;;  :map (elfeed-show-mode-map elfeed-show-mode-map)
;;  :local
;;  :gn "Co" #'+rss|capture)
#+END_SRC

***** Update feeds when saving org-elfeed file

When I save the elfeed org-mode file I want to automatically update the feed list.
Update function taken from [[file:~/.emacs.d/.local/straight/repos/elfeed-org/elfeed-org.el::rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id)][elfeed package]].

#+BEGIN_SRC elisp
(add-hook 'after-save-hook (defun +org-efleed/update-feeds ()
                             (when (and (eq major-mode 'org-mode)
                                        (string= buffer-file-name (car rmh-elfeed-org-files)))
                                (require 'elfeed)
                                (rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id))))
#+END_SRC

***** Hydra

#+BEGIN_SRC elisp
(defun +rss/toggle-filter (tag)
  "Toggle elfeed filter TAG or append to filters if non-existent."
  (->> (or (-when-let* (((_ modi) (s-match (t! "\\_<\\([+-]\\)<<tag>>\\_>") elfeed-search-filter))
                        (new-modi (if (string= modi "+") "-" "+")))
             (s-replace-regexp (t! "\\_<\\<<modi>><<tag>>\\_>") (t! "<<new-modi>><<tag>>") elfeed-search-filter))
           (s-append (t! " +<<tag>>") elfeed-search-filter))
       (--tap (progn (setq elfeed-search-filter it)
                     (elfeed-search-update--force)
                     (-log (t! "Filter changed to: <<it>>"))))))

(defun +rss|counsel-filter (&optional arg)
  "Toggles a filter in elfeed."
  (interactive "P")
  (ivy-read (t! "Filter: <<elfeed-search-filter>>") (elfeed-db-get-all-tags)
            :action #'+rss/toggle-filter
            :caller #'+rss|counsel-filter))

(defhydra +rss|hydra ()
   "Elfeed"
   ("j" (evil-next-line) "Next item" :column "Navigate")
   ("k" (evil-previous-line) "Previous item")
   ("t" (+rss|counsel-filter) "Tags" :column "Filter")
   ("0" (elfeed-search-set-filter "@2-weeksago +unread") "Unread" :column "Favorites")
   ("f" (elfeed-search-set-filter "@2-weeksago +unread -YOUTUBE -REDDIT") "Feeds")
   ("y" (elfeed-search-set-filter "@2-weeksago +unread +YOUTUBE") "Youtube")
   ("e" (elfeed-search-set-filter "@2-weeksago +unread +REDDIT =emacs") "Reddit: Emacs")
   ("n" (elfeed-search-set-filter "@2-weeksago +unread +REDDIT =nixos") "Reddit: Nixos")
   ("U" (elfeed-update) "Update" :column "actions")
   ("u" (elfeed-search-untag-all-unread) "Mark as unread")
   ("s" (elfeed-db-save) "Save DB")
   ("v" (+rss|visit-dwim) "Visit")
   ("q" nil "Quit" :color blue))
#+END_SRC

**** Config
***** Org Elfeed File

#+BEGIN_SRC elisp
(setq rmh-elfeed-org-files (list (+org/expand-org-file-name "Elfeed/Elfeed.org")))
#+END_SRC

***** Disable sliced images

These don't work if you have a big line-height.

#+BEGIN_SRC elisp
(setq +rss-enable-sliced-images nil)
#+END_SRC

***** Default Search

#+BEGIN_SRC elisp
(setq +rss:default-search-filter "@2-week-ago +unread -YOUTUBE")
(setq-default elfeed-search-filter +rss:default-search-filter)

#+END_SRC

**** Bindings
***** Search Mode Bindings

#+BEGIN_SRC elisp
(map!
 :after elfeed
 :map elfeed-search-mode-map
 :gn "r" #'elfeed-update
 (:prefix-map ("g" . "Go")
  :desc "Youtube" :gn "y" (cmd! (elfeed-search-set-filter "@2-week-ago +YOUTUBE +unread"))
  :desc "Normal"  :gn "n" (cmd! (elfeed-search-set-filter "@2-week-ago -YOUTUBE +unread"))
  :desc "Month"   :gn "m" (cmd! (elfeed-search-set-filter "@1-month-ago +unread"))))
#+END_SRC

***** Show Mode Bindings

#+BEGIN_SRC elisp
(map!
 :after elfeed
 :map elfeed-search-mode-map
 :gn "r" #'elfeed-update)
#+END_SRC

***** LocalLeader

#+BEGIN_SRC elisp
(map! :map (elfeed-search-mode-map elfeed-show-mode-map)
      :localleader
      :desc "Filter Hydra" "f" #'+rss|hydra/body
      :desc "Capture"      "c" #'+rss|capture
      :desc "Open Eww"     "o" #'+rss|open-eww
      :desc "Visit"        "v" #'+rss|visit-dwim
      (:prefix-map ("s" . "Search")
       :desc "Unread" "u" #'+rss|search-unread))
#+END_SRC

*** IRC

#+BEGIN_SRC elisp
(after! circe
  (set-irc-server! "chat.freenode.net"
                   `(:tls t
                          :port 6697
                          :nick "floscr"
                          :sasl-username ,(+pass-get-user "Irc/freenode.net")
                          :sasl-password (lambda (&rest _) (+pass-get-secret "Irc/freenode.net"))
                          :channels ("#emacs" "#nixos"))))
#+End_SRC

#+RESULTS:

*** Literate Calc Mode

#+BEGIN_SRC elisp
(use-package! literate-calc-mode
  :commands (literate-calc-mode literate-calc-minor-mode))
#+END_SRC

*** Calendar
**** Utils
***** Filtered Calendars
****** Personal (Without Work)

#+BEGIN_SRC elisp
(defun +calendar|personal (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "-WORK")))
      (call-interactively #'=calendar)))
#+END_SRC

****** Personal (Just Family)

#+BEGIN_SRC elisp
(defun +calendar|just-family (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "+FAMILY|+BIRTHDAY")))
      (call-interactively #'=calendar)))
#+END_SRC

****** Personal (Just Birthdays)

#+BEGIN_SRC elisp
(defun +calendar|birthdays (&rest args)
  (interactive)
  (let ((org-agenda-files `(,(+org/expand-org-file-name "Main/contacts.org")))
        (org-agenda-skip-function '(+org/agenda-skip-without-match "+BIRTHDAY")))
      (call-interactively #'=calendar)))
#+END_SRC

****** Personal (Without Family)

#+BEGIN_SRC elisp
(defun +calendar|no-family (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "-FAMILY-WORK")))
      (call-interactively #'=calendar)))
#+END_SRC

****** Work

#+BEGIN_SRC elisp
(defun +calendar|work (&rest args)
  (interactive)
  (let ((org-agenda-skip-function '(+org/agenda-skip-without-match "+WORK")))
      (call-interactively #'=calendar)))
#+END_SRC

**** Config
***** Calendars

Emacs comes with a lot of custom calendars that I don't want.
This is mostly copied from [[https://thenybble.de/projects/german-emacs-calendar.html][How to set up a german emacs calendar]].

****** General Holidays

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq general-holidays
        '((holiday-fixed 1 1 "New Years")
          (holiday-fixed 5 1 "1st Mai"))))
#+END_SRC

****** Austrian Holidays

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq austrian-holidays
        `((holiday-fixed 1 6 "Heilige drei Könige")
          (holiday-fixed 5 1 "Staatsfeiertag")
          (holiday-fixed 8 15 "Mariä Himmelfahrt")
          (holiday-fixed 10 26 "Nationalfeiertag")
          (holiday-fixed 11 1 "Allerheiligen")
          (holiday-fixed 12 8 "Mariä Empfängnis")
          (holiday-fixed 12 24 "Weihnachten")
          (holiday-fixed 12 25 "Christtag")
          (holiday-fixed 12 26 "Stefanitag")
          ;; variable
          (holiday-easter-etc -2 "Karfreitag")
          (holiday-easter-etc 0 "Ostersonntag")
          (holiday-easter-etc 1 "Ostermontag")
          (holiday-easter-etc 39 "Christi Himmelfahrt")
          (holiday-easter-etc 49 "Pfingstsonntag")
          (holiday-easter-etc 50 "Pfingstmontag")
          (holiday-easter-etc 60 "Fronleichnam"))))
#+END_SRC

****** Set calendars

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq calendar-holidays
        (append
          general-holidays
          austrian-holidays
          holiday-solar-holidays)))
#+END_SRC

***** General

#+BEGIN_SRC elisp
(after! calfw
  :config
  (setq calendar-week-start-day 1)
  (setq calendar-time-display-form
        '(24-hours ":" minutes (and time-zone (concat " (" time-zone ")"))))
  (setq calendar-abbrev-length 2))
#+END_SRC

*** Calc
**** Additional Units

#+BEGIN_SRC elisp
(setq math-additional-units '((GB "1024 * MiB" "Giga Byte")
                              (MB "1024 * KiB" "Mega Byte")
                              (KB "1024 * B" "Kilo Byte")
                              (B nil "Byte")))
#+END_SRC

*** Comint
**** Allow evil enter anywhere

Fix for comint mode, throwing an error when pressing enter in the middle of the line.

#+BEGIN_EXAMPLE
error in process filter: End of buffer
#+END_EXAMPLE

#+BEGIN_SRC elisp
(map!
 :after comint
 :map comint-mode-map
 :ni "RET" (cmd! (comint-send-input nil t))
 :n "<C-backspace>" #'comint-clear-buffer)
#+END_SRC

*** Company
**** Config
***** Sort company by occurrence
:PROPERTIES:
:SOURCE:   [[https://github.com/company-mode/company-mode/issues/52][{Proposal} Improve company-dabbrev candidate ordering · Issue #52 · company-mode/company-mode]]
:END:

#+BEGIN_SRC elisp
(setq company-transformers '(company-sort-by-occurrence)
      company-idle-delay 0.5)
#+END_SRC

**** Functions
***** Company complete whole lines for all matching buffers

Complete a whole line with all lines from buffers matching the current major-mode.

#+BEGIN_SRC elisp
(defun +company:buffer-list-with-modes (modes)
  "Get all buffers that match MODES"
  (--filter
   (with-current-buffer it (-contains? (doom-enlist modes) major-mode))
   (buffer-list)))

(defun +company:buffer-list-with-major-mode ()
  "Get all buffers matching the current major-mode
Has built in aliases"
  (let ((javascript-modes (list 'rjsx-mode 'js2-mode)))
    (pcase major-mode
      ('rjsx-mode
       (+company:buffer-list-with-modes javascript-modes))
      ('js2-mode
       (+company:buffer-list-with-modes javascript-modes))
      (_
       (+company:buffer-list-with-modes major-mode)))))

(defun +company/whole-lines-all-buffers (command &optional arg &rest ignored)
  "`company-mode' completion backend that completes whole-lines, akin to vim's
C-x C-l."
  (interactive (list 'interactive))
  (require 'company)
  (pcase command
    (`interactive (company-begin-backend '+company/whole-lines-all-buffers))
    (`prefix      (company-grab-line "^[\t\s]*\\(.+\\)" 1))
    (`candidates
     (all-completions
      arg
      (funcall (-compose
                #'-uniq
                #'-flatten
                (lambda (xs)
                  (--map (with-current-buffer it
                           (split-string
                            (replace-regexp-in-string
                             "^[\t\s]+" ""
                             (buffer-substring-no-properties (point-min) (point-max)))
                            "\\(\r\n\\|[\n\r]\\)" t)) xs)))
               (+company:buffer-list-with-major-mode))))))
#+END_SRC

Bindings

#+BEGIN_SRC elisp
(map!
 (:prefix "C-x"
   :i "C-l" #'+company/whole-lines-all-buffers
   :i "C-." #'+company/whole-lines))
#+END_SRC

*** Eldoc

#+BEGIN_SRC elisp :tangle no
;; Always truncate ElDoc messages to one line. This prevents the echo
;; area from resizing itself unexpectedly when point is on a variable
;; with a multiline docstring.
(setq eldoc-echo-area-use-multiline-p nil)

;; Show ElDoc messages in the echo area immediately, instead of after
;; 1/2 a second.
(setq eldoc-idle-delay 0)

;; Disable eldoc mode
(global-eldoc-mode -1)
#+END_SRC

*** Eshell
**** Aliases

Custom eshell aliases.

#+BEGIN_SRC elisp
(setq +eshell-aliases
  '(("q"      "exit")
    ("f"      "find-file $1")
    ("bd"     "eshell-up $1")
    ("rg"     "rg --color=always $*")
    ("ag"     "ag --color=always $*")
    ("l"      "ls -lh")
    ("ll"     "ls -lah")
    ("gs"     "git status")
    ("groot"  "cd (projectile-project-root)")
    ("gc"     "git commit")
    ("grha"   "git reset --hard; git clean -f -d")
    ("clear"  "clear-scrollback")))
#+END_SRC

**** Syntax highlighted cat

#+BEGIN_SRC elisp
(defun +eshell/cat (file)
  "Like `cat' but output with Emacs syntax highlighting."
  (with-temp-buffer
    (insert-file-contents file)
    (let ((buffer-file-name file))
      (delay-mode-hooks
        (set-auto-mode)
        (if (fboundp 'font-lock-ensure)
            (font-lock-ensure)
          (with-no-warnings
            (font-lock-fontify-buffer)))))
    (buffer-string)))

(add-to-list '+eshell-aliases '("cat" "+eshell/cat $1"))
#+END_SRC

*** Evil-Snipe
**** Repeat snipe after further key press

#+BEGIN_SRC elisp
(after! evil-snipe
  (setq evil-snipe-repeat-keys t))
#+END_SRC

*** EWW Web Browser
**** Set the max page width

#+BEGIN_SRC elisp
(setq shr-width 100)
#+END_SRC
*** Jest

#+BEGIN_SRC elisp
(use-package! jest
  :after (js2-mode)
  :hook (js2-mode . jest-minor-mode)
  :config
  (set-popup-rule! "^\\*jest\\*"
    :side 'right
    :size 0.5
    :select nil :quit 'current :ttl nil))
#+END_SRC

*** Git Lens

#+BEGIN_SRC elisp
(use-package! git-lens
  :commands (git-lens))
#+END_SRC

*** Symex

#+BEGIN_SRC elisp
(use-package! symex
  :commands (symex-mode symex-mode-interface))
#+END_SRC

*** Indium

#+BEGIN_SRC elisp
(use-package! indium
  :commands (indium-connect indium-launch)
  :init
  (setq indium-chrome-use-temporary-profile t)
  (setq indium-chrome--default-data-dir (f-join (getenv "XDG_CACHE_HOME") "inidum-chrome-profile"))
  (setq indium-chrome-data-dir (f-join (getenv "XDG_CACHE_HOME") "inidum-chrome-profile"))
  (map! :map (js2-mode-map rjsx-mode-map)
        :localleader
        (:prefix ("i" . "Indium")
          :desc "Console"                   "c" #'indium-switch-to-repl-buffer
          :desc "Launch"                    "l" #'indium-launch
          :desc "Launch"                    "q" #'indium-quit
          :desc "Add breakpoint"            "r" #'indium-reload
          (:prefix ("b" . "breakpoint")
            :desc "Add"                     "b" #'indium-add-breakpoint
            :desc "Conditional"             "c" #'indium-add-conditional-breakpoint
            :desc "Conditional"             "e" #'indium-edit-breakpoint-condition
            :desc "Conditional"             "l" #'indium-list-breakpoints
            :desc "Conditional"             "0" #'indium-deactivate-breakpoints
            :desc "Conditional"             "1" #'indium-activate-breakpoints
            :desc "Delete"                  "d" #'indium-remove-breakpoint
            :desc "Delete all from buffer"  "D" #'indium-remove-all-breakpoints-from-buffer
            :desc "Edit Condition"          "e" #'indium-toggle-breakpoint
            :desc "Toggle"                  "t" #'indium-toggle-breakpoint)))
  (map!
        :map indium-inspector-mode-map
        :n "-" #'indium-inspector-pop)
  (map! :map indium-debugger-mode-map
        :n "gr" #'indium-debugger-resume
        :n "gi" #'indium-debugger-step-into
        :n "go" #'indium-debugger-step-over
        :n "ge" #'indium-debugger-evaluate
        :n "gl" #'indium-debugger-locals)
  :config
  (set-popup-rule! "^\\*JS REPL*" :size 0.3)
  (set-popup-rule! "^\\*JS Debugger Locals*" :size 0.3))
#+END_SRC

*** Impatient-Mode

Serves the current buffer live over http.

#+BEGIN_SRC elisp
(use-package! impatient-mode
  :commands impatient-mode)
#+END_SRC

*** Narrow To Defun Indirect

When narrowing to region or defun, make it in an indirect other window.

Source:
- [[./packages/narrow-indirect.el]]
- [[https://www.emacswiki.org/emacs/NarrowIndirect][EmacsWiki: Narrow Indirect]]

#+BEGIN_SRC elisp
(use-package! narrow-indirect
  :init
  (global-set-key (kbd "C-x n n") 'ni-narrow-to-region-indirect-other-window)
  (global-set-key (kbd "C-x n d") 'ni-narrow-to-defun-indirect-other-window))
#+END_SRC

*** Ivy / Counsel
**** Config

Always show actions in hydra.

#+BEGIN_SRC elisp
(setq ivy-read-action-function #'ivy-hydra-read-action)
#+END_SRC

**** Bindings

Adds general bindings to ivy.
~MOD + ↩~ will insert the current item and continue with a new instance of the same ivy buffer.
~CTRL + ↩~ will abort completion and insert the inserted text.

#+BEGIN_SRC elisp
(map!
 :after ivy
 :map ivy-minibuffer-map
  "<s-return>" 'ivy-call
  "<C-tab>" 'minibuffer-complete
  "<C-return>" 'ivy-immediate-done
  "M-m" 'ivy-mark)
#+END_SRC

Find file on enter press for ~ivy-occur-mode~

#+BEGIN_SRC elisp
(map! :map ivy-occur-mode-map
      :gni "RET" #'ivy-occur-press-and-switch)
#+END_SRC

**** Functions
***** Counsel Project File Jump

#+BEGIN_SRC elisp
(defun +ivy/counsel-project-file-jump (x)
  "Jump to file in project"
  (interactive)
  (counsel-file-jump nil (f-join (projectile-project-root) x)))
#+END_SRC

***** Counsel Grep Buffers

#+BEGIN_SRC elisp
(defun +ivy|search-buffers (buffer-list)
  "Grep workspace buffers."
  (interactive)
  (-->
   (or buffer-list (+workspace-buffer-list))
   (cl-remove-if-not #'buffer-file-name it)
   (-map #'buffer-file-name it)
   (-map #'shell-quote-argument it)
   (s-join " " it)
   (counsel-grep-files it)))

(defun +ivy/search-buffer-list (&optional buffer-list)
  (--> (or buffer-list ivy--old-cands)
   (-log it)
   (-map #'shell-quote-argument it)
   (--map (f-join (doom-project-root) it) it)
   (s-join " " it)
   (counsel-grep-files it)))

(defun counsel-grep-files (buffer-file-names)
  "Grep for a string in the file visited by the current buffer."
  (interactive)
  (counsel-require-program counsel-grep-base-command
   (setq counsel-grep-command
         (format counsel-grep-base-command "%s" buffer-file-names))
   (message "%s" counsel-grep-command)
   (let ((init-point (point))
         res)
     (unwind-protect
         (setq res (ivy-read "grep: " #'counsel-grep-function
                             :dynamic-collection t
                             :require-match t
                             :keymap counsel-grep-map
                             :history 'counsel-grep-history
                             :re-builder #'ivy--regex
                             :action #'counsel-grep-action
                             :caller 'counsel-grep))
       (unless res
         (goto-char init-point))))))

(after! ivy
  (ivy-set-actions
   '+git|ivy-changed-files
   '(("/" (lambda (&optional arg)
            (+ivy/search-buffer-list))
      "Grep Forward"))))
#+END_SRC

***** Counsel External Drives

#+BEGIN_SRC elisp
(defun +ivy|counsel-mounted-drives ()
  "Counsel of mounted drives from udiskie."
  (interactive)
  (counsel-find-file (concat "/run/media/" (user-login-name) "/")))
#+END_SRC

**** Hacks
***** Banish mouse cursor

The cursor will steal the focus from ivy-posframe, breaking ivy completely...

This option moves the mouse cursor to 0x0,
which is really unacceptable, but works for now.

#+BEGIN_SRC elisp
(setq posframe-mouse-banish t)
#+END_SRC

***** Fix case-insensitive wgrep

#+BEGIN_SRC elisp :tangle no
(after! ivy
  (defadvice! respect-case-fold-search (args)
    :filter-return #'counsel--ag-extra-switches
    (concat args (pcase ivy-case-fold-search
                   (`auto " -S ")
                   (`t " -i ")
                   (`nil " -s ")))))
#+END_SRC
**** Actions

***** Search from ~counsel-find-file~

#+begin_src elisp
(defun +counsel/search-from-find-file (x)
  "Function docstring"
  (let ((default-directory (if (f-dir? x) x (f-dirname x))))
    (+default/search-cwd)))

(after! ivy
 (setq +counsel:search-from-find-file-action
  '(("s" +counsel/search-from-find-file "Search in directory")))
 (ivy-add-actions 'counsel-find-file +counsel:search-from-find-file-action))
#+end_src

*** JSON
**** Utils
***** Is Last JSON key at point

#+BEGIN_SRC elisp
(defun +json/is-last-key? ()
  "Is the next line the last json key."
  (save-excursion
    (forward-line)
    (my::buffer/line-contains "}")))
#+END_SRC

***** Insert JSON Key

Insert JSON key in a JSON document
This functions is dependant on the yasnippet: [[file:snippets/json-mode/key::# --][key]]

#+BEGIN_SRC elisp
(defun +json/insert-key (&optional above?)
  "Adds a new JSON key pair."
  (let ((last-line? (my::buffer/line-contains ",$")))
    ;; Insert comma
    (if (and (not last-line?) (not above?))
        (replace-regexp "$" "," nil (point-at-bol) (point-at-eol)))
    (end-of-line)
    (if above?
        (evil-insert-newline-above)
      (evil-insert-newline-below))
    (indent-according-to-mode)
    (yas/insert-by-name "key")))

(defun +json|insert-key-above ()
  "Function docstring"
  (interactive)
  (+json/insert-key t))

(defun +json|insert-key-below ()
  "Function docstring"
  (interactive)
  (+json/insert-key nil))
#+END_SRC

***** Autofix JSON

Uses [[https://www.npmjs.com/package/json-fix][json-fix]] to autofix JSON files.

#+BEGIN_SRC bash :tangle no
npm i -g json-fix
#+END_SRC

#+BEGIN_SRC elisp
(defun +json|autofix-buffer ()
  "Autofix json buffer"
  (interactive)
  (let ((b (if mark-active (min (point) (mark)) (point-min)))
        (e (if mark-active (max (point) (mark)) (point-max))))
    (shell-command-on-region b e
     (template "json-fix --no-sort --spaces <<tab-width>>") (current-buffer) t)))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map!
 :after json-mode
 :map json-mode-map
 :gni "<C-return>" #'+json|insert-key-below
 :gni "<C-S-return>" #'+json|insert-key-above)
#+END_SRC

*** LSP
**** Guess root

When working in nested git worktrees, lsp should infer the root by using projectile, by finding the closest ~.projectile~ file.
This file is always created when [[*Create worktree workspace][creating a worktree]].

#+begin_src elisp
(setq lsp-auto-guess-root t)
#+end_src

**** Disable presets

All are these are distracting and not helpful.

- Removes all popup UIs
- Remove signature message
- Remove lsp flycheck

#+BEGIN_SRC elisp
(setq lsp-eldoc-render-all nil
      lsp-eldoc-enable-hover nil
      lsp-eldoc-enable-signature-help nil
      lsp-eldoc-prefer-signature-help nil
      lsp-inhibit-message t

      lsp-eldoc-enable-hover nil
      ;; Disable Signature
      lsp-signature-auto-activate nil
      lsp-signature-render-documentation nil
      lsp-signature-doc-lines 1

      ;; Disable flycheck override
      lsp-diagnostic-package :none

      lsp-highlight-symbol-at-point nil
      ;; Disable make error highlighting
      lsp-prefer-flymake nil)

;; (setq-hook! 'js2-mode lsp-eldoc-enable-hover nil)

(setq lsp-on-idle-hook nil)
#+END_SRC

**** Fix flycheck for js buffers

LSP manually disables all checkers and chooses it's own.
This way you can't add checkers after your regular hooks like ~js2-hook~.
So I fix the checker manually for each mode after lsp was loaded.

#+BEGIN_SRC elisp
(after! lsp-mode
  (remove-hook 'lsp-mode-hook #'+lsp-init-flycheck-or-flymake-h))

(defun +js/fix-checker ()
  "Fix LSP overwritten checkers."
  (interactive)
  (when (-contains? '(js2-mode rjsx-mode) major-mode)
    (flycheck-select-checker 'javascript-eslint)))

(add-hook 'lsp-mode-hook #'+js/fix-checker)
#+END_SRC

*** Mail
**** Config
***** Accounts
****** Work

****** COMMENT Work

#+BEGIN_SRC elisp :tangle no
(setq smtpmail-default-smtp-server "smtp.gmail.com")
(setq smtpmail-smtp-service 587)
(setq smtpmail-debug-info t)
#+END_SRC

***** Bookmarks

#+BEGIN_SRC elisp :tangle no
(setq mu4e-bookmarks
  `(("flag:unread AND NOT flag:trashed AND NOT maildir:/Spam" "Unread messages"      ?u)
    ("date:today..now AND NOT maildir:/Spam"                  "Today's messages"     ?T)))
#+END_SRC

***** Disable Background Color

#+BEGIN_SRC elisp :tangle no
(setq shr-use-colors nil)
#+END_SRC

***** Shortcuts

#+BEGIN_SRC elisp :tangle no
(setq mu4e-maildir-shortcuts
      '(("/mailbox/work/INBOX"     . ?i)
        ("/mailbox/work/Sent Mail" . ?s)
        ("/mailbox/work/Trash"     . ?t)
        ("/mailbox/work/All Mail"  . ?a)))
#+END_SRC

***** Automatically apply Section without asking

#+BEGIN_SRC elisp :tangle no
(setq mu4e-headers-leave-behavior 'apply)
#+END_SRC

*** Magit / Git
**** Utils
***** Create worktree workspace

Creates a new git workspace from a branch.
Automatically adds ~.projectfile~ and opens a new doom workspace.

#+BEGIN_SRC elisp
(defun magit-worktree-branch-project-worktree (branch start-point &optional force)
  "Create a new BRANCH and check it out in a new worktree at PATH in a new workspace."
  (interactive
   `(,@(butlast (magit-branch-read-args "Create and checkout branch"))
     ,current-prefix-arg))
  (let* ((worktree-path (f-join (projectile-project-root) ".worktrees"))
         (path (f-join (projectile-project-root) ".worktrees" branch)))
    (when (not (f-exists-p worktree-path))
      (mkdir worktree-path t))
    (magit-run-git "worktree" "add" (if force "-B" "-b")
                   branch (expand-file-name path) start-point)
    (f-touch (f-join path ".projectile"))
    (+workspace-new branch)
    (+workspace-switch branch)
    (magit-diff-visit-directory path)
    (projectile-add-known-project path)
    path))
#+END_SRC

***** Revision show original file

Show the original file when visiting a revision buffer.
E.g.: When showing a diff from a commit, you may want to edit that file.

#+BEGIN_SRC elisp
(defun magit-revision-show-original-file ()
  "Show the orginal file from a revision buffer
If possible also go to the pointing line"
  (interactive)
  (when magit-buffer-file-name
    (let ((file-name magit-buffer-file-name)
          (line-number (line-number-at-pos)))
      (if current-prefix-arg
          (delete-other-windows))
      (find-file file-name)
      (goto-line line-number))))
#+END_SRC

***** Changed files in branch

Show a list of the changed files in the current branch.
For now only works on branches that were directly forked from master.

#+BEGIN_SRC elisp
(defun +git/new-files ()
  "List of added files in the current branch."
  (my::shell/command-to-list "git ls-files -om --exclude-standard"))

(defun +git/modfied-files (&optional branch)
  "Get a list of modified files from the BRANCH to head."
  (my::shell/command-to-list
   (template "git --no-pager diff --no-renames --name-only --no-merges <<(magit-rev-parse \"HEAD\")>> <<branch>>;")))

(defun +git/changed-branch-files (branch)
  "Get a list of new and modified files from BRANCH to head."
  (->> (+git/modfied-files branch)
       (-concat (+git/new-files))
       (-uniq)
       (-filter
        (lambda (x)
          (let ((default-directory (projectile-project-root)))
            (f-exists? x))))))

(defun +git|ivy-changed-files (&optional branch)
  (interactive)
  (let ((enable-recursive-minibuffers t))
    (ivy-read (template "Changed files for <<(or branch (magit-get-current-branch))>>:")
              (+git/changed-branch-files (or "origin/master"))
              :require-match t
              :history 'file-name-history
              :action counsel-projectile-find-file-action
              :caller '+git|ivy-changed-files)))
#+END_SRC
***** Undo commit

#+BEGIN_SRC elisp
(defun +git|undo ()
  "Soft reset current git repo to HEAD~1."
  (interactive)
  (magit-reset-soft "HEAD~1"))
#+END_SRC

***** Push dated remote branch

For work I need remote branches with a date prefix.

#+BEGIN_SRC elisp
(defun +git|push-dated (&optional branch)
  "Pushes the given the current BRANCH with a dated prefix
my-branch-name -> 19-01-my-branch-name
When no BRANCH is given, take the current one."
  (interactive)
  (let* ((branch (or branch (magit-get-current-branch)))
         (date (format-time-string "%y-%m"))
         (remote (template "origin/<<date>>-<<branch>>")))
    (magit-git-push branch remote "--set-upstream")
    remote))
#+END_SRC

***** Diff range from current branch to ~magit-thing-at-point~

When I'm on the log view, I want to quickly diff it against the currently checked out branch.
The transient shortcut for this is ~d R~ define [[*Transient][here]].

#+BEGIN_SRC elisp
(defun +magit|diff-range-from-current-branch ()
  "Ranged diff from the checked out branch to the commit at point."
  (interactive)
  (magit-diff-range (template "<<(magit-commit-at-point)>>..<<(magit-get-current-branch)>>")))
#+END_SRC

***** Diff range from current pull request

#+BEGIN_SRC elisp
(defun +magit|diff-range-from-pullreq ()
  "Ranged diff from the pull request under point."
  (interactive)
  (-some->> (forge-current-topic)
    (forge--pullreq-range)
    (magit-diff-range)))
#+END_SRC

***** Review branch

#+BEGIN_SRC elisp
(defun +magit|delete-review-branches ()
  "Delete all review branches that no longer have an upstream."
  (interactive)
  (->> (magit-list-branches)
       (--filter (s-starts-with? "refs/heads/REVIEW" it))
       (--map (magit-name-local-branch it))
       (--reject (magit-get-upstream-branch it))
       (--each (lambda (x) (magit-branch-delete x t)))))

(defun +magit|checkout-review-branch (&optional branch start-point)
  "Create a branch with review prefix for easy cleanup afterwards."
  (interactive)
  (let* ((remotes (magit-list-remote-branch-names))
         (atpoint (magit-branch-at-point))
         (branch (magit-completing-read
                  "Checkout branch" remotes
                  nil nil nil 'magit-revision-history
                  (or (car (member atpoint remotes))
                      (and atpoint
                           (car (member (and (string-match "[^/]+/" atpoint)
                                             (substring atpoint (match-end 0)))
                                        remotes))))))
         (review-branch-name (s-replace "origin/" "REVIEW-" branch)))
    ;; HACK Workaround where the buffer cant be read
    (advice-remove 'magit-checkout #'+magit-revert-repo-buffers-deferred-a)
    (magit-checkout branch)
    (when (magit-anything-modified-p)
      (user-error "Cannot checkout when there are uncommitted changes"))
    (if (-contains? (magit-list-local-branch-names) review-branch-name)
        (magit-branch-checkout review-branch-name)
      (magit-branch-and-checkout (s-replace "origin/" "REVIEW-" branch) branch))))
#+END_SRC
***** Cleanup branches

Cleans up all merged and review branches

#+BEGIN_SRC elisp
(defun +magit|cleanup-branches (&optional base-branch)
  "Remove all merged and review branches."
  (interactive)
  (+magit|delete-review-branches)
  (let* ((base-branch (or base-branch "master")))
    (call-interactively #'+magit|delete-review-branches)
    (deferred:$
      (deferred:process-shell (template "git branch --merged | egrep -v \"(^\\*|<<base-branch>>)\" | xargs git branch -d"))
      (deferred:nextc it
        (magit-status-maybe-update-revision-buffer)))))
#+END_SRC

***** Branches by user

#+BEGIN_SRC elisp
(defun +magit|branches-by-user (&optional ignore-review?)
  "List all branches by user.
Universal argument to ignore review branches."
  (interactive "P")
  (let ((branches
         (->>
          (concat "git for-each-ref"
                  " --sort=-committerdate"
                  " --format='%(committerdate) %(authorname) %(refname)'"
                  " --sort=-committerdate"
                  ;; refs/remotes/origin/ for remote branches
                  " refs/heads"
                  " | grep -e 'Florian Schroedl'")
          (shell-command-to-string)
          (s-split "\n")
          (-butlast)
          (-map (lambda (x) (->> (s-match ".*Florian Schroedl refs\\/heads\\/\\(.*\\)" x)
                                 (-last-item))))
          ((lambda (xs)
             (if ignore-review?
                 (--reject (s-starts-with? "REVIEW" it) xs)
               xs))))))
    (ivy-read "Checkout: " branches :action #'magit-checkout)))
#+END_SRC

***** Load forge when needed

#+BEGIN_SRC elisp
(use-package! forge
  :commands (forge-browse-commit))
#+END_SRC

***** Commit Template

Loads commit template from ~./git/TEMPLATE~ if the file exist.

#+BEGIN_SRC elisp
(defun +git/template-file (branch)
  (when-let* ((dir (+git/find-root-git-dir))
              (entries (f-entries dir (lambda (x) (s-starts-with? "TEMPLATE" (f-base x)))))
              (branch-template (template "TEMPLATE-<<branch>>")))
    (-log entries)
    (-log branch-template)
    (or
     (-find (lambda (x) (string= branch-template (f-base x))) entries)
     (-find (lambda (x) (string= "TEMPLATE" (f-base x))) entries))))

(defun +git/load-git-template (&rest discard)
  "When a TEMPLATE file in the git directory exists, insert it as a commit template."
  (when (eq (point) (point-at-eol))
    (-some->> (+git/template-file (magit-get-current-branch))
      (f-read)
      (s-trim)
      (s-append " ")
      (insert)))
  (evil-insert-state))
#+END_SRC

And the hook

#+BEGIN_SRC elisp
(add-hook! 'git-commit-setup-hook :append #'+git/load-git-template)
#+END_SRC

***** Find root directory

Find the root directory of a ~.git~ repository
This also works for worktrees that are in a nested directory.

#+BEGIN_SRC elisp
(defun +git/find-root-git-dir ()
  "Find the root directory of a repository."
    (-some->> (magit-toplevel)
      (-f-join ".git")
      (-id-when #'f-exists?)
      ((lambda (x)
         (if (f-file? x)
             (->> (magit-list-worktrees)
                  (car)
                  (car)
                  (-f-join ".git"))
           x)))))
#+END_SRC
***** Lock git buffer :ADVICE:

#+BEGIN_SRC elisp
(advice-add #'magit-toggle-buffer-lock :after (lambda () (my/bool-state-message 'magit-buffer-locked-p)))
#+END_SRC
***** Check for merge conflicts
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/501407/is-there-a-git-merge-dry-run-option][Is there a git-merge --dry-run option? - Stack Overflow]]
:END:

Try two merge two branches in memory, to determine if there would be merge conflicts.

#+BEGIN_SRC elisp
(defun +git|check-branch-for-merge-conflict (&optional source-branch target-branch)
  "Try to merge SOURCE-BRANCH into TARGET-BRANCH, return list of conflicting files when there are any.
This will try to merge in memory, so no index files will be created.
SOURCE-BRANCH defaults to the current branch.
TARGET-BRANCH defaults to origin/master."
  (interactive)
  (let* ((source-branch (or source-branch (magit-get-current-branch)))
         (target-branch (or target-branch "origin/master"))
         (merge-base (my::shell/command-to-list (t! "git merge-base <<target-branch>> <<source-branch>>"))))
    (my::shell/command-to-list (t! "git merge-tree <<(car merge-base)>> <<target-branch>> <<source-branch>>"))))
#+END_SRC
***** Copy over changes from diff

#+BEGIN_SRC elisp
(defun +magit/diff-copy-file-changes ()
  "Copies over contents of diff at point to the curent file system."
  (interactive)
  (save-excursion
    (let ((buffer (call-interactively #'magit-diff-visit-file)))
      (with-current-buffer buffer
        (make-directory (f-dirname magit-buffer-file-name) t)
        (f-write (substring-no-properties (buffer-string)) 'utf-8 magit-buffer-file-name)))
    (kill-buffer)))
#+END_SRC
***** Text Mode

Restores functionality when editing magit buffers as text.
For now only the toggle functionality is needed.

#+BEGIN_SRC elisp
(defvar +magit-evil-edit-mode-map (make-sparse-keymap))

(define-minor-mode +magit-evil-edit-mode ""
  :keymap +magit-evil-edit-mode-map)

(map! :map +magit-evil-edit-mode-map
      :n [tab] #'magit-section-toggle)
#+END_SRC

**** Config

#+BEGIN_SRC elisp
(after! magit
  :config
  (setq
   magit-save-repository-buffers 'dontask
   magithub-clone-default-directory "~/Code/Repositories"
   git-commit-summary-max-length 120))

(after! forge
  :config
  (setq forge-database-file (f-join doom-local-dir "forge-database.sqlite")))
#+END_SRC

**** Bindings
***** Diff Navigation

My workflow for navigating diffs
Use ~z1~ to fold all diffs to their file headers and press's ~{~ or ~}~ to

1. Refold all sections
2. Go to the next section
3. Unfold everything in the current section

Then use ~]~ to navigate the sections

#+BEGIN_SRC elisp
(defun floscr:magit-jumpunfold-section (&optional forward)
  "Fold all section. Go to next section when FORWARD. Show all children"
  (interactive)
  (magit-section-show-level-1-all)
  (call-interactively (if forward #'magit-section-forward-sibling #'magit-section-backward-sibling))
  (call-interactively #'magit-section-show-children))

(map!
 (:map magit-diff-mode-map
  :nv "}" (cmd! (floscr:magit-jumpunfold-section 't))
  :nv "{" (cmd! (floscr:magit-jumpunfold-section))))
#+END_SRC

***** Time Machine Navigation

#+BEGIN_SRC elisp
(map!
 :after git-timemachine
 :map git-timemachine-mode-map
 :n "[" #'git-timemachine-show-previous-revision
 :n "]" #'git-timemachine-show-next-revision
 :n "b" #'git-timemachine-blame)
#+END_SRC

***** Disable quit for locked buffers

Disable accidentally quitting magit buffers with ~q~ when the buffer is locked.

#+BEGIN_SRC elisp
(defun +magit/disable-locked-quit (orig-fn &rest args)
  (unless magit-buffer-locked-p
    (apply orig-fn args)))

(advice-add #'magit-mode-bury-buffer :around #'+magit/disable-locked-quit)
#+END_SRC

**** Transient Bindings

You can add flags or commands to the magit interface transient here.
To append something, just state the flag that you see in the transient popup as the 2nd argument.

#+BEGIN_SRC elisp
(after! magit
  (transient-append-suffix 'magit-log "-f" '("-0" "No merges" "--no-merges"))
  (transient-append-suffix 'magit-push "p" '("d" "dated" +git|push-dated))

  (transient-append-suffix 'magit-diff "d" '("R" "Diff range from current branch" +magit|diff-range-from-current-branch))
  (transient-append-suffix 'magit-diff "d" '("P" "Pullrequest Range" +magit|diff-range-from-pullreq))
  (transient-append-suffix 'magit-diff "d" '("f" "File" magit-diff-buffer-file))

  (transient-append-suffix 'magit-commit
    "-D" '("-D" "Override the author date" "--date=" transient-read-date))

  (transient-append-suffix 'magit-branch "l" '("R" "Create review branch" +magit|checkout-review-branch))
  (transient-append-suffix 'magit-branch "l" '("U" "My Branches" +magit|branches-by-user)))
#+END_SRC

*** Markdown

Always keep markdown centered, without line numbers.

#+BEGIN_SRC elisp
(use-package! markdown-mode
  :init
  (add-to-list 'auto-mode-alist '("\\.mdx\\'" . markdown-mode))
  (setq markdown-fontify-code-blocks-natively t)
  :config
  (add-hook! markdown-mode
    (hl-line-mode -1)
    (visual-line-mode)
    (visual-fill-column-mode)
    (outline-minor-mode)
    (setq visual-fill-column-width 90
          display-line-numbers nil)
    (setq line-spacing 2
          fill-column 80))

  (map! (:map markdown-mode-map
          :n "<"    #'markdown-promote
          :n ">"    #'markdown-demote)))
#+END_SRC
*** Open With

*** Nov (EPUB Reading Mode)

Adds EPUB reading mode
[[https://github.com/wasamasa/nov.el][wasamasa/nov.el: Major mode for reading EPUBs in Emacs]]

I want to keep the buffer centered, but let nov take care of breaking the text,
since this is much nicer then ~visual-line-mode~.

#+BEGIN_SRC elisp
(defun my-nov-config ()
  (setq line-spacing 5)
  (face-remap-add-relative 'variable-pitch :family "Liberation Serif" :height 1.4)
  (setq visual-fill-column-center-text t)
  (setq visual-fill-column-width (+ nov-text-width 25))
  (visual-fill-column-mode t))

(use-package! nov
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  (setq nov-text-width 75)
  (setq nov-save-place-file (f-join doom-local-dir "nov-places"))
  :config
  (progn
    (add-hook 'nov-mode-hook 'my-nov-config)))
#+END_SRC

The font can be installed via brew cask.

#+BEGIN_SRC bash :tangle no
brew tap homebrew/cask-fonts
brew cask install font-liberation-sans
#+END_SRC

*** NPM Mode
**** Add CI command

#+BEGIN_SRC elisp
(defun npm-mode-npm-ci ()
  "Run the 'npm install' command."
  (interactive)
  (npm-mode--exec-process "npm ci"))
#+END_SRC

*** Magit Smerge Mode
**** Fix Colors

#+BEGIN_SRC elisp
(after! smerge-mode
  :config
  ;; TODO This is broken after switching the theme but works for now
  ;; This fixes the smerge diff color is really bright an ugly
  (set-face-attribute 'smerge-refined-added nil :foreground nil :background nil))
#+END_SRC

**** Hydra
:PROPERTIES:
:SOURCE:   [[https://github.com/alphapapa/unpackaged.el#hydra][alphapapa/unpackaged.el: A collection of useful Emacs Lisp code that isn't substantial enough to be packaged]]
:END:

#+BEGIN_SRC elisp
(use-package smerge-mode
  :after hydra
  :config
  (defhydra unpackaged/smerge-hydra
    (:color pink :hint nil :post (smerge-auto-leave))
    "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
    ("n" smerge-next)
    ("p" smerge-prev)
    ("b" smerge-keep-base)
    ("u" smerge-keep-upper)
    ("l" smerge-keep-lower)
    ("a" smerge-keep-all)
    ("RET" smerge-keep-current)
    ("\C-m" smerge-keep-current)
    ("<" smerge-diff-base-upper)
    ("=" smerge-diff-upper-lower)
    (">" smerge-diff-base-lower)
    ("R" smerge-refine)
    ("E" smerge-ediff)
    ("C" smerge-combine-with-next)
    ("r" smerge-resolve)
    ("k" smerge-kill-current)
    ("ZZ" (lambda ()
            (interactive)
            (save-buffer)
            (bury-buffer))
     "Save and bury buffer" :color blue)
    ("q" nil "cancel" :color blue))
  :hook (magit-diff-visit-file . (lambda ()
                                   (when smerge-mode
                                     (flycheck-mode -1)
                                     (unpackaged/smerge-hydra/body)))))
#+END_SRC

*** Workspaces
**** Config
***** Always add buffers to current workspace

Doom per default adds buffers to the current workspace on ~find-file~.
I want buffers added whenever I visit a buffer.

#+BEGIN_SRC elisp
(after! persp-mode
  (defun +workspace*add-special-buffer ()
    (if-let* ((name (buffer-name))
              (add-buffer? (or
                            ;; Always add files to workspaces
                            (buffer-file-name)
                            ;; Add src buffer
                            (s-matches? "\\*Org Src.*" name))))
      (persp-add-buffer (current-buffer) (get-current-persp))))

  (add-hook 'doom-switch-buffer-hook #'+workspace*add-special-buffer))
#+END_SRC

**** Functions
***** Switch to workspace

Enhancement of the default ~+workspace/switch-to~.
This allows quick deletion of workspaces from ivy with ~CTRL + BACKSPACE~.

#+BEGIN_SRC elisp
(defvar counsel-workspace-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "C-<backspace>") #'+workspace/switch-to-delete-space)
    map))

(defun +workspace//switch-to-delete-space (workspace)
  (let* ((current-workspace-name (+workspace-current-name))
         (new-workspace-name
            (or (--first (string= current-workspace-name it) (+workspace-list-names)) "main")))
    (+workspace/delete workspace)
    (+workspace-switch new-workspace-name)
    (+workspace/my-switch-to)))

(defun +workspace/switch-to-delete-space ()
  (interactive)
  (ivy-set-action #'+workspace//switch-to-delete-space)
  (ivy-done))

(defun +workspace/my-switch-to ()
  (interactive)
  (ivy-read "Switch to workspace: "
            (+workspace-list-names)
            :keymap counsel-workspace-map
            :action #'+workspace/switch-to))
#+END_SRC

***** Close Other Workspaces

#+BEGIN_SRC elisp
(defun +workspace|close-others ()
  "Close all other workspaces."
  (interactive)
  (--> (+workspace-list-names)
       (--reject (string= (+workspace-current-name) it) it)
       (-each it #'+workspace-delete))) ;
#+END_SRC


***** Find file for workspace

Most of the time you create workspaces from a project.
But when the CWD has changed in that workspace, you would have to relocate to
the projects cwd to find a file.

#+BEGIN_SRC elisp
(defun +workspace/workspace-project-root (&optional arg)
  "Gets the root dir for the current workspace"
  (--find (s-match (concat (+workspace-current-name) "/$") it) projectile-known-projects))

(defun +workspace|find-workspace-project-file ()
  "Projectile find file for the project named after the current workspace."
  (interactive)
  (cl-letf (((symbol-function 'projectile-project-root) #'+workspace/workspace-project-root))
    (projectile-find-file)))

(defun +workspace|workspace-project-vc ()
  "Projectile find file for the project named after the current workspace."
  (interactive)
  (let ((default-directory
          (or (+workspace/workspace-project-root)
              (my::file/project-root))))
    (magit-status)))
#+END_SRC

***** New named workspace

#+BEGIN_SRC elisp
(defun +workspace/new-named ()
  "Create a new named workspace."
  (interactive)
  (let ((name (read-string "New workspace name: ")))
    (if name (+workspace/new name))))
#+END_SRC

***** Cleanup Workspace

#+BEGIN_SRC elisp
(defun +workspace/remove-other-buffers (&optional keep-alive?)
  "Kill or remove all other buffers from current workspace."
  (interactive)
  (--> (+workspace-buffer-list)
       (--reject (eq (current-buffer) it) it)
       (if keep-alive?
           (persp-remove-buffer it)
         (kill-buffer it))))

(defun +workspace|hide-other-buffers ()
  "Hide all inactive buffers from the current workspace."
  (interactive)
  (+workspace/remove-other-buffers t))

(defun +workspace|kill-other-buffers ()
  "Kill all interactive buffers from the current workspace."
  (interactive)
  (+workspace/remove-other-buffers))

(defun +workspace|hide-non-project-buffers ()
  "Hide all file buffers that don't belong to the project workspace."
  (interactive)
  (let ((project-path (or (expand-file-name (+workspace/workspace-project-root))
                          (projectile-project-root))))
    (-some--> (+workspace-buffer-list)
         ;; Dont remove non-remove buffers
         (--filter (buffer-file-name it) it)
         (--reject (s-contains? project-path (buffer-file-name it)) it)
         (--each (persp-remove-buffer it) it))))
#+END_SRC

*** Grep Modes
**** Bindings

#+BEGIN_SRC elisp
(map!
 :map (wgrep-mode-map ivy-occur-grep-mode-map)
 :n [return] #'compile-goto-error

 :localleader
 :desc "Remove line" "d" (cmd! (let ((inhibit-read-only t))
                                 (my::buffer/delete-current-line))))
#+END_SRC

*** Yasnippet
**** Utils
***** Expand snippet by name
:PROPERTIES:
:SOURCE:   [[https://stackoverflow.com/questions/10211730/insert-yasnippet-by-name][emacs - Insert yasnippet by name - Stack Overflow]]
:END:

#+BEGIN_SRC elisp
(defun yas/insert-by-name (name)
  (require 'noflet)
  (noflet ((dummy-prompt
            (prompt choices &optional display-fn)
            (declare (ignore prompt))
            (or (cl-find name choices :key display-fn :test #'string=)
                (throw 'notfound nil))))
    (let ((yas-prompt-functions '(dummy-prompt)))
      (catch 'notfound
        (yas-insert-snippet t)))))
#+END_SRC

***** Use last src language
:PROPERTIES:
:SOURCE:   [[https://github.com/tecosaur/emacs-config/blob/0c50e2a651e8903a922a60acf701d4a6ba0e1d29/config.org][emacs-config/config.org at 0c50e2a651e8903a922a60acf701d4a6ba0e1d29 · tecosaur/emacs-config]]
:END:

Used with [[file:snippets/org-mode/src::`%`$0][src snippet]] to auto fill the language from the previously used src language.

#+BEGIN_SRC elisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at point.
Return nil otherwise."
  (save-excursion
    (pcase
        (downcase
         (buffer-substring-no-properties
          (goto-char (line-beginning-position))
          (or (ignore-errors (1- (search-forward " " (line-end-position))))
              (1+ (point)))))
      ("#+property:"
       (when (re-search-forward "header-args:")
         (buffer-substring-no-properties
          (point)
          (or (and (forward-symbol 1) (point))
              (1+ (point))))))
      ("#+begin_src"
       (buffer-substring-no-properties
        (point)
        (or (and (forward-symbol 1) (point))
            (1+ (point)))))
      ("#+header:"
       (search-forward "#+begin_src")
       (+yas/org-src-lang))
      (_ nil))))

(defun +yas/org-last-src-lang ()
  (save-excursion
    (beginning-of-line)
    (when (search-backward "#+begin_src" nil t)
      (+yas/org-src-lang))))
#+END_SRC

**** Load custom snippets

#+BEGIN_SRC elisp
(use-package! yasnippet
  :init
  (require 'doom-snippets nil t))
#+END_SRC

*** Babel Async

#+BEGIN_SRC elisp
(use-package! ob-async
  :after org-babel)
#+END_SRC

*** Process List / Proced
**** Config
***** Proced Narrow

#+BEGIN_SRC elisp
(use-package! proced-narrow
  :after proced
  :config
  (map!
   :map proced-mode-map
   :n "/" #'proced-narrow))
#+END_SRC

***** Shorten nixos path names in proced

Nixos paths can be very long, which is distracting in proced.
This shortens the nixos paths to ~{nix}~.

#+BEGIN_SRC elisp
(defun +proced/remove-nixos-path-name (oldformat &rest xs)
  (let ((xs (--map (->> it
                        (s-replace-regexp "/nix/store/[^/]+" "{nix}")
                        (s-replace-regexp (template "^/home/<<(user-login-name)>>") "~")
                        ((lambda (x) (if (s-contains? "chromium" x) "{chromium}" x))))
                  xs)))
    (apply oldformat xs)))

(advice-add #'proced-format-args :around #'+proced/remove-nixos-path-name)
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map! :map process-menu-mode-map
      :n "gr" #'list-processes)
(map! :map proced-mode-map
      :n "gr" #'proced)
#+END_SRC
*** NixOs

**** Edit indirect

Edit nix script regions in an indirect buffer just like ~org-edit-special~.

#+BEGIN_SRC elisp
(defun +nix|edit-indirect ()
  "Edit script in an indirect buffer."
  (interactive)
  (and-let* ((beg (save-excursion
                    (search-backward "''\n" nil t)
                    (forward-char 3)
                    (point)))
             (end (save-excursion
                    (re-search-forward "''" nil t)
                    (previous-line 1)
                    (goto-char (point-at-eol))
                    (point))))
    (+indirect-indent|edit beg end #'sh-mode)))

(map! :map nix-mode-map "C-c '" '+nix|edit-indirect)

(set-popup-rule! "^\\*edit-indirect" :ignore t)
#+END_SRC

** Bindings
*** General

#+BEGIN_SRC elisp
(map! :g "C-±" #'+popup/raise)
#+END_SRC

**** Disable emacs-state-toggle

#+BEGIN_SRC elisp
(map! :nm "C-z" nil)
#+END_SRC
**** Auto indent bracket openings
:PROPERTIES:
:SOURCE:   [[https://xenodium.com/emacs-smartparens-auto-indent/][Emacs smartparens auto-indent]]
:END:

Automatically indent and format when opening area betwen to delimiters.

#+begin_src elisp
(defun indent-between-pair (&rest _ignored)
  (newline)
  (indent-according-to-mode)
  (forward-line -1)
  (indent-according-to-mode))

(sp-local-pair 'prog-mode "{" nil :post-handlers '((indent-between-pair "RET")))
(sp-local-pair 'prog-mode "[" nil :post-handlers '((indent-between-pair "RET")))
(sp-local-pair 'prog-mode "(" nil :post-handlers '((indent-between-pair "RET")))
#+end_src

*** Super

#+BEGIN_SRC elisp
(map!
 (:map override
   :g "s-n" #'evil-buffer-new
   :g "s-;" #'eval-expression
   :g "s-a" #'mark-whole-buffer
   :g "s-s" #'save-buffer
   :g "s-v" #'yank
   :g "s-x" #'execute-extended-command
   :g "s-y" #'helm-show-kill-ring

   ;; Text scale
   :g "s-="   #'doom/increase-font-size
   :g "s--"   #'doom/decrease-font-size
   :g "s-0"   #'doom/reset-font-size))
#+END_SRC

*** Evil
**** Config
***** Use global ex by default

I almost always want global search and replace, doom changed this in [[orgit-rev:~/.emacs.d/::1a6f5086400d164178016784aac12114934c8245][1a6f50864]].
To undo this behavior just add =g= flag

#+BEGIN_SRC elisp
(setq evil-ex-substitute-global t)
#+END_SRC

**** Motions
***** Additional text objects

- =q= for any type of quote
- =B= for curly braces
- =r= for square brackets

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "`")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "`")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket)
  (define-key evil-inner-text-objects-map "B" 'evil-inner-curly))
#+END_SRC

***** Up to next/previous indent

Text objects for lines after or before the current line,
that have the same or deeper indent.

#+BEGIN_SRC elisp
(defun evil-indent-plus--line-down-indent-range (&optional point)
  (require 'evil-indent-plus)
  (let* ((range (evil-indent-plus--same-indent-range point))
         (base (point))
         (begin (point)))
    (list begin (cl-second range) base)))

(evil-define-text-object evil-indent-plus-i-indent-line-down (&optional count beg end type)
  "Text object describing the block with the same (or greater) indentation as the current line,
and the line above, skipping empty lines."
  :type line
  (require 'evil-indent-plus)
  (evil-indent-plus--linify (evil-indent-plus--line-down-indent-range)))

(define-key evil-inner-text-objects-map "+" 'evil-indent-plus-i-indent-line-down)

(defun evil-indent-plus--line-up-indent-range (&optional point)
  (require 'evil-indent-plus)
  (let* ((range (evil-indent-plus--same-indent-range point))
         (base (point))
         (begin (point)))
    (list begin (cl-first range) base)))

(evil-define-text-object evil-indent-plus-i-indent-line-up (&optional count beg end type)
  "Text object describing the block with the same (or greater) indentation as the current line,
and the line above, skipping empty lines."
  :type line
  (require 'evil-indent-plus)
  (evil-indent-plus--linify (evil-indent-plus--line-up-indent-range)))

(define-key evil-inner-text-objects-map "-" 'evil-indent-plus-i-indent-line-up)
#+END_SRC

***** Little Word Motion

#+BEGIN_SRC elisp
(defun load-evil-camel-case-motion ()
  (require 'evil-little-word)
  (define-key evil-normal-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-normal-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-operator-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-w") 'evil-forward-little-word-begin)
  (define-key evil-visual-state-map (kbd "M-b") 'evil-backward-little-word-begin)
  (define-key evil-visual-state-map (kbd "i M-w") 'evil-inner-little-word))

(load-evil-camel-case-motion)
#+END_SRC
***** Sort Motion

#+BEGIN_SRC elisp
(evil-define-operator +evil/sort (beg end)
  "Sort lines with motion"
  (interactive "<r>")
  (sort-lines nil beg end))

(map!
 (:after evil
    :m "gS" #'+evil/sort))
#+END_SRC

***** Case Conversion

Copied code from [[https://github.com/strickinato/evil-briefcase][strickinato/evil-briefcase]] since it's not maintained anymore.
Convert case motion via ~Z~.

Example pressing ~ZciW~ would convert the inner =Word= into =camelCase=

#+BEGIN_SRC elisp
(evil-define-operator +evil/case-upper (beg end type)
  "Convert text to upper case."
  (if (eq type 'block)
      (evil-apply-on-block #'s-upcase beg end nil)
    (let ((str (s-upcase (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-lower (beg end type)
  "Convert text to lowercase."
  (if (eq type 'block)
      (evil-apply-on-block #'s-downcase beg end nil)
    (let ((str (s-downcase (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-camel-upper (beg end type)
  "Convert text to CamelCase with a Capital C"
  (if (eq type 'block)
      (evil-apply-on-block #'s-upper-camel-case beg end nil)
    (let ((str (s-upper-camel-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-camel-lower (beg end type)
  "Convert text to camelCase with a small C"
  (if (eq type 'block)
      (evil-apply-on-block #'s-lower-camel-case beg end nil)
    (let ((str (s-lower-camel-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-snake-lower (beg end type)
  "Convert text to snake_case, slithering"
  (if (eq type 'block)
      (evil-apply-on-block #'s-snake-case beg end nil)
    (let ((str (s-snake-case (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-snake-upper (beg end type)
  "Convert text to SNAKE_CASE, AKA SCREAMING_SNAKE_CASE"
  (if (eq type 'block)
      (evil-apply-on-block #'s-snake-case beg end nil)
    (let ((str (s-upcase (s-snake-case (buffer-substring-no-properties beg end)))))
      (delete-region beg end)
      (insert str))))

(evil-define-operator +evil/case-kebab-upper (beg end type)
  "Convert text to KEBAB-KASE, mmmm... THICK MEAT"
  (if (eq type 'block)
      (evil-apply-on-block #'s-dashed-words beg end nil)
    (let ((str (s-dashed-words (buffer-substring-no-properties beg end))))
      (delete-region beg end)
      (insert (upcase str)))))

(evil-define-operator +evil/case-kebab-lower (beg end type)
  "Convert text to kebab-kase, mmmm... hyphens"
  (if (eq type 'block)
      (evil-apply-on-block #'s-dashed-words beg end nil)
    (let ((str (s-dashed-words (buffer-substring-no-properties beg end))))
        (delete-region beg end)
        (insert str))))

(map!
 (:after evil
  :m "Zu" #'+evil/case-upper
  :m "Zl" #'+evil/case-lower
  :m "ZC" #'+evil/case-camel-upper
  :m "Zc" #'+evil/case-camel-lower
  :m "ZS" #'+evil/case-snake-upper
  :m "Zs" #'+evil/case-snake-lower
  :m "ZK" #'+evil/case-kebab-upper
  :m "Zk" #'+evil/case-kebab-lower))
#+END_SRC

***** Org Src Block

Matches any block with ~BEGIN_~, e.g.: SRC blocks.

#+BEGIN_SRC elisp
(defun +evil-org/src-block ()
  "Matches src blocks using org-element-context."
  (-when-let* ((ctx (org-element-context))
               (type (car ctx))
               (ctx (cond
                     ((equal type 'src-block) ctx)
                     ((equal type 'example-block) ctx)
                     ((equal type 'quote-block) ctx)
                     ;; Inside quote blocks org-element-context matches the paragraphs
                     ;; So we have to take the parent block to get the quote-block
                     ((equal type 'paragraph)
                      (-some->> ctx
                        (nth 1)
                        ((lambda (x) (doom-plist-get x :parent)))
                        (--id-when (equal (car it) 'quote-block)))))))
    ctx))

(evil-define-text-object +evil-org-inner-src-block (count &optional beg end type)
  "Select an org src/quote/example block object."
  (evil-org-select-inner-element (+evil-org/src-block)))

(evil-define-text-object +evil-org-an-src-block (count beg end type)
  "An org object.
Matches urls and table cells."
  (evil-org-select-an-element (+evil-org/src-block)))

(after! evil-org
  (evil-define-key '(visual operator) evil-org-mode-map
    "ib" #'+evil-org-inner-src-block
    "ab" #'+evil-org-an-src-block))
#+END_SRC

**** Normal Bindings
***** Window navigation

Fix window navigation for various modes.
I don't like pressing ~C-w~ or ~SPC w~ as leader to navigate,
so I have to work around it:

#+BEGIN_SRC elisp
(map!
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)

(map!
 :map (image-mode-map
       magit-diff-mode-map
       magit-revision-mode-map
       magit-status-mode-map
       eshell-mode-map
       evil-org-mode-map)
 :en "C-h"   #'evil-window-left
 :en "C-j"   #'evil-window-down
 :en "C-k"   #'evil-window-up
 :en "C-l"   #'evil-window-right)

(add-hook! 'eshell-first-time-mode-hook
  (map!
   :map eshell-mode-map
   :en "C-h"   #'evil-window-left
   :en "C-j"   #'evil-window-down
   :en "C-k"   #'evil-window-up
   :en "C-l"   #'evil-window-right))

(map!
 :map org-agenda-mode-map
 "C-h"  #'evil-window-left
 "C-j"  #'evil-window-down
 "C-k"  #'evil-window-up
 "C-l"  #'evil-window-right)
#+END_SRC

***** History navigation in minibuffer

#+BEGIN_SRC elisp
(define-key minibuffer-local-map "\C-p" 'previous-history-element)
(define-key minibuffer-local-map "\C-n" 'next-history-element)
#+END_SRC

***** Jump to last buffer

#+BEGIN_SRC elisp
(map! :n "gb" #'evil-switch-to-windows-last-buffer)
#+END_SRC

***** Select last paste
:PROPERTIES:
:SOURCE:   https://emacs.stackexchange.com/a/21093
:END:

#+BEGIN_SRC elisp
(defun +evil|select-pasted ()
  (interactive)
  (let ((start-marker (evil-get-marker ?\[))
        (end-marker (evil-get-marker ?\])))
    (evil-visual-select start-marker end-marker)))

(map! :n "gp" #'+evil|select-pasted)
#+END_SRC

***** Go up one directory from the current buffer

#+BEGIN_SRC elisp
(map! :m "-"  #'dired-jump)
#+END_SRC

***** Visual Line Mode Navigation

#+BEGIN_SRC elisp
(map! :map visual-line-mode-map
      :nv "j" #'evil-next-visual-line
      :nv "k" #'evil-previous-visual-line)
#+END_SRC

**** Insert Bindings

Insert Mode bindings, mostly unicode insertion and workaround for german umlaut.

***** Insert from the kill ring in insert mode

#+BEGIN_SRC elisp
(map! :i "A-y" #'helm-show-kill-ring)
#+END_SRC

***** Unicode Characters

#+BEGIN_SRC elisp
(map!
 :i "C-y"   #'helm-show-kill-ring
 :i "M-`"   (cmd! (insert "°"))
 :i "M-."   (cmd! (insert "…"))
 :i "M-^"   (cmd! (insert "°"))
 :i "M-l"   (cmd! (insert "λ"))
 :i "M-w"   (cmd! (insert "⚠"))
 :i "M-i"   (cmd! (insert "ℹ")))
#+END_SRC

**** Square Bracket Bindings

Global ~[~ & ~]~ combinator bindings

***** Dumb Jump

#+BEGIN_SRC elisp
(map!
 :n "]F" #'dumb-jump-go
 :n "[F" #'dumb-jump-back)
#+END_SRC

***** Flycheck Error Jumping

#+BEGIN_SRC elisp
(map!
 :n "]e" #'flycheck-next-error
 :n "[e" #'flycheck-previous-error)
#+END_SRC
***** Projectile Alternate file finding

#+BEGIN_SRC elisp
(map!
 :n "]1" #'projectile-toggle-between-implementation-and-test
 :n "[1" #'projectile-toggle-between-implementation-and-test)
#+END_SRC

**** Text Objects

Custom evil text objects mostly stolen from [[https://github.com/jerryxgh/lambda-x/blob/master/lambda-evil.el#L236][Spacemacs|define-text-object-regexp]].

***** Utils
****** Define Text Objects

#+BEGIN_SRC elisp
(defmacro +evil/define-text-object-regexp (key name start-regexp end-regexp)
  "Define a text object.
START-REGEXP and END-REGEXP are the boundaries of the text object."
  (let ((inner-name (make-symbol (concat "evil-inner-" name)))
        (outer-name (make-symbol (concat "evil-outer-" name))))
    `(progn
       (evil-define-text-object ,inner-name (count &optional beg end type)
         (evil-select-paren ,start-regexp ,end-regexp beg end type count nil))
       (evil-define-text-object ,outer-name (count &optional beg end type)
         (evil-select-paren ,start-regexp ,end-regexp beg end type count t))
       (define-key evil-inner-text-objects-map ,key (quote ,inner-name))
       (define-key evil-outer-text-objects-map ,key (quote ,outer-name)))))
#+END_SRC
***** Config

#+BEGIN_SRC elisp
(+evil/define-text-object-regexp "~" "tilde" "~" "~")
(+evil/define-text-object-regexp "=" "equal" "=" "=")
(+evil/define-text-object-regexp "|" "bar" "|" "|")
(+evil/define-text-object-regexp "*" "star" "*" "*")
(+evil/define-text-object-regexp "$" "dollar" "$" "$")
(+evil/define-text-object-regexp "%" "percent" "%" "%")
(+evil/define-text-object-regexp "/" "slash" "/" "/")
(+evil/define-text-object-regexp "_" "underscore" "_" "_")
(+evil/define-text-object-regexp "-" "hyphen" "-" "-")
#+END_SRC

***** Quotes Text Object

Changes the text matching inside quotes with ~q~ motion (e.g. ~ciq~)
Change inner bracket with ~r~

#+BEGIN_SRC elisp
(after! evil
  (require 'evil-textobj-anyblock)
  (evil-define-text-object my-evil-textobj-anyblock-inner-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count nil)))

  (evil-define-text-object my-evil-textobj-anyblock-a-quote
    (count &optional beg end type)
    "Select the closest outer quote."
    (let ((evil-textobj-anyblock-blocks
           '(("'" . "'")
             ("\"" . "\"")
             ("`" . "'")
             ("“" . "”"))))
      (evil-textobj-anyblock--make-textobj beg end type count t)))

  (define-key evil-inner-text-objects-map "q" 'my-evil-textobj-anyblock-inner-quote)
  (define-key evil-outer-text-objects-map "q" 'my-evil-textobj-anyblock-a-quote)
  (define-key evil-inner-text-objects-map "r" 'evil-inner-bracket))
#+END_SRC
**** Ex Commands

Extend the default evil ex commands from [[file:~/.emacs.d/modules/editor/evil/+commands.el::;;; editor/evil/+commands.el -*- lexical-binding: t; -*-][+commands.el]]

#+BEGIN_SRC elisp
(after! evil-ex
  :config
  (evil-ex-define-cmd "W" #'evil-write))
#+END_SRC

**** MultiEdit

#+BEGIN_SRC elisp
(map! :nv "C-M-d" #'evil-multiedit-match-all)
#+END_SRC

**** Jump with =tab=

#+BEGIN_SRC elisp
(map! :n [tab] (general-predicate-dispatch nil
                 (and (featurep! :editor fold)
                      (save-excursion (end-of-line) (invisible-p (point))))
                 #'+fold/toggle
                 (fboundp 'evil-jump-item)
                 #'evil-jump-item)
      :v [tab] (general-predicate-dispatch nil
                 (and (bound-and-true-p yas-minor-mode)
                      (or (eq evil-visual-selection 'line)
                          (not (memq (char-after) (list ?\( ?\[ ?\{ ?\} ?\] ?\))))))
                 #'yas-insert-snippet
                 (fboundp 'evil-jump-item)
                 #'evil-jump-item))
#+END_SRC
**** TODO Paste Fix

Evil pastes at the current cursor, which I don't expect it to do.
Most of the time it requires me to move into insert mode, move one character,
and then do my function.

#+BEGIN_SRC elisp
(defun +evil/normal-mode-paste-fix (fn &optional insert-char)
  "Move forward one character and then paste."
  (interactive)
  (if (and (evil-normal-state-p)
           (my::buffer/line-contains "[^\s]"))
      (progn
        (forward-char 1)
        (when (and insert-char (looking-at insert-char))
          (insert insert-char))
        (let ((line (substring-no-properties (thing-at-point 'line))))
          (call-interactively fn)
          (when (eq line (substring-no-properties (thing-at-point 'line)))
            (delete-char 1))))
    (call-interactively fn)))
#+END_SRC

**** TODO Store all yanks in extra register

#+begin_src elisp :tangle no
(defvar +evil:last-yank nil)

(defun +evil/save-to-yank-register (&rest _rest)
  "Save the last yank to a specific register that only gets overwritten by yanks.
So deletes wont affect this register."
  (setq +evil:last-yank (evil-get-register ?\")))

(defun +evil/insert-from-yank-register ()
  "Save the last yank to a specific register that only gets overwritten by yanks.
So deletes wont affect this register."
  (-some->> +evil:last-yank
    (insert)))

;; (advice-add 'evil-yank :after #'+evil/save-to-yank-register)
#+end_src

*** Leader

#+BEGIN_SRC elisp
(map!
 :leader
 "RET"  #'+bookmarks|main
 "'"  #'+popup/toggle
 "au" #'undo-tree-visualize
 "-"  #'quick-calc)
#+END_SRC

**** Buffer

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("b" . "buffer")
  :desc "Rename Buffer"  "r" #'rename-buffer
  :desc "Rename Buffer"  "+" #'persp-add-buffer))
#+END_SRC

**** File / Goto

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("f" . "file")
  :desc "Open Private Config" "P" (cmd! (find-file (f-join doom-private-dir "config.org")))
  (:prefix-map ("g" . "goto")
   :desc "Drive"                 "/" #'+ivy|counsel-mounted-drives
   :desc "Desktop"               "D" (cmd! (find-file "~/Desktop"))
   :desc "Config"                "." (cmd! (find-file "~/.config"))
   :desc "Code"                  "c" (cmd! (find-file "~/Code"))
   :desc "Last captured"         "C" (cmd! (org-goto-marker-or-bmk org-capture-last-stored-marker))
   :desc "Downloads"             "d" (cmd! (find-file "~/Downloads"))
   :desc "Elfeed"                "e" (cmd! (find-file (car rmh-elfeed-org-files)))
   :desc "Media"                 "m" (cmd! (find-file "~/Media"))
   :desc "Music"                 "M" (cmd! (find-file "~/Media/Music"))
   :desc "Notes"                 "n" (cmd! (find-file org-directory))
   :desc "Project Root"          "p" (cmd! (find-file (projectile-project-root)))
   :desc "Last refiled"          "r" (cmd! (org-refile-goto-last-stored))
   :desc "Tmp"                   "t" (cmd! (find-file "/tmp"))
   :desc "Home"                  "h" (cmd! (find-file "~"))
   :desc "Run (Mounted Drives)"  "r" #'my::dired|find-mounted-drive)))
#+END_SRC

**** Git

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("g" . "git")
  :desc "Amend Commit (No Message)"           "A" (cmd! (magit-commit-amend "--no-edit"))
  :desc "Blame"                               "B" #'magit-blame
  :desc "Changed Files"                       "F" #'+git|ivy-changed-files
  :desc "New Branch"                          "N" #'magit-branch-spinoff
  :desc "Show revision original File"         "O" #'magit-revision-show-original-file
  :desc "Map-editor Changed Files"            "T" (cmd! (+git|ivy-changed-files "map-editor"))
  :desc "Amend Commit"                        "a" #'magit-commit-amend
  :desc "Checkout"                            "b" #'magit-checkout
  :desc "Diff"                                "d" #'magit-diff
  :desc "Push"                                "p" #'magit-push
  :desc "Undo"                                "u" #'+git|undo
  :desc "Worktree Popup"                      "w" #'magit-worktree
  :desc "New Org Pr"                          "!" #'+MM|new-pr-from-branch
  (:prefix ("f" . "file")
   :desc "VC file"                            "F" #'vc-revision-other-window)
  (:prefix ("l" . "list")
   :desc "List gists"                         "g" #'+gist:list
   :desc "List submodules"                    "n" #'magit-list-submodules
   :desc "List issues"                        "p" #'forge-list-issues
   :desc "List pull requests"                 "r" #'forge-list-pullreqs
   :desc "List pull awaiting review requests" "R" #'forge-list-requested-reviews
   :desc "List notifications"                 "s" #'forge-list-notifications)))
#+END_SRC

**** Insert

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("i" . "insert")
   :desc "New Snippet"    "S" #'+snippets/new
   :desc "Killring"       "y" #'helm-show-kill-ring))
#+END_SRC

**** Open

#+BEGIN_SRC elisp
(map!
 :leader
 (:desc "open" :prefix "o"
   :desc "Calc"            :g "c" #'calc
   :desc "Calc"            :g "C" #'=calendar
   :desc "Elfeed"          :g "e" #'+eshell/toggle
   :desc "Eshell"          :g "E" #'+rss|open
   :desc "Irc"             :g "i" #'=irc
   :desc "Mail"            :g "m" #'=mu4e
   :desc "Proced"          :g "p" #'proced
   :desc "Snippet"         :g "s" #'+snippets/edit
   :desc "Flycheck Errors" :g "$" #'flycheck-list-errors))
#+END_SRC

**** Projects

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("p" . "project")
  :desc "Workspace Project Files" "P" #'+workspace|find-workspace-project-file
  :desc "Project VC"              "v" #'+workspace|workspace-project-vc
  :desc "Project Bookmarks"       "RET" #'+bookmarks))
#+END_SRC

**** Search

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("s" . "search")
  :desc "Project for symbol" "P" #'+default/search-project-for-symbol-at-point
  :desc "Occur" "o" #'occur
  :desc "Web Lookup" "w" #'+lookup/online
  :desc "Web Lookup with prompt" "W" #'+lookup/online-select))
#+END_SRC

**** Toggle

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("t" . "toggle")
   :desc "Theme Dark/Light" "t" #'+doom|toggle-theme
   :desc "Auto Completion" "c" #'+company/toggle-auto-completion))
#+END_SRC

**** Window

#+BEGIN_SRC elisp
(map!
 :leader
 :desc  "Split Vertical"        "|"    #'evil-window-vsplit
 :desc  "Split Horizontal"      "-"    #'evil-window-split

 (:prefix-map ("w" . "window")
  :desc  "Delete"               "d"    #'delete-window
  :desc  "Ace Delete Windo"     "D"    #'ace-delete-window
  :desc  "New"                  "n"    #'evil-window-new

  :desc  "Undo"                 "u"    #'winner-undo
  :desc  "Redo"                 "r"    #'winner-redo
  :desc  "Enlargen"             "o"    #'doom/window-enlargen

  :desc  "Toggle Split"         "T"    #'+window|toggle-split-direction

  :desc  "Split Vertical"       "|"    #'evil-window-vsplit
  :desc  "Split Horizontal"     "_"    #'evil-window-split

  :desc  "Move Left"            "H"    #'+evil/window-move-left
  :desc  "Move Down"            "U"    #'+evil/window-move-down
  :desc  "Move Up"              "K"    #'+evil/window-move-up
  :desc  "Move Right"           "L"    #'+evil/window-move-right

  :desc  "Set Height"           "C-_"  #'evil-window-set-height
  :desc  "Set Height"           "C-|"  #'evil-window-set-width

  :desc  "Swap"                 "SPC"  #'ace-swap-window
  :desc  "Toggle Locked"        "#"    #'my|toggle-window-dedicated
  :desc "Toggle Locked"         "."    #'+popup/raise))
#+END_SRC

**** Workspace

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("TAB" . "workspace")
  :desc "Switch to"     "." #'+workspace/my-switch-to
  :desc "Close others"  "o" #'+workspace|close-others
  :desc "Create"        "c" #'+workspace/new-named
  :desc "Rename"        "," #'+workspace/rename
  :desc "Project Files" "p" #'+workspace|find-workspace-project-file
  :desc "Project VC"    "v" #'+workspace|workspace-project-vc
  :desc "Clone"         "C" (cmd!
                             (+workspace/new (format "Clone: %s" (+workspace-current-name)) t)
                             (message "Cloned current workspace %s" (+workspace-current-name)))
  :desc "Switch to last workspace" "0"   #'+workspace/other))
#+END_SRC

**** Yank

#+BEGIN_SRC elisp
(defun +yank/execute-action (x &optional insert)
  "Copy the the yank or insert it during insert mode."
  (interactive)
  (cond
   ((or (evil-insert-state-p) insert) (insert x))
   (t (my/kill-and-message x)))
  x)

(defun +yank/dired-path ()
  "Returns the current dired entry or the buffer directory."
  (or (dired-file-name-at-point) dired-directory))

(defun +yank/buffer-filename ()
  "Returns the current buffers file name if possible."
  (cond ((doom-dired-buffer-p (current-buffer)) (+yank/dired-path))
        (buffer-file-name buffer-file-name)
        (org-src-source-file-name org-src-source-file-name)
        (t nil)))

(defun +yank/buffer-path ()
  "Returns the current buffers path."
  (or (+yank/buffer-filename) default-directory))

(defun +yank|filename (&optional insert)
  "Yank the buffer file name."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-filename)
     ;; When pointing at a directory at dired, I still take the directory
     ((lambda (x) (if (f-file? x)
                      (file-name-directory x)
                    x)))
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|base (&optional insert)
  "Yank the buffer files base name."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-filename)
     (file-name-base)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|directory (&optional insert)
  "Yank the buffer files directory."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     (file-name-directory)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|path (&optional insert)
  "Yank the buffer files path."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(defun +yank|relative-to-project (&optional insert)
  "Yank the buffer path relative to the projectile-project-root."
  (interactive "P")
  (or
   (-some->> (+yank/buffer-path)
     (f-full)
     ((lambda (x)
        (or
         (->> (s-replace (projectile-project-root) "" x)
              (-id-when #'s-present?))
         x)))
     ((lambda (x) (+yank/execute-action x insert))))
   (user-error "Error: Not a file bufer!")))

(map!
 :leader
 (:prefix-map ("y" . "Yank")
  :desc "filename"            "f" #'+yank|filename
  :desc "base"                "b" #'+yank|base
  :desc "directory"           "d" #'+yank|directory
  :desc "path"                "p" #'+yank|path
  :desc "path"                "y" #'+yank|path
  :desc "relative to project" "r" #'+yank|relative-to-project))
#+END_SRC

*** Local-Leader
**** Eshell

#+BEGIN_SRC elisp
(defun floscr|+eshell|init-keymap ()
  "Setup additional custom eshell keybindings to already existing doom bindings. This must be done in a hook because eshell-mode
redefines its keys every time `eshell-mode' is enabled."
  (map! :map eshell-mode-map
        :in "C-p"         #'eshell-previous-input
        :in "C-n"         #'eshell-next-input

        :localleader "l"  #'eshell/clear))

(add-hook 'eshell-first-time-mode-hook #'floscr|+eshell|init-keymap)
#+END_SRC

**** Elisp

#+BEGIN_SRC elisp
(map! :map emacs-lisp-mode-map
      ;;
      ;; Rearrange Sexps

      :gni "M-;"   #'symex-mode-interface
      :n "s-k"   (cmd! (sp-transpose-sexp)
                     (evil-previous-line))
      :n "s-j"   (cmd! (sp-push-hybrid-sexp)
                     (evil-next-line))

      ;; Eval Buffer
      :n "s-r" #'eval-buffer

      ;; Slurp and barf
      :n "g]"  #'sp-slurp-hybrid-sexp
      :n "g["  #'sp-forward-barf-sexp

      :localleader
      :desc "Ly Mode"                 "l"  #'+ly-mode
      :desc "Jump to tangled source"  "j"  #'org-babel-tangle-jump-to-org
      :desc "Symex Mode"              "s" #'symex-mode-interface
      :desc "Raise sexp"              "<" #'raise-sexp
      :desc "Barf Sexp"               ">" #'barf-sexp)
#+END_SRC

**** Haskell

#+BEGIN_SRC elisp
(map! :map haskell-mode-map
      :localleader
      :desc "Stylish" "s" #'format-haskell-with-brittany-and-stylish-haskell)
#+END_SRC

**** Bash

#+BEGIN_SRC elisp
(map! :map sh-mode-map
      :localleader
      :desc "Eval Region"  "e" #'sh-execute-region
      :desc "Eval Region"  "E" #'executable-interpret)
#+END_SRC

**** Git

#+BEGIN_SRC elisp
(map! :map magit-mode-map
      :localleader
      :desc "Toggle Magit Buffer Lock" "#" #'magit-toggle-buffer-lock)
#+END_SRC

**** Reasonml

#+BEGIN_SRC elisp
(map! :map reason-mode-map
      :localleader
      :desc "Eval Region"  "r" #'refmt)
#+END_SRC

**** Mail

#+BEGIN_SRC elisp
(map! :map (mu4e-view-mode-map mu4e-headers-mode-map)
      :localleader
      :g "x" (cmd!
              (require 'org-mu4e)
              (org-mu4e-store-and-capture)))
#+END_SRC

**** Beancount

#+BEGIN_SRC elisp
(map! :map (mu4e-view-mode-map mu4e-headers-mode-map)
      :localleader
      :g "x" (cmd!
              (require 'org-mu4e)
              (org-mu4e-store-and-capture)))
#+END_SRC
**** Images

#+BEGIN_SRC elisp
(map! :map 'image-mode-map
      :desc "Zoom in" :gn "+" #'image-increase-size
      :desc "Zoom in" :gn "-" #'image-decrease-size
      :desc "Zoom in" :gn "0" (cmd! (image-transform-set-scale 1)))
#+END_SRC

*** Minibuffer
**** Copy and Paste from the minibuffer

Since the minibuffer has no evil mode, i've got these bindings to help out:
- ~M-c~: Copy the minibuffer line
- ~M-v~: Paste from clipboard to minibuffer (Same as ~C-r 0~)
         This also removes trailing newlines

#+BEGIN_SRC elisp
(defun evil-get-register-string (REGISTER)
  "Get evil-register pure text content
Registers can be selected with ?letter
E.g.: ?* -> Clipboard Contents"
  (evil-vector-to-string (evil-get-register REGISTER)))

(defun paste-evil-register-clipboard-pruned ()
  "Paste the current clipboard pruned from newlines"
  (interactive)
  (insert (s-trim (shell-command-to-string "pbpaste")))
  (doom/forward-to-last-non-comment-or-eol))

(defun copy-minibuffer-line ()
  "Copies the minibuffer content to the clipboard"
  (interactive)
  (save-excursion
    (doom/forward-to-last-non-comment-or-eol)
    (set-mark-command nil)
    (doom/backward-to-bol-or-indent)
    (kill-ring-save (mark) (point))))

(defun setup-minibuffer ()
  "Set up keybindings for the minibuffer"
  (local-set-key (kbd "s-v") 'paste-evil-register-clipboard-pruned)
  (local-set-key (kbd "s-c") 'copy-minibuffer-line))

(add-hook 'minibuffer-setup-hook 'setup-minibuffer)

;; (define-key! :keymaps +default-minibuffer-maps
;;   "C-w" 'sp-backward-delete-word)
#+END_SRC
** Hacks
*** Fix ~evil-org-mode-map~

Fixes =(void-function ad-Advice-newline-and-indent)= error for now.
I honestly don't know where this comes from.

#+BEGIN_SRC elisp
(map!
 :map evil-org-mode-map
 :after org
 :i [return] #'org-return-and-maybe-indent)
#+END_SRC
*** Prevent ~woman defvaralias~ error

I'm using ~woman~ for manuals, but it throws this error on first launch

#+BEGIN_QUOTE
Warning (defvaralias): Overwriting value of ‘woman-topic-history’ by aliasing to ‘Man-topic-history’
#+END_QUOTE

Solution from here: [[https://discord.com/channels/406534637242810369/406554085794381833/703782241766998067][Doom Discord question]]

#+BEGIN_SRC elisp
(add-to-list 'warning-suppress-types '(defvaralias))
#+END_SRC

*** Stupid workaround where splitting a window with evil-ex-results breaks emacs...

#+BEGIN_SRC elisp
(advice-add 'evil-window-vsplit :after #'evil-force-normal-state)
(advice-add 'evil-window-split :after #'evil-force-normal-state)
#+END_SRC
*** Emacs 28 Head Workaround

#+begin_src elisp
(with-no-warnings
      (defclass xref-location () ()
        :documentation "(Obsolete) location represents a position in a file or buffer."))
#+end_src
*** Make optional

#+begin_src elisp
(defmacro define-obsolete-function-alias ( obsolete-name current-name &optional when
                                           docstring)
  "Set OBSOLETE-NAME's function definition to CURRENT-NAME and mark it obsolete.

\(define-obsolete-function-alias \\='old-fun \\='new-fun \"22.1\" \"old-fun's doc.\")

is equivalent to the following two lines of code:

\(defalias \\='old-fun \\='new-fun \"old-fun's doc.\")
\(make-obsolete \\='old-fun \\='new-fun \"22.1\")

WHEN should be a string indicating when the function was first
made obsolete, for example a date or a release number.

See the docstrings of `defalias' and `make-obsolete' for more details."
  (declare (doc-string 4))
  `(progn
     (defalias ,obsolete-name ,current-name ,docstring)
     (make-obsolete ,obsolete-name ,current-name ,when)))
#+end_src
*** Fix Flycheck for emacs 29

#+begin_src elisp
(defun +flycheck/fix-emacs-29-save (&rest args)
  (flycheck-clear)
  (flycheck-buffer))

(advice-add #'flycheck-handle-save :after #'+flycheck/fix-emacs-29-save)
#+end_src
