#+TITLE: Org Mode Configuration
#+AUTHOR: Florian Schrödl (floscr)
#+PROPERTY: header-args :emacs-lisp :tangle yes :comments link
#+STARTUP: org-startup-folded: showall
#+BEGIN_SRC emacs-lisp
;; -*- lexical-binding: t -*-
#+END_SRC

* Org Mode
** Config
*** General config
**** Attachment

Disable displaying all images after attaching

#+begin_src emacs-lisp
(setq org-download-display-inline-images nil)
#+end_src

**** Directories

#+BEGIN_SRC elisp
;; Doom resets the default ~org-directory~, so this is a workaround.
(setq org-directory "~/Documents/Org")
(after! org
  (setq org-directory "~/Documents/Org")
  (setq org-default-notes-file (+org/expand-org-file-name "Main/inbox.org")))

(setq +org:shopping-list-file (+org/expand-org-file-name "Main/shoppinglist.org"))
(setq +org:reading-list-file (+org/expand-org-file-name "Main/reading-list.org"))
(setq +org:bookmarks-file (+org/expand-org-file-name "Bookmarks/bookmarks.org"))
#+END_SRC

**** Fix date compatibility before 1970

Org mode does not work for dates before 1970 for old emacs versions.
I do not care about backwards compatibility and have dates for books date predate this.

#+BEGIN_SRC elisp
(after! org
  (setq org-read-date-force-compatible-dates nil))
#+END_SRC

**** Unset tags column

I prefer not having an aligned tags column,
it just messes with the mobile clients, ~visual-line-mode~ and I view org files in the agenda most of the time anyway.

I don't set it to ~nil~ so the ~org-align-tags~ function still works.

#+BEGIN_SRC elisp
(setq org-tags-column 0)
#+END_SRC
**** Source window

Open the source buffers in the same window.

#+BEGIN_SRC elisp
(after! org
  (setq org-src-window-setup 'current-window))
#+END_SRC

**** Image width

#+BEGIN_SRC elisp
(after! org
  (setq org-image-actual-width 600))
#+END_SRC

**** Tags

#+BEGIN_SRC elisp
(after! org
  (setq org-tag-alist '(("WORK")
                        ("HOME")
                        ("PERSONAL")
                        ("LOW_EFFORT")
                        ("MEDIUM_EFFORT")
                        ("YAK_SHAVE")
                        ("PROJECT")
                        ("EMACS")
                        ("NIXOS")
                        ("TO_BUY")
                        ("EREADER"))))
#+END_SRC

**** Load hook

Customize org mode to:
- Always keep the buffer centered via ~viusal-fill-column-mode~.
  This has to be installed extra, doom doesn't ship with it anymore.
- Always reload buffers when the file changes via ~auto-revert-mode~
  Automatically update on Syncthing changes.
- Disable automatic line wrapping from ~auto-fill-mode~
  Automatic line wrapping is great when you're working on one display,
  but when you edit the same text on mobile it will break awkwardly.
- Visually Wrap text with ~visual-line-mode~
  Since text is not hard wrapped, I wrap it via Emacs visually.

#+BEGIN_SRC elisp
(setq visual-fill-column-center-text t
      visual-fill-column-width fill-column)

(defun +org*setup-org-mode-hook ()
  "Setup org mode buffers."
  (auto-fill-mode -1)
  (display-line-numbers-mode -1)
  (line-number-mode -1)
  (hl-line-mode -1)
  (auto-revert-mode 1)
  (setq-local visual-fill-column-center-text t)
  (setq-local visual-fill-column-width 120)
  (visual-fill-column-mode)
  (visual-line-mode)
  (visual-fill-column-adjust))

(after! org
  (add-hook! org-mode #'+org*setup-org-mode-hook))
#+END_SRC

**** Todo-state keywords

All todo keywords are for general items.

#+BEGIN_SRC elisp
(after! org
  :config
  (setq org-todo-keywords
        '((sequence "ACTIVE(a)" "NEXT(n)" "|" "DONE")
          (sequence "TODO(t)" "|" "DONE(x)")
          (sequence "WAITING(w)" "WAIT_RESPONSE(r)" "WAIT_QA(q)" "SOMEDAY(s)" "|" "DONE" "CANCELLED(c)")
          (sequence "PROJECT(p)" "|" "DONE")
          (sequence "NOTE(N)")))
  (setq org-todo-keyword-faces
        '(("ACTIVE" :inherit warning :weight bold)
          ("NEXT" :inherit warning :weight bold)
          ("NOTE" :inherit warning :weight bold)
          ("WAITING" :inherit default :weight bold)
          ("WAIT_RESPONSE" :inherit default :weight bold)
          ("WAIT_QA" :inherit default :weight bold)
          ("SOMEDAY" :inherit default :weight bold)
          ("PROJECT" :inherit 'org-todo :weight bold)))
  (setq org-done-keywords '("DONE" "[X]" "CANCELLED")))
#+END_SRC

**** Todo-Popup

Don't show the ~todo~ selection in a popup,
I know my keys, and the popup is problemating when displaying with certain windows,
e.g.: Agenda + Splits

#+BEGIN_SRC elisp
(setq org-use-fast-todo-selection 'expert)
#+END_SRC

**** Projectile ignore ~org_archive~

#+BEGIN_SRC elisp
(after! projectile
  (add-to-list 'projectile-globally-ignored-file-suffixes ".org_archive"))
#+END_SRC

**** Latex

#+BEGIN_SRC elisp
(setq org-latex-create-formula-image-program 'dvisvgm)
#+END_SRC

**** Disable Spellchecking SRC Regions

#+BEGIN_SRC elisp
(defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
  (let* ((rlt ad-return-value)
         (begin-regexp "^[ \t]*#\\+BEGIN_SRC")
         (end-regexp "^[ \t]*#\\+END_SRC")
         (case-fold-search t)
         b e)
    (when ad-return-value
      (save-excursion
        (setq b (re-search-backward begin-regexp nil t))
        (if b (setq e (re-search-forward end-regexp nil t))))
      (if (and b e (< (point) e)) (setq rlt nil)))
    (setq ad-return-value rlt)))
#+END_SRC

**** Habits

***** Log Habits into drawer

#+BEGIN_SRC elisp
(setq org-log-into-drawer t)
#+END_SRC

**** Keep plain lists also folded

#+BEGIN_SRC elisp
(after! org
  (setq org-cycle-include-plain-lists 'integrate))
#+END_SRC
**** Effort

#+BEGIN_SRC elisp
(setq org-columns-default-format "%60ITEM(Task) %TODO %6Effort(Estim){:}  %6CLOCKSUM(Clock) %TAGS")
#+END_SRC

*** Refile targets

#+BEGIN_SRC elisp
(setq +org:level-1-refile-targets
      (+org/expand-org-file-name
       '("Main/reading-list.org"
         "Main/cooking.org"
         "Main/books.org"
         "Main/programming.org"
         "Main/shoppinglist.org")))

(setq +org:max-level-2-refile-targets
      (+org/expand-org-file-name
       '("Main/emacs.org"
         "Main/art.org"
         "Main/diary"
         "Main/games.org"
         "Main/hardware.org"
         "Main/gtd.org"
         "Main/inbox.org"
         "Main/mealplan.org"
         "Main/misc.org"
         "Main/movies.org"
         "Main/music.org"
         "Main/osx.org"
         "Main/personal.org"
         "Main/podcasts.org"
         "Main/sleep.org"
         "Main/sports.org"
         "Main/travel.org"
         "Work/work.org")))

(setq max-level-3-refile-targets
      (+org/expand-org-file-name
       '("Main/projects.org")))

(defun +org:level-1-refile-targets () +org:level-1-refile-targets)
(defun +org:max-level-2-refile-targets () +org:max-level-2-refile-targets)
(defun max-level-3-refile-targets () max-level-3-refile-targets)

(after! org
  :config
  (setq org-refile-targets (quote ((nil :maxlevel . 5)
                                   (+org:max-level-2-refile-targets :maxlevel . 2)
                                   (max-level-3-refile-targets :maxlevel . 3)
                                   (+org:level-1-refile-targets :level . 1))))
  (setq org-agenda-refile org-agenda-files))
#+END_SRC

*** Capture
**** Config

#+BEGIN_SRC elisp
(setq +org-capture-frame-parameters
  `((name . "doom-capture")
    (width . 150)
    (height . 45)
    (transient . t)))
#+END_SRC

**** Templates

Configured with [[https://github.com/progfolio/doct][doct]].

#+BEGIN_SRC elisp
(use-package! doct
  :after org
  :init (setq org-capture-templates '())
  :config
  (setq org-capture-templates
        (doct `((:group "Inbox"
                 :todo "TODO"
                 :title "%?"
                 :file org-default-notes-file
                 :template ("* %{todo} %{title}"
                            ":PROPERTIES:"
                            ":CREATED: %U"
                            ":END:")
                 :children
                 (("Task"
                   :keys "t")
                  ("Backlog Task"
                   :file ,(+org/expand-org-file-name "Main/gtd.org")
                   :headline "GTD"
                   :keys "b")
                  ("Chrome Window"
                   :keys "c"
                   :title "%(+wm/last-chrome-window-org-link)")
                  ("Reading List"
                   :keys "r"
                   :title "%(+wm/last-chrome-window-org-link)"
                   :headline "Reading List"
                   :file +org:reading-list-file)
                  ("Elfeed"
                   :keys "e"
                   :children
                   (("Watch"
                     :keys "w"
                     :title "%(pop kill-ring)"
                     :headline "Watching List"
                     :file +org:reading-list-file)
                    ("Read"
                     :keys "r"
                     :title "%(pop kill-ring)"
                     :headline "Reading List"
                     :file +org:reading-list-file)))
                  ("Shopping"
                   :keys "s"
                   :headline "Supermarket"
                   :file +org:shopping-list-file)
                  ("Recipe"
                   :keys "R"
                   :headline "Recipes"
                   :file ,(f-join org-directory "Main/cooking.org")
                   :template ("* %(car (+wm/last-chrome-window-url-title))"
                              ":PROPERTIES:"
                              ":SOURCE: %(nth 1 (+wm/last-chrome-window-url-title))"
                              ":END:"
                              "** Prep"
                              "%?"
                              "** Ingredients"))
                  ("Work:"
                   :keys "w"
                   :file ,(f-join org-directory "Work/work.org")
                   :headline "GTD"
                   :children
                   (("Task"
                     :title "%?"
                     :keys "t")
                    ("Task (Chrome)"
                     :keys "c"
                     :title "%(+wm/last-chrome-window-org-link-formatted)")
                    ("Job Application (Chrome)"
                     :keys "j"
                     :title "%(+wm/last-chrome-window-org-link-formatted) :META:JOB_APPLICATION:\nSCHEDULED: %(org-insert-time-stamp (current-time))")
                    ("Meeting (Chrome)"
                     :keys "m"
                     :title "%(+wm/last-chrome-window-org-link-formatted) :MEETING:")
                    ("Review (Chrome)"
                     :keys "r"
                     :title "%(+wm/last-chrome-window-org-link-formatted) :REVIEW:\nSCHEDULED: %(org-insert-time-stamp (current-time))")))))
                ("Bookmarks"
                 :keys "p"
                 :file +org:bookmarks-file
                 :headline "Bookmarks"
                 :template ("* %(nth 0 (+wm/last-chrome-window-url-title))"
                            ":PROPERTIES:"
                            ":URL: %(nth 1 (+wm/last-chrome-window-url-title))"
                            ":CREATED: %U"
                            ":END:"))))))

#+END_SRC
*** SRC block snippets

#+BEGIN_SRC elisp :tangle no
(add-to-list 'org-structure-template-alist '("es" "#+BEGIN_SRC elisp\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("E"  "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE"))
(add-to-list 'org-structure-template-alist '("j"  "#+BEGIN_SRC js\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("ps" "#+BEGIN_SRC purescript\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("b"  "#+BEGIN_SRC bash\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("re" "#+BEGIN_SRC reason\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("oc" "#+BEGIN_SRC ocaml\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("rb" "#+BEGIN_SRC ruby\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("md" "#+BEGIN_SRC markdown\n?\n#+END_SRC\n"))
(add-to-list 'org-structure-template-alist '("n" "#+BEGIN_SRC nim\n?\n#+END_SRC\n"))
#+END_SRC

*** Agenda
**** Config
***** Customization

#+BEGIN_SRC elisp
(after! org-agenda
  (setq org-agenda-use-time-grid nil)
  (setq org-agenda-block-separator ?—))
#+END_SRC

***** Files

#+BEGIN_SRC elisp
(after! org-agenda
  (setq org-agenda-files
        (+org/expand-org-file-name
         '("Main/gtd.org"
           "Main/gtd-reoccuring-events.org"
           "Main/inbox.org"
           "Main/projects.org"
           "Main/contacts.org"
           "Main/calendar-family.org"
           "Work/work.org"))))
#+END_SRC

***** Sorting strategies

#+BEGIN_SRC elisp
(after! org-agenda
  (setq-default
   org-agenda-cmp-user-defined #'+org|compare-created-date-property
   org-agenda-sorting-strategy '((agenda habit-down user-defined-up time-up priority-down category-keep)
                                 (todo priority-down category-keep user-defined-up time-up)
                                 (tags priority-down category-keep user-defined-up time-up)
                                 (search category-keep))))
#+END_SRC

***** Always save files after agenda commands

I always forget to save after agenda commands since it feels like an UI.
So I've added ~advices~ to save all buffers after executing them.

This is taken from [[https://emacs.stackexchange.com/questions/21754/how-to-automatically-save-all-org-files-after-marking-a-repeating-item-as-done-i][StackOverflow: How to automatically save all org files after marking a repeating item as DONE in the org agenda?]]

The macro is take from [[file:~/.config/doom/autoload.org::*Ignore Arguments][Ignore Arguments]].

#+BEGIN_SRC elisp
(after! org
  :init
  (advice-add 'org-agenda-clock-in  :after (η #'org-save-all-org-buffers))
  (advice-add 'org-agenda-clock-out :after (η #'org-save-all-org-buffers))
  (advice-add 'org-deadline         :after (η #'org-save-all-org-buffers))
  (advice-add 'org-schedule         :after (η #'org-save-all-org-buffers))
  ;; (advice-add 'org-todo             :after (η #'org-save-all-org-buffers))
  (advice-add 'org-agenda-clock     :after (η #'org-save-all-org-buffers))
  (advice-add '+org|counsel-org-tag :after (η #'org-save-all-org-buffers))
  (advice-add 'org-agenda-kill      :after (η #'org-save-all-org-buffers))
  (advice-add 'org-agenda-archive   :after (η #'org-save-all-org-buffers)))
#+END_SRC

**** Bindings
***** Enable avy/evil-motion for agenda

#+BEGIN_SRC elisp
(map! :after evil-org-agenda
      :map org-agenda-mode-map
      :m "gs" nil)
#+END_SRC

***** Motions

#+BEGIN_SRC elisp
(evil-define-key 'motion org-agenda-mode-map
  "vd" 'org-agenda-day-view
  "ds" 'org-agenda-schedule
  "vw" 'org-agenda-week-view
  "vm" 'org-agenda-month-view
  "vy" 'org-agenda-year-view)
#+END_SRC

**** Custom Agenda Commands

Helper to reset the org agenda custom commands.

#+BEGIN_SRC elisp :tangle no
(setq org-agenda-custom-commands '())
#+END_SRC

***** Helpers
****** Get topmost todo

#+BEGIN_SRC elisp
(defun +org/topmost-todo-header ()
  "Return the topmost TODO item of the current org tree.
returns a pair with '(TODO-STATE POINT)."
  (let ((headings '()))
    (save-excursion
      (while (org-up-heading-safe)
        (add-to-list 'headings (list (org-get-todo-state) (point)))))
    (--last (-contains? '("TODO" "ACTIVE") (car it)) headings)))

(defun +org|org-topmost-todo-element ()
  "Go to the topmost todo item of an org tre."
  (interactive)
  (-some->> (+org/topmost-todo-header)
    (nth 1)
    (goto-char)))
#+END_SRC

****** Get Parent Project

#+BEGIN_SRC elisp
(defun +org/get-parent-project ()
  "Search upwards for either parent tree for item with either PROJECT or ACTIVE todo state."
  (while (and (org-up-heading-safe) (not (--find (string= (org-get-todo-state) it) '("PROJECT" "ACTIVE")))))
  (--find (string= (org-get-todo-state) it) '("PROJECT" "ACTIVE")))
#+END_SRC

****** Super Agenda ~TODO~ autogroup

Adds super agenda auto group for headings defined in [[*Get Parent Project][Get Parent Project]] function.
This way I can create super agenda groups for items with ~PROJECT~ heading, that have their own subtasks.

#+BEGIN_SRC elisp
(after! org-super-agenda
  :init
  (org-super-agenda--def-auto-group parent-todo "their parent todo heading"
    :key-form (org-super-agenda--when-with-marker-buffer (org-super-agenda--get-marker item)
                (when (and (org-up-heading-safe) (+org/get-parent-project))
                  (org-get-heading 'notags 'notodo)))))
#+END_SRC

***** Opening tag

#+BEGIN_SRC elisp
(after! org-agenda
#+END_SRC

***** All todos ~x~

#+BEGIN_SRC elisp
(+org/add-to-agenda-custom-commands
 '("x" "Todo Items"
   ((agenda
     "a"
     ((org-agenda-span 3)
      (org-agenda-start-day ".")
      (org-agenda-show-all-dates nil)
      (org-agenda-prefix-format '((agenda . "%11s%?-t")))
      (org-super-agenda-header-separator "")
      (org-agenda-sorting-strategy '(time-up scheduled-up todo-state-up priority-down user-defined-up))
      (org-super-agenda-groups '((:name "\nHabits" :habit t :order 1000)
                                 (:name "Work Meetings" :and (:tag ("MEETING") :not (:tag ("REPEATING"))))
                                 (:name nil :discard (:tag "WORK" :todo "PROJECT"))
                                 (:name none :date today :time-grid t)
                                 (:name "\nOverdue" :deadline past :scheduled past)
                                 (:name "Future" :anything (:scheduled future))))))
    (tags-todo
     "-WORK-BACKLOG"
     ((org-agenda-prefix-format "  %?-12t% s")
      (org-agenda-sorting-strategy '(user-defined-down timestamp-down todo-state-down))
      (org-super-agenda-groups '((:name "Next" :todo ("ACTIVE"))
                                 (:name nil :discard (:file-path "projects.org"))
                                 (:name nil :discard (:scheduled t :deadline t :file-path "gtd-reoccuring-events.org"))
                                 (:name "Inbox Links" :regexp "TODO \\(\\[\\[\\\|https?:\\)" :order 2)
                                 (:name "Inbox" :file-path ".*inbox.org$" :order 2)
                                 (:name "Unscheduled" :and (:todo "TODO" :scheduled nil :not (:tag "BACKLOG")) :order 1)
                                 (:name "Overdue" :scheduled past))))))))
#+END_SRC

***** Backlog

#+BEGIN_SRC elisp
(+org/add-to-agenda-custom-commands
 '("b" "Backlog Items"
   ((tags-todo
     "+BACKLOG-WORK"
     ((org-agenda-prefix-format "  %?-12t% s")
      (org-agenda-todo-ignore-scheduled t)
      (org-agenda-sorting-strategy '(priority-down todo-state-up user-defined-down timestamp-down))
      (org-super-agenda-groups '((:discard (:scheduled t))
                                 (:name "Emacs" :tag ("EMACS"))
                                 (:name "Nixos" :tag ("NIXOS"))
                                 (:name "Digital" :tag ("DIGITAL"))
                                 (:name "Personal" :tag ("PERSONAL") :order 1)
                                 (:name "Home" :tag ("HOME") :order -1)
                                 (:name "To Buy" :tag ("TO_BUY") :order 2)
                                 (:name "Untagged" :order -3 :anything))))))
   ((org-agenda-hide-tags-regexp "BACKLOG")
    (org-agenda-files (--map (f-join org-directory it) '("Main/gtd.org"))))))
#+END_SRC

***** Today

#+BEGIN_SRC elisp
(+org/add-to-agenda-custom-commands
 '("d" "Day View" ((agenda "a"
                           ((org-agenda-prefix-format "  %?-12t% s")
                            (org-agenda-start-on-weekday nil)
                            (org-agenda-span 1)
                            (org-agenda-start-day ".")
                            (org-agenda-skip-scheduled-if-done t)
                            (org-agenda-sorting-strategy '(timestamp-up time-up))
                            (org-super-agenda-header-separator "")
                            (org-agenda-day-view)
                            (org-super-agenda-groups '((:name none :date today :time-grid t)
                                                       (:name "\nOverdue" :deadline past :scheduled past)
                                                       (:name "Future" :anything (:scheduled future)))))))))
#+END_SRC

***** Week

#+BEGIN_SRC elisp
(+org/add-to-agenda-custom-commands
 '("c" "Calendar" agenda ""
   ((org-agenda-span 7)
    (org-agenda-start-on-weekday nil)
    (org-agenda-start-day "-1d")
    (org-agenda-tag-filter-preset '("+CALENDAR")))))
#+END_SRC

***** Work
****** Main

#+BEGIN_SRC elisp
(+org/add-to-agenda-custom-commands
 `("w" "Work Agenda"
   ((agenda "a" ((org-agenda-sorting-strategy '(time-up todo-state-up priority-down scheduled-up user-defined-up))
                 (org-agenda-span ,(+org/work-week-agenda-span))
                 (org-agenda-start-on-weekday t)
                 (org-agenda-start-day ,(+org/work-start-day))
                 (org-super-agenda-header-separator "")
                 (org-super-agenda-groups '((:name "Tasks" :tag "TASK" :order 1)
                                            (:name "Reviews" :tag "REVIEW" :order 2)
                                            (:anything)))))
    (alltodo ""
             ((org-agenda-todo-list-sublevels nil)
              (org-agenda-sorting-strategy '(priority-down time-up todo-state-up user-defined-down))
              (org-super-agenda-groups '((:discard (:todo ("[ ]" "[|]") :tag "HIDE_FROM_AGENDA"))
                                         (:name "Yak Shave" :tag "YAK_SHAVE" :order 30)
                                         (:name "Notes" :todo "NOTE")
                                         (:name "Inbox" :category "Inbox" :order 5)
                                         (:name "Meetings" :tag "MEETING" :order 2)
                                         (:name "Reviews" :tag "REVIEW" :order 4)
                                         (:name "Backlog" :tag "BACKLOG" :order 11)
                                         (:name "Tasks" :tag "TASK" :order 3)
                                         (:name "Time Management" :and (:tag "TIME_MANAGEMENT") :order 3)
                                         (:name "GTD (Not Scheduled)" :and (:tag "GTD" :scheduled nil :not (:todo "WAITING")))
                                         (:name "GTD" :and (:tag "GTD"))
                                         (:name "Reading List" :tag "TEXT" :order 10))))))
   ((org-agenda-hide-tags-regexp "WORK\\|BACKLOG")
    (org-agenda-tag-filter-preset '("+WORK"))
    (org-agenda-files (--map (f-join org-directory it) '("Work/work.org" "Main/inbox.org"))))))
#+END_SRC

****** Projects

#+BEGIN_SRC elisp
(+org/add-to-agenda-custom-commands
 '("p" "Work Project Agenda"
   ((alltodo "+WORK-EVENT"
             ((org-agenda-sorting-strategy '(todo-state-down user-defined-down timestamp-down time-down))
              (org-agenda-tag-filter-preset '("-EVENT"))
              (org-super-agenda-groups '((:name "Projects" :auto-parent-todo)
                                         (:discard (:anything t)))))))
   ((org-agenda-hide-tags-regexp "WORK\\|BACKLOG")
    (org-agenda-files (list (f-join org-directory "Work/work.org"))))))
#+END_SRC

****** Meistermacs

#+BEGIN_SRC elisp
(setq +MM:my-meistertask-name-tag "+@FLORIAN_SCHROEDL")

(+org/add-to-agenda-custom-commands
 '("ys" "Sprint"
   ((alltodo ""
             ((org-super-agenda-groups '((:auto-category t))))))
   ((org-agenda-files (list (f-join doom-cache-dir "meistertask" "meistertask_mind_meister_sprint.org"))))
   ((org-agenda-tag-filter-preset `(,+MM:my-meistertask-name-tag)))))

(+org/add-to-agenda-custom-commands
 '("yb" "Beta"
   ((alltodo ""
             ((org-super-agenda-groups '((:auto-category t))))))
   ((org-agenda-files (list (f-join doom-cache-dir "meistertask" "meistertask_mm_panda.org")))
    (org-agenda-hide-tags-regexp "meistertask_mm_panda"))
   ((org-agenda-tag-filter-preset `(,+MM:my-meistertask-name-tag)))))

(+org/add-to-agenda-custom-commands
 '("yk" "Kits"
   ((alltodo ""
             ((org-super-agenda-groups '((:auto-category t))))))
   ((org-agenda-files (list (f-join doom-cache-dir "meistertask" "meistertask_platform_kits.org")))
    (org-agenda-hide-tags-regexp "meistertask_platform_kits"))
   ((org-agenda-tag-filter-preset `(,+MM:my-meistertask-name-tag)))))

(+org/add-to-agenda-custom-commands
 '("yl" "Log"
   ((alltodo ""
             ((org-super-agenda-groups '((:auto-category t))))))
   ((org-agenda-files (list (f-join doom-cache-dir "meistertask" "meistertask_platform_backlog.org")))
    (org-agenda-hide-tags-regexp "meistertask_platform_backlog"))
   ((org-agenda-tag-filter-preset `(,+MM:my-meistertask-name-tag)))))
#+END_SRC

***** Personal projects

#+BEGIN_SRC elisp
(+org/add-to-agenda-custom-commands
 '("P" "Personal Project Agenda"
   ((alltodo ""
             ((org-agenda-sorting-strategy '(priority-down todo-state-down user-defined-down timestamp-down time-down))
              (org-super-agenda-groups '((:name "Projects" :auto-parent-todo)
                                         (:discard (:anything t)))))))
   ((org-agenda-files (--> '("Main/projects.org" "Main/gtd.org")
                            (--map (f-join org-directory it) it))))))
#+END_SRC

***** Books

#+BEGIN_SRC elisp
(+org/add-to-agenda-custom-commands
 '("l" "Literature (Books)"
   ((alltodo ""
     ((org-agenda-files (--map (f-join org-directory it) '("Main/books.org")))
      (org-super-agenda-groups '((:name "Fiction" :tag ("FICTION"))
                                 (:name "Non-Fiction" :tag ("NON_FICTION"))
                                 (:name "Self Help" :tag ("SELF_HELP"))
                                 (:name "Comics" :tag ("COMIC")))))))))
#+END_SRC
***** Closing Tag

#+BEGIN_SRC elisp
)
#+END_SRC

*** Clocking
**** Automatically set clocking or todo state
:PROPERTIES:
:SOURCE:   [[https://github.com/magnars/dash.el#-contains-list-element][magnars/dash.el: A modern list library for Emacs]]
:END:

#+BEGIN_SRC elisp
(after! org
#+END_SRC

Clock in when the todo state has been changed to ~ACTIVE~

#+BEGIN_SRC elisp
(defun +org/org-clock-in-if-starting ()
  "Clock in when the task is marked ACTIVE."
  (when (and (string= org-state "ACTIVE")
             (not (string= org-last-state org-state)))
    (org-clock-in)))

(add-hook 'org-after-todo-state-change-hook '+org/org-clock-in-if-starting)
#+END_SRC

Clock out when the todo state is set to a delay state.

#+BEGIN_SRC elisp
(defun +org/org-clock-out-if-waiting ()
  "Clock out when the task is marked WAITING."
  (when (and (-contains? '("WAITING" "SOMEDAY" "CANCELLED") org-state)
             (equal (marker-buffer org-clock-marker) (current-buffer))
             (< (point) org-clock-marker)
             (> (save-excursion (outline-next-heading) (point))
               org-clock-marker)
             (not (string= org-last-state org-state)))
    (org-clock-out)))

(add-hook 'org-after-todo-state-change-hook '+org/org-clock-out-if-waiting)
#+END_SRC

Set the active state when clocking in.

#+BEGIN_SRC elisp :tangle no
(defun +org/org-set-active-state (&optional args args2)
  "Set the active state for the current item."
  (cond ((+my/buffer-line-has "PROJECT") nil)
        ((+my/buffer-line-has "\\[.\\]") (org-todo "[!]"))
        ((not (+my/buffer-line-has (rx (or "ACTIVE" "NEXT" "DONE" "TODO" "WAITING" "SOMEDAY" "CANCELLED" "PROJECT")))) nil)
        (t (org-todo "ACTIVE"))))

(advice-add #'org-clock-in :after #'+org/org-set-active-state)
#+END_SRC

#+BEGIN_SRC elisp
)
#+END_SRC

**** Polybar clock display

#+BEGIN_SRC elisp
(defun +org/org-clock-polybar-status ()
  "Status for the polybar org clock module."
  (if (org-clocking-p)
      (->>
       (org-clock-get-clock-string)
       (substring-no-properties)
       (s-prepend ""))
    -1))
#+END_SRC

**** Open Link

#+BEGIN_SRC elisp
(defun +org|clocked-visit-link ()
  "Visit a link in the currently clocked task."
  (interactive)
  (let* ((buffer (save-window-excursion (+org-indirect|narrow-subtree-indirect #'org-clock-goto t)))
         (content (with-current-buffer buffer (buffer-substring-no-properties (point-min) (point-max))))
         (links (s-match-strings-all org-bracket-link-regexp content))
         (items (-map (lambda (x)
                        (-let* (((_ title link) x)
                                (item (if (and title link)
                                          (t! "<<title>>\n<<link>>")
                                        (or link title))))
                          (list (t! "<<item>>\n") link))) links)))
    (kill-buffer buffer)
    (ivy-read "Open Link: " items
              :action (lambda (x)
                        (browse-url (car x))))))
#+END_SRC

*** Tables
**** Copy Table Field

#+BEGIN_SRC elisp
(defun +org|table-copy-field ()
  "Copy a table field under the cursor."
  (interactive)
  (save-excursion
    (kill-new (s-trim (org-table-get-field)))))
#+END_SRC
*** Org QL
**** Personal Projects

#+BEGIN_SRC elisp
(defun +org-ql|projects ()
  "List all work projects."
  (interactive)
  (org-ql-search (+org/expand-org-file-name '("Main/projects.org"))
    '(and (todo)
          (ancestors
           (and (todo))))
    :title "Projects"
    :sort '(todo priority date)
    :super-groups '((:auto-outline-path))))
#+END_SRC

**** Work Projects

#+BEGIN_SRC elisp
(defun +org-ql|work-projects ()
  "List all work projects."
  (interactive)
  (org-ql-search (+org/expand-org-file-name '("Work/work.org"))
    '(and (todo)
          (ancestors
           (and (todo))))
    :title "Work Projects"
    :sort '(todo priority date)
    :super-groups '((:auto-outline-path))))
#+END_SRC

**** Search

#+BEGIN_SRC elisp
(defun +org|search ()
  (interactive)
  (require 'org-ql)
  (let ((files (org-agenda-files)))
    (ivy-read
     "Query: "
     #'(lambda (input)
         (let ((query (org-ql--query-string-to-sexp input)))
           (when query
             (ignore-errors
               (org-ql-select files query
                 :action (lambda ()
                           (propertize (org-get-heading t)
                                       'marker (copy-marker (point)))))))))
     :dynamic-collection t
     :action #'+org|search-goto)))

(defun +org|work-search ()
  (interactive)
  (require 'org-ql)
  (let ((files (list (+org/expand-org-file-name "Work/work.org"))))
    (ivy-read
     "Query: "
     #'(lambda (input)
         (let ((query (org-ql--query-string-to-sexp input)))
           (when query
             (ignore-errors
               (org-ql-select files query
                 :action (lambda ()
                           (propertize (org-get-heading t)
                                       'marker (copy-marker (point)))))))))
     :dynamic-collection t
     :action #'+org|search-goto)))


(defun +org|search-goto (headline)
  (interactive)
  (+org-indirect|narrow-subtree-indirect (lambda ()
                                           (let ((marker (get-text-property 0 'marker headline)))
                                             (when (markerp marker)
                                               (switch-to-buffer (marker-buffer marker))
                                               (goto-char marker)
                                               (org-show-entry))))))
#+END_SRC

** Modules

#+BEGIN_SRC elisp
(if (featurep! +org-noter)        (load! "+org-noter"))
(if (featurep! +org-web-tools)    (load! "+org-web-tools"))
(if (featurep! +org-tags)         (load! "+org-tags"))
#+END_SRC

*** Bookmarks

#+BEGIN_SRC elisp
(defun +org|refile-to-bookmarks ()
  "Refile the current headline to bookmarks with url in properties."
  (interactive)
  (require 'org-ml)
  (let* ((item (org-ml-parse-this-headline))
         (headline (org-ml-get-property :raw-value item))
         (headline-match (s-match "^\\[\\[\\(.+\\)\\]\\[\\(.*\\)\\]\\]" headline))
         (new-item
          (--> item
               (org-ml-set-property :level 2 it)
               (org-ml-headline-set-title! (nth 2 headline-match) nil it)
               (org-ml-set-property :todo-keyword nil it)
               (org-ml-headline-set-node-property "URL" (nth 1 headline-match) it)
               (org-ml-to-string it))))
    (call-interactively #'org-cut-subtree)
    (find-file +org:bookmarks-file)
    (goto-char (point-max))
    (insert "\n")
    (insert new-item)
    (call-interactively #'+org|counsel-org-tag)))

(defun +org|agenda-refile-to-bookmarks ()
  "Refile the current agenda headline to bookmarks with url in properties."
  (interactive)
  (org-agenda-switch-to)
  (+org|refile-to-bookmarks))
#+END_SRC

*** Reading list
**** Config

#+BEGIN_SRC elisp
(setq +org-reading-list:agenda-buffer-name "*Org Agenda: Reading List*")
#+END_SRC

**** Customize agenda UI

Remove the underline from the links.

#+BEGIN_SRC elisp
(defun +org-reading-list/customize-agenda ()
  (when (string= (buffer-name) +org-reading-list:agenda-buffer-name)
    (face-remap-add-relative 'org-link '(:underline nil :foreground white))))

(add-hook! 'org-agenda-finalize-hook :after '+org-reading-list/customize-agenda)
#+END_SRC

**** Agenda command

#+BEGIN_SRC elisp
(after! org-agenda
  (+org/add-to-agenda-custom-commands
   '("r" "Reading List" alltodo ""
     ((org-agenda-files (list +org:reading-list-file))
      (org-agenda-buffer-name +org-reading-list:agenda-buffer-name)
      (org-agenda-prefix-format "  %?-12t% s")
      (org-agenda-hide-tags-regexp "TEXT\\|VIDEO\\|RESEARCH")
      (org-agenda-sorting-strategy '(todo-state-up user-defined-down timestamp-down))
      (org-super-agenda-groups '((:name "Active" :todo ("NEXT" "ACTIVE") :order 0)
                                 (:name "Research" :tag "RESEARCH" :order 3)
                                 (:name "Someday" :todo "SOMEDAY" :order 3)
                                 (:name "Articles" :tag "TEXT" :order 1)
                                 (:name "Videos" :regexp "\\(youtube\\|vimeo\\).com" :tag "VIDEO" :order 2)))))))
#+END_SRC

*** Backup Link

#+BEGIN_SRC elisp
(defvar +org-backup:link-backup-directory nil
  "Directory where the backup files are stored.")
(setq +org-backup:link-backup-directory (+org/expand-org-file-name "LinkBackups"))

(defun +org-backup/backup-path (url &optional title)
  "Return the target directory path from an URL.
Take the host as the base and either the TITLE or the path from the URL."
  (let* ((url-obj (url-generic-parse-url url))
         (host (url-host url-obj))
         (path (or
                (-some->> title
                  (s-snake-case))
                (-some->> (url-path-and-query url-obj)
                  (car)
                  (s-replace-regexp "^/" "")
                  (s-replace-regexp "/$" "")
                  (s-replace "/" "_")
                  (s-replace-regexp "\\.[a-zA-Z]+$" "")))))
    (f-join +org-backup:link-backup-directory host path)))

(defun +org-backup/create-directory (url &optional title)
  "Create backup target directory from URL and TITLE."
  (let ((path (+org-backup/backup-path url title)))
    (shell-command-to-string (concat "mkdir -p " path))
    path))
#+END_SRC

**** Main

#+BEGIN_SRC elisp
(defun +org-backup/wget-link (dir)
  "Wget the given URL to the +org-backup:link-backup-directory"
  (require 'deferred)
  (let ((default-directory dir))
    (deferred:process
        "wget"
        ;; Disable Robots
        "-e" "robots=off"
        ;; Disable generation of host directories which might be nested
        "--no-host-directories"
        ;; Removes query parameters from media
        "--content-disposition"
        ;; Don't create directories
        "--no-directories"
        ;; Do not ascend to the parent
        "--no-parent"
        ;; Always download index as html file
        "--adjust-extension"
        ;; Enable spanning across hosts when doing recursive retrieving.
        "--span-hosts"
        ;; After the download is complete, convert the links in the document to make them suitable for local viewing.
        "--convert-links"
        ;; Download all files neccssary to view the page offline
        "--page-requisites"
        ;; These files are not neccessary for offline viewing and just cost space
        "--reject" "css,woff,ttf,js"
        url)))

(defun +org-backup/convert-html-to-org (path)
  "Convert html files at PATH to org documents."
  (--> (f-entries path)
       (--filter (f-ext? it "html") it)
       (-first-item it)
       (deferred:process
         "pandoc"
         "--wrap=none"
         "-f" "html"
         "-t" "org"
         it
         "-o" (f-swap-ext it "org"))))

(defun +org-backup/convert-html-to-epub (path)
  "Convert html files at PATH to org documents."
  (--> (f-entries path)
       (--filter (f-ext? it "html") it)
       (-first-item it)
       (deferred:process
         "ebook-convert"
         it
         (f-swap-ext it "epub"))))

(defun +org-backup|backup-dwim (&optional to-epub?)
  "Backup the first link under the cursor and set the property."
  (interactive)
  (require 'deferred)
  (require 'org-ml)
  (let* ((header (org-ml-parse-this-headline))
         (url (->> (org-offer-links-in-entry (current-buffer) (point) 0)
                   (car)
                   (substring-no-properties)
                   (+org/link-url-or-original)))
         (title (->> header
                  (org-ml-get-property :raw-value)
                  (+org/link-title-or-original)))
         (dir (+org-backup/create-directory url title)))
    (org-set-property "BACKUP" (template "[[<<dir>>]]"))
    (deferred:$
      (+org-backup/wget-link dir)
      (deferred:nextc it `(lambda ()
                            (+org-backup/convert-html-to-org ,dir)))
      (deferred:nextc it `(lambda ()
                            (when ,to-epub?
                              (+org-backup/convert-html-to-epub ,dir))))
      (deferred:nextc it `(lambda ()
                            (when ,to-epub?
                              (-some->> (f-files ,dir)
                                        (--find (f-ext? it "epub"))
                                        (s-prepend "file:")
                                        (org-set-property "BACKUP_EPUB"))))))))

(defun +org-backup|backup-dwim-epub ()
  "Function docstring"
  (interactive)
  (+org-backup|backup-dwim t))

(defun +org-backup/wget-images (dir)
  "Wget the given URL to the +org-backup:link-backup-directory"
  (require 'deferred)
  (let ((default-directory dir))
    (deferred:process
        "wget"
        ;; Disable Robots
        "-e" "robots=off"
        ;; Disable generation of host directories which might be nested
        "--no-host-directories"
        ;; Removes query parameters from media
        "--content-disposition"
        ;; Don't create directories
        "--no-directories"
        ;; Do not ascend to the parent
        "--no-parent"
        ;; Always download index as html file
        "--adjust-extension"
        ;; Enable spanning across hosts when doing recursive retrieving.
        "--span-hosts"
        ;; After the download is complete, convert the links in the document to make them suitable for local viewing.
        "--convert-links"
        ;; Download all files neccssary to view the page offline
        "--page-requisites"
        ;; These files are not neccessary for offline viewing and just cost space
        "-A" "jpeg,jpg,bmp,gif,png"
        url)))

(defun +org-web-tools|org-backup ()
  "Open the url under the cursor"
  (interactive)
  (require 'org-ml)
  (and-let* ((header (org-ml-parse-this-headline))
             (link (->> (org-offer-links-in-entry (current-buffer) (point) 0)
                        (car)
                        (substring-no-properties)
                        (-log)))
             (url (->> link
                       (+org/link-url-or-original)))
             (title (->> link
                         (+org/link-title-or-original)))
             (dir (+org-backup/create-directory url title))
             (file (f-join dir "article.org"))
             (entry (->> (org-web-tools--url-as-readable-org url)
                         ;; Remove more than one line break
                         (s-replace-regexp "\n\n\s*\n" "\n")
                         (s-replace-regexp "(https?://)?" "\n"))))
    (org-set-property "BACKUP" (template "[[<<file>>]]"))
    (save-window-excursion
      (switch-to-buffer url)
      (org-mode)
      (insert entry)
      (goto-char (point-min))
      (set-visited-file-name file)
      (save-buffer)
      (deferred:$
        (+org-backup/wget-images dir)))))

(defun +org-backup|relative-image-links ()
  "Convert links to relative image links."
  (interactive)
  (save-excursion
    (while (re-search-forward org-link-any-re nil t)
      (-some->> (substring-no-properties (thing-at-point 'line))
        (s-match "\\(https?\\)?\\(/.+\\)\\(/.*\\.\\)\\(png\\|jpg\\|jpeg\\|gif\\)")
        (-take-last 2)
        (s-join "")
        (s-prepend ".")
        ((lambda (x) (template "[[<<x>>]]\n")))
        ((lambda (x)
           (+my/delete-current-line)
           (insert x)
           x))))))
#+END_SRC
**** Send To Device

#+BEGIN_SRC elisp
(defvar +ebook:device-name nil
  "The name of the directory under which your reader is going to be mounted.")
(setq +ebook:device-name "tolino")

(defun +ebook/root-dir ()
  "Return the ebook reader directory or user-error."
  (let ((dir (f-join "/run/media" (user-login-name) +ebook:device-name)))
    (if (f-exists? dir)
        dir
      (user-error (template "Device <<+ebook:device-name>> is not mounted.")))))

(defun +ebook/books-dir ()
  "Books dir"
  (-some--> (+ebook/root-dir)
            (f-join it "Books")))

(defun +ebook/articles-dir ()
  "Article directory, create on if it doesnt exist."
  (-some--> (+ebook/books-dir)
            (f-join it "Articles")
            (f-mkdir it)))
#+END_SRC
*** Searching
**** Programming Docs

#+BEGIN_SRC elisp
(defun +org|search-programming-docs ()
  "Search my programming related notes"
  (interactive)
  (let ((entries)
        (buffers
         (->>
          '("Main/programming.org"
            "Main/system.org"
            "Main/emacs.org"
            "Work/docs.org")
          (+org/expand-org-file-name)
          (-append (f-entries (f-join org-directory "Docs")))
          (-flatten)
          (-map #'find-file-noselect))))
    (dolist (b buffers)
      (with-current-buffer b
        (setq entries
              (nconc entries
                     (counsel-outline-candidates
                      (cdr (assq 'org-mode counsel-outline-settings))
                      (counsel-org-goto-all--outline-path-prefix))))))
    (ivy-read "Goto: " entries
              :history 'counsel-org-goto-history
              :action #'counsel-org-goto-action
              :caller 'counsel-org-goto-all)))
#+END_SRC

**** Projects

#+BEGIN_SRC elisp
(defun +org|search-projects ()
  "Search my programming related notes"
  (interactive)
  (let ((entries)
        (buffers
         (->> '("Main/projects.org")
           (+org/expand-org-file-name)
           (-append (f-entries (f-join org-directory "Docs")))
           (-flatten)
           (-map #'find-file-noselect))))
    (dolist (b buffers)
      (with-current-buffer b
        (setq entries
              (nconc entries
                     (counsel-outline-candidates
                      (cdr (assq 'org-mode counsel-outline-settings))
                      (counsel-org-goto-all--outline-path-prefix))))))
    (ivy-read "Goto: " entries
              :history 'counsel-org-goto-history
              :action #'counsel-org-goto-action
              :caller 'counsel-org-goto-all)))
#+END_SRC

** Features

Stuff that doesn't belong into modules, but is too big to put into a simple util section.

*** Counsel Tagging Enhancement

Custom counsel tagging for org buffers and agenda buffers.

Functions taken from:
- [[file:~/.emacs.d/.local/straight/repos/swiper/counsel.el::defun counsel-org-tag-agenda (][swiper/counsel.el:counsel-org-tag-agenda]]
- [[file:~/.emacs.d/.local/straight/repos/swiper/counsel.el::defun counsel-org-tag (][swiper/counsel.el:counsel-org-tag]]

What I've changed:
- Always display ~org-tag-persistent-alist~ tags
- Always display all buffer tags

#+BEGIN_SRC elisp
(defun +org|counsel-org-tag (&optional from-agenda)
  "Add or remove tags in `org-mode'."
  (interactive)
  (save-excursion
    (if (eq major-mode 'org-agenda-mode)
        (if org-agenda-bulk-marked-entries
            (setq counsel-org-tags nil)
          (let ((hdmarker (or (org-get-at-bol 'org-hd-marker)
                              (org-agenda-error))))
            (with-current-buffer (marker-buffer hdmarker)
              (goto-char hdmarker)
              (setq counsel-org-tags (counsel--org-get-tags)))))
      (unless (org-at-heading-p)
        (org-back-to-heading t))
      (setq counsel-org-tags (counsel--org-get-tags)))
    (let ((org-last-tags-completion-table
           (append (and (or org-complete-tags-always-offer-all-agenda-tags
                            (eq major-mode 'org-agenda-mode))
                        (org-global-tags-completion-table
                         (org-agenda-files)))
                   org-tag-persistent-alist
                   org-tag-alist
                   (org-get-buffer-tags))))
      (ivy-read (counsel-org-tag-prompt)
                (lambda (str _pred _action)
                  (delete-dups
                   (all-completions str #'org-tags-completion-function)))
                :history 'org-tags-history
                :action #'counsel-org-tag-action
                :caller 'counsel-org-tag))))
#+END_SRC

*** Indirect Narrow Buffers

Open org tasks in an indirect popup that can be closed via =C-c C-c=.
The indirect buffer is narrowed to the current item.
This makes visiting org tasks much more focused, without having to widen the main buffer every time.

Known Issues:
- this popup blocks the =org-todo= popup
- The =C-c C-c= binding overrides the clocking binding

**** Config

#+BEGIN_SRC elisp
(set-popup-rule! "^\\*Org Indirect" :side 'bottom :size 0.35 :quit t :transient t :ttl t :select t :autosave)
#+END_SRC

**** Minor Mode

#+BEGIN_SRC elisp
(defvar +org-indirect:window-mode-map (make-sparse-keymap))

(define-minor-mode +org-indirect-window-mode
  "Open org headlines in an indirect window buffer."
  :keymap +org-indirect:window-mode-map)

(map! :map +org-indirect:window-mode-map
      "C-c C-c" #'+org-indirect/save-and-kill-window
      "C-c C-k" #'kill-buffer-and-window
      :localleader
      :desc "Show original" "+" #'+org-indirect/show-original)
#+END_SRC

**** Advices
***** Close window after refiling

#+BEGIN_SRC elisp :tangle no
(defadvice! +org/org-refile-close-indirect-window (&rest _)
  "Close indirect buffer windows after refiling them."
  :after '(org-refile)
  (when (+org-indirect-window-mode)
    (kill-buffer-and-window)))
#+END_SRC

**** Functions
***** Main

#+BEGIN_SRC elisp
(defun +org-indirect|narrow-subtree-indirect (&optional visit-fn goto-parent?)
  "Narrow to an indirect buffer in a popup."
  (interactive)
  ;; Cleanup old indirect buffers
  (kill-matching-buffers "^\\*Org Indirect.*" nil t)
  (let ((buffer
         (save-window-excursion
           (when visit-fn (funcall visit-fn))
           ;; Why do i need this message?
           (message "%s" (buffer-name))
           (clone-indirect-buffer
            (generate-new-buffer-name (template "*Org Indirect <<(buffer-name)>> "))
            nil))))
    (with-current-buffer buffer
      (widen)
      (setq header-line-format "Edit, then exit with 'C-c C-c', abort with 'C-c C-k'.")
      (save-excursion
        (when goto-parent?
          (+org|org-topmost-todo-element)
          ;; Show CHILDREN without content
          (org-global-cycle 4))
        (org-narrow-to-subtree))
      ;; When the item has subtrees show only the subtrees
      (if (save-excursion (search-forward-regexp "^\\*" nil t))
          (org-global-cycle 10)
        ;; Otherwise show contents but not the drawers
        (org-cycle 4))
      (+org-indirect-window-mode 1)
      (pop-to-buffer buffer)
      (rename-buffer (concat
                      (buffer-name)
                      (int-to-string (point-min))
                      (int-to-string (point-max))
                      "*"))
      (evil-forward-word-begin 1)
      buffer)))
#+END_SRC

***** Window Killing

#+BEGIN_SRC elisp
(defun +org-indirect/save-and-kill-window ()
  "Save the buffer and close the indirect buffer and window."
  (interactive)
  (save-buffer)
  (kill-buffer-and-window))

(defun +org-indirect/kill-buffer-maybe ()
  "Kill the window/buffer if it's indirect.
For example when archiving a task, there would be an empty window left over."
  (when (s-match "^\\*Org Indirect" (buffer-name))
    (kill-buffer-and-window)))
#+END_SRC

***** Show original

#+BEGIN_SRC elisp
(defun +org-indirect|show-original ()
  "Show the original buffer of the indirect window."
  (interactive)
  (doom/widen-indirectly-narrowed-buffer)
  (call-interactively #'+popup/raise)
  (+org-indirect-window-mode -1)
  (setq header-line-format nil)
  (call-interactively #'evil-scroll-line-to-center))
#+END_SRC

***** Visiting Functions

#+BEGIN_SRC elisp
(defun +org-indirect|clock-visit-entry (&optional arg)
  "Visit currently clocked org entry in a narrowed indirect buffer."
  (interactive "P")
  (let ((org-agenda-follow-indirect t))
    (+org-indirect|narrow-subtree-indirect #'org-clock-goto (not arg))))

(defun +org-indirect|agenda-visit-entry (arg)
  "Visit agenda entry in a narrowed indirect buffer."
  (interactive "P")
  (+org-indirect|narrow-subtree-indirect #'org-agenda-switch-to (not arg)))
#+END_SRC

***** Inserting New Items

I want to create items directly from the org agenda.
For this I will visit the current item, move to the header and add a new child at the bottom.

#+BEGIN_SRC elisp
(defun +org-indirect|add-entry ()
  (interactive)
  (with-current-buffer (+org-indirect|narrow-subtree-indirect #'org-agenda-switch-to t)
    (widen)
    (call-interactively #'+org/insert-item-below)
    (org-narrow-to-element)))
#+END_SRC

*** Subtask todo reset
:PROPERTIES:
:SOURCE:   [[https://github.com/jezcope/dotfiles/blob/master/emacs.d/lisp/org/org-subtask-reset.el][dotfiles/org-subtask-reset.el at master · jezcope/dotfiles]]
:END:

Reset nested todo properties when a task gets marked as done and it has the =:RESET_SUBTASKS:= property on it.
This is useful for repeating habit tasks, that have a list of todos that need to be done every time.

**** Config

#+BEGIN_SRC elisp
(after! org
  (setq org-default-properties (cons "RESET_SUBTASKS" org-default-properties)))
#+END_SRC

**** Autoloads
:PROPERTIES:
:header-args: :tangle "./autoload/+reset-subtask.el" :comments link :mkdirp yes
:END:

#+BEGIN_SRC elisp
(defun +org|reset-subtask-state-subtree ()
  "Reset all subtasks in an entry subtree."
  (interactive "*")
  (if (org-before-first-heading-p)
      (error "Not inside a tree")
    (save-excursion
      (save-restriction
        (org-narrow-to-subtree)
        (org-show-subtree)
        (goto-char (point-min))
        (beginning-of-line 2)
        (narrow-to-region (point) (point-max))
        (org-map-entries
         '(when (member (org-get-todo-state) org-done-keywords)
                (org-todo "TODO")))))))

(defun +org|reset-subtask-state-maybe ()
  "Reset all subtasks in an entry if the `RESET_SUBTASKS' property is set"
  (interactive "*")
  (if (org-entry-get (point) "RESET_SUBTASKS")
      (+org|reset-subtask-state-subtree)))

;;;###autoload
(defun +org/subtask-reset ()
  (-log org-state)
  (when (member org-state org-done-keywords) ;; org-state dynamically bound in org.el/org-todo
    (+org|reset-subtask-state-maybe)
    (org-update-statistics-cookies t)))

;;;###autoload
(add-hook 'org-after-todo-state-change-hook '+org/subtask-reset)
#+END_SRC

*** Add =:keep-windows= property to org babel
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/42096/running-elisp-within-an-orgmode-code-block][org mode - Running elisp within an orgmode code block - Emacs Stack Exchange]]
:END:

Org babel runs in a ~save-excursion~ function, so any spawned windows have to be manually accessed.
With the =:keep-windows= property we can disable this functionality.

#+BEGIN_SRC elisp
(defun transform-tree (tree trafo)
  "Transform TREE by TRAFO."
  (let ((next tree))
    (while next
      (let ((this next))
        (setq next (cdr next))
        (if (consp (car this))
            (transform-tree (car this) trafo)
          (funcall trafo this)))))
  tree)

(defun replace-in-fundef (fun sym &rest replacement)
  "In function FUN perform REPLACEMENT."
  (require 'ob-emacs-lisp)
  (setq fun (or
             (condition-case err
                 (let* ((pos (find-function-noselect fun t))
                        (buf (car pos))
                        (pt (cdr pos)))
                   (with-current-buffer buf
                     (save-excursion
                       (goto-char pt)
                       (read buf))))
               (error nil))
             (and (symbolp fun) (symbol-function fun))
             fun))
  (transform-tree fun
                  (lambda (this)
                    (when (eq (car this) sym)
                      (let ((copy-repl (cl-copy-list replacement)))
                        (setcdr (last copy-repl) (cdr this))
                        (setcdr this (cdr copy-repl))
                        (setcar this (car copy-repl)))))))

(defmacro save-window-excursion-if (pred &rest body)
  "Act like `save-window-excursion' if PRED is non-nil."
  (declare (indent 1) (debug t))
  (let ((c (make-symbol "wconfig")))
    `(let ((,c (and ,pred (current-window-configuration))))
       (unwind-protect (progn ,@body)
         (when ,c (set-window-configuration ,c))))))

(after! org
  (advice-remove 'org-babel-execute:emacs-lisp #'ad-org-babel-execute:emacs-lisp)
  ;; make sure we have access to the source code of `org-babel-execute:emacs-lisp'
  (find-function-noselect 'org-babel-execute:emacs-lisp t)
  ;; (defun ad-org-babel-execute:emacs-lisp ...):
  (eval (replace-in-fundef 'org-babel-execute:emacs-lisp 'org-babel-execute:emacs-lisp 'ad-org-babel-execute:emacs-lisp))
  ;; Use `save-window-excursion-if' in `ad-org-babel-execute:emacs-lisp':
  (declare-function 'ad-org-babel-execute:emacs-lisp " ")
  (eval (replace-in-fundef 'ad-org-babel-execute:emacs-lisp
                           'save-window-excursion 'save-window-excursion-if '(null (member (cdr (assoc :keep-windows params)) '("yes" "t")))))
  ;; Replace `org-babel-execute:emacs-lisp':
  (advice-add 'org-babel-execute:emacs-lisp :override #'ad-org-babel-execute:emacs-lisp))
#+END_SRC
*** Org Web Tools

#+BEGIN_SRC elisp
(defun +org-web-tools/dwim-at-point ()
  "Pass url to web tools from either:
1. An org link under the cursor
2. An url in the clipboard"
  (interactive)
  (let ((org-url (org-element-property :raw-link (org-element-context)))
        (clipboard-url (current-kill 0)))
    (if org-url
        (message "Reading org url from thing at point")
      (org-web-tools-read-url-as-org org-url)
      (if (string-match url-handler-regexp clipboard-url)
          (message "Reading org url from clipboard")
        (org-web-tools-read-url-as-org clipboard-url)
        (message "No url found")))))

(defun +org-web-tools/backup ()
  "Open the url under the cursor"
  (interactive)
  (let ((url (org-web-tools--read-url))))
  (org-web-tools-read-url-as-org))

(defun +org-web-tools/read-url-at-point ()
  "Open the url under the cursor"
  (interactive)
  (org-web-tools-read-url-as-org (org-web-tools--read-url)))

(defun +org-web-tools|read-url-from-chrome ()
  "Open the url under the cursor"
  (interactive)
  (->> (+wm/last-chrome-url)
       (org-web-tools-read-url-as-org))
  (visual-line-mode)
  (visual-fill-column-mode)
  (setq display-line-numbers nil))

(use-package! org-web-tools
  :after org
  :commands (+org-web-tools/read-url-at-point))
#+END_SRC

*** Archive Work Org Files in specific format

For work it makes more sense to keep a monthly file with all the tasks.
This way creating reports needs less processing power.

#+BEGIN_SRC elisp
(defun +org/month-archive-dir ()
  "Path for an monthly archive location to be used with org-archive-location."
  (interactive)
  (concat ".archive/%s_archive-" (format-time-string "%Y%m" (current-time)) ".org_archive::"))

(defadvice! +org/custom-archive-check (orig-fn &rest args)
  "Archive work org files on a monthly basis"
  :around '(org-archive-subtree
            +org|archive-done-tasks
            +org|visit-archive-file)
  (let ((path
         (cond
          ((buffer-base-buffer) (buffer-file-name (buffer-base-buffer)))
          ((string= (buffer-name) org-agenda-buffer-name)
           (-some->> (org-get-at-bol 'org-marker)
             (marker-buffer)
             (buffer-file-name)))
          (t buffer-file-name))))
    (if (f-ancestor-of? (f-join org-directory "Work") path)
        (let ((org-archive-location (+org/month-archive-dir)))
          (apply orig-fn args))
      (apply orig-fn args))))

#+END_SRC
*** Notifications

Copied from [[https://github.com/spegoraro/org-alert][spegoraro/org-alert: System notifications of org agenda items]].

#+BEGIN_SRC elisp

#+END_SRC

** Utils
*** Get Frontmost chrome url

#+BEGIN_SRC elisp
(defun +org/get-frontmost-chrome-url-raw ()
  "Get just the url for the frontmost chrome instance."
  (interactive)
  (--> (org-mac-chrome-get-frontmost-url)
       (s-match org-bracket-link-regexp it)
       (nth 1 it)))
#+END_SRC

*** Add source property from chrome

#+BEGIN_SRC elisp
(defun +org|source-properties-key-from-browser ()
  "Add the link from the frontmost chrome tab as a source property."
  (interactive)
  (org-set-property "SOURCE" (+wm/last-chrome-window-org-link)))
#+END_SRC

*** Add created date to new items

#+BEGIN_SRC elisp
(defun +org|add-created-property ()
  "Add CREATED property with the current time to the current item."
  (interactive)
  (org-set-property +org-created-property (+org/inactive-timestamp)))

(defun +org/add-created-property-automatically ()
  "Add CREATED property with the current time to the current item."
  (interactive)
  (let ((global-property (+org-get-global-property "ADD_CREATED")))
    (unless (string= global-property "nil")
      (when (+org-get-global-property "ADD_CREATED")
        (org-set-property +org-created-property (+org/inactive-timestamp))))))
#+END_SRC

And advice the function to the manual item creation functions:

#+BEGIN_SRC elisp
(advice-add '+org/insert-item-below :after (η #'+org/add-created-property-automatically))
(advice-add '+org/insert-item-above :after (η #'+org/add-created-property-automatically))
#+END_SRC

*** Archive all done tasks

#+BEGIN_SRC elisp
(defun +org|archive-done-tasks ()
  "Archive tasks with DONE or CANCELED todo state."
  (interactive)
  (let ((scope (if (eq (org-outline-level) 0)
                   'file
                 'tree)))
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq org-map-continue-from (outline-previous-heading)))
     "/+{|DONE|CANCELLED}" scope)))
#+END_SRC

*** Archive and Done

#+BEGIN_SRC elisp
(defun +org|archive-and-done ()
  "Mark task as done and archive."
  (interactive)
  (org-todo "DONE")
  (org-archive-subtree)
  (+org-indirect/kill-buffer-maybe))

(defun +org|agenda-archive-and-done ()
  "Mark agenda task as done and archive."
  (interactive)
  (org-agenda-todo "DONE")
  (org-agenda-archive)
  (+org/kill-indirect-buffer-maybe))
#+END_SRC

*** Copy block to clipboard

#+BEGIN_SRC elisp
(defun +org|copy-block ()
  "Copies the current block to clipboard."
  (interactive)
  (org-edit-src-code)
  (clipboard-kill-ring-save (point-min) (point-max)))
#+END_SRC

*** Export As Markdown

#+BEGIN_SRC elisp
(defun +org/copy-as-markdown (&optional subtree-p)
  "Copy the current subtree as markdown to clipboard."
  (let* ((org-export-with-toc nil)
         (org-export-with-special-strings nil)
         (org-export-with-smart-quotes nil)
         (md (org-export-as 'md nil subtree-p)))
    (kill-new md)
    (message "Copied buffer as markdown to clipboard.")))

(defun +org|copy-buffer-as-markdown ()
  "Copy the entire buffer as markdown to clipboard."
  (interactive)
  (+org/copy-as-markdown))

(defun +org|copy-subtree-as-markdown ()
  "Copy the subtree as markdown to clipboard."
  (interactive)
  (+org/copy-as-markdown t))
#+END_SRC

*** Paste Chrome Link Fix

Fixes wrong paste behavior where the link would be inserted directly on the character by adding a space

E.g.: (Brackets signal the cursor position)

: **[*]
: ***[]"

#+BEGIN_SRC elisp
(defun +org|paste-chrome-link ()
  "Paste the frontmost chrome link."
  (interactive)
  (insert (+wm/last-chrome-window-org-link)))
#+END_SRC

*** Paste Markdown as org

#+BEGIN_SRC elisp
(defun +org|paste-markdown-as-org ()
  "Convert the current clipboard to markdown."
  (interactive)
  (save-excursion
    (let ((select-enable-clipboard t)
          (file (->> (make-temp-file "markdown-content")
                     (--tap (f-write (current-kill 0) 'utf-8 it)))))
      (->> (shell-command-to-string (template "cat <<file>> | pandoc -f markdown -t org"))
           (s-trim)
           (insert)))))
#+END_SRC

*** Schedule Tomorrow
:PROPERTIES:
:SOURCE:   [[https://github.com/xandeer/.doom/blob/master/modules/private/xandeer/+org.el][.doom/+org.el at master · xandeer/.doom]]
:END:

#+BEGIN_SRC elisp
(defun +org|schedule-tomorrow ()
  "Return scheduled string on tomorrow."
  (format-time-string "SCHEDULED: <%F %a>"
                      (time-add (current-time) (* 24 3600))))
#+END_SRC

*** Sort org entries

#+BEGIN_SRC elisp
(defun +org|sort-entries ()
  "Go to header and sort entries."
  (interactive)
  (org-up-element)
  (org-sort)
  (org-shifttab)
  (org-cycle))
#+END_SRC

*** Visit archive file

#+BEGIN_SRC elisp
(defun +org|visit-archive-file ()
  (interactive)
  (let ((archive-filename (car (org-archive--compute-location org-archive-location))))
    (find-file archive-filename)
    (end-of-buffer)))
#+END_SRC

*** Align all tags

#+BEGIN_SRC elisp
(defun +org|align-all-tags ()
  "Interactive version of org-align-all-tags."
  (interactive)
  (org-align-tags t))
#+END_SRC

*** Org get chrome tab formatted

The Github Review Title is very long,
shorten it a bit for the org capture templates.

#+BEGIN_SRC elisp
(defun +github/just-pr-title (title)
  (car (s-split " · " title)))

(defun +org/mac-chrome-get-frontmost-url-custom-format ()
  "Adaption for org-as-mac-chrome-get-frontmost-url."
    (--> (org-as-mac-chrome-get-frontmost-url)
         (s-split "::split::" it)
         (pcase it
           ((pred (s-contains? "github.com" (-first-item it)))
            (-update-at (- (length it) 1)
                        #'+github/just-pr-title
                        it))
           (_ it))
         (s-join "::split::" it)
         (org-mac-paste-applescript-links it)))
#+END_SRC

*** Custom Agenda Compare

Sort my agenda entries by a ~DATE_CREATED~ property.

#+BEGIN_SRC elisp
(setq-default +org-created-property "CREATED")
#+END_SRC

#+BEGIN_SRC elisp
(defun +org|compare-created-date-property (a b)
  "Compare two `org-mode' agenda entries, `A' and `B', by the \"CREATED\" property."
  (let* ((a-pos (get-text-property 0 'org-marker a))
         (b-pos (get-text-property 0 'org-marker b))
         (a-date (or (org-entry-get a-pos +org-created-property)
                     (format "<%s>" (org-read-date t nil "now"))))
         (b-date (or (org-entry-get b-pos +org-created-property)
                     (format "<%s>" (org-read-date t nil "now"))))
         (cmp (compare-strings a-date nil nil b-date nil nil)))
    (if (eq cmp t) nil (cl-signum cmp))))
#+END_SRC

*** Search in notes

#+BEGIN_SRC elisp
(after! ivy
  (ivy-set-actions
   '+org|search-in-notes
   '(("j" counsel-notes-find-file-other-window "open in other window"))))

(defun +org|search-in-notes ()
  "Search in the org directory for a file.
Projectile search is not fast reliable enough."
  (interactive)
  (counsel-notes-jump))

(defun counsel-notes-find-file (x)
  "Function docstring"
  (interactive)
  (with-ivy-window
    (let ((default-directory (ivy-state-directory ivy-last)))
      (find-file (expand-file-name x))
      (+workspaces-add-current-buffer-h))))

(defun counsel-notes-find-file-other-window (x)
  (split-window nil nil 'right)
  (counsel-notes-find-file x))

(defun +org/counsel-notes-jump:files ()
  "Function docstring"
  (interactive)
  (--> '("Main" "Work")
       (--map (f-join org-directory it) it)
       (-map 'f-files it)
       -flatten
       (--map (s-replace (concat (expand-file-name org-directory) "/") "" it) it)))

(defun counsel-notes-jump ()
  "Jump to a file in your notes and call org-goto right-away."
  (interactive)
  (counsel-require-program find-program)
  (let ((default-directory org-directory))
    (ivy-read "Find directory: "
              (+org/counsel-notes-jump:files)
              :matcher #'counsel--find-file-matcher
              :action #'counsel-notes-find-file
              :history 'file-name-history
              :keymap counsel-find-file-map
              :caller 'counsel-dired-jump)))
#+END_SRC

*** Visual Fill Column

#+BEGIN_SRC elisp
(defun +org|toggle-visual-wrap (&optional center?)
  "Toggle text wrapping for org buffers."
  (interactive)
  (let ((visual-fill-column-center-text (or center? nil)))
    (if (bound-and-true-p visual-line-mode)
        (progn
          (visual-line-mode -1)
          (visual-fill-column-mode -1))
      (progn
        (visual-line-mode)
        (visual-fill-column-mode)))))
#+END_SRC

*** Agenda Cut Entry

#+BEGIN_SRC elisp
(defun +org|agenda-cut-entry ()
  "Cut entry straight from agenda."
  (interactive)
  (save-window-excursion
    (org-agenda-switch-to)
    (org-cut-subtree))
  (org-agenda-redo))
#+END_SRC

*** Agenda Change Link

#+BEGIN_SRC elisp
(defun +org|agenda-change-link ()
  "Change a link in the title from the org agenda."
  (interactive)
  (save-window-excursion
    (org-agenda-switch-to)
    (when (search-forward "[[" (point-at-eol) t)
      (call-interactively #'org-insert-link))
    (org-agenda-redo)))
#+END_SRC

*** Move to shopping list

Moves a todo item from the agenda to the shopping list as a list item.

#+BEGIN_SRC elisp
(defun +org|agenda-move-to-shopping-list ()
  "Function docstring"
  (interactive)
  (save-window-excursion
    (save-excursion
      (let ((title (nth 1 (s-match "^.*TODO \\(.*\\)$" (thing-at-point 'line t))))
            (buffer (find-file +org:shopping-list-file)))
        (with-current-buffer buffer
          (org-narrow-to-subtree)
          (goto-char (point-max))
          (insert (template "\n- [ ] <<title>>"))
          (org-update-checkbox-count t)
          (save-buffer)))))
  (+org|agenda-archive-and-done))
#+END_SRC
*** Export named table
:PROPERTIES:
:SOURCE:   [[https://emacs.stackexchange.com/questions/16640/can-i-export-a-specific-table-in-an-org-file-to-csv-from-the-command-line][org mode - Can I export a specific table in an org file to csv from the command line? - Emacs Stack Exchange]]
:END:

#+BEGIN_SRC elisp
(defun +org|export-named-table (name &optional dir)
  "Export table in org document with NAME property to a DIR.
Return the path of the file."
  (interactive)
  (show-all)
  (let ((case-fold-search t))
    (save-excursion
      (goto-char (point-min))
      (if (search-forward-regexp (concat "#\\+NAME: +" name) nil t)
          (progn
            (next-line)
            (let ((filename (file-truename (f-join (or dir "./") (format "%s.csv" name)))))
              (org-table-export filename "orgtbl-to-csv")
              filename))))))
#+END_SRC

*** Refile Helpers
:PROPERTIES:
:SOURCE:   [[https://mollermara.com/blog/Fast-refiling-in-org-mode-with-hydras/][Fast refiling in org-mode with hydras | Josh Moller-Mara]]
:END:

#+BEGIN_SRC elisp
(defun +org/refile (file headline &optional arg)
  (let* ((file (+org/expand-org-file-name file))
         (pos (save-excursion
                (find-file file)
                (org-find-exact-headline-in-buffer headline))))
    (org-refile arg nil (list headline file nil pos))))

(defun +org/agenda-refile (file headline &optional arg)
  (save-window-excursion
    (let* ((file (+org/expand-org-file-name file))
           (pos (save-excursion
                  (find-file file)
                  (org-find-exact-headline-in-buffer headline))))
      (org-agenda-refile arg (list headline file nil pos) t))))
#+END_SRC

*** Cut Link

#+BEGIN_SRC elisp
(defun +org|cut-link ()
  "Remove the item under the cursor but copy the link."
  (interactive)
  (require 'org-ml)
  (let ((link (->> (org-ml-parse-this-headline)
                   (org-ml-get-property :raw-value))))
    (org-cut-subtree)
    (kill-new link)))
#+END_SRC

*** Filter agenda

#+BEGIN_SRC elisp
(defun +org/agenda-set-tag-filter (tags)
  "Set the agenda TAGS filter."
  (org-agenda-filter-show-all-tag)
  (setq org-agenda-tag-filter tags)
  (org-agenda-filter-apply org-agenda-tag-filter 'tag t))
#+END_SRC

*** Show unestimated items backlog

#+BEGIN_SRC elisp
(defun +org|agenda-filter-unestimated ()
  "Filter for unestimated items in the backlog agenda."
  (interactive)
  (setq-local org-agenda-tag-filter '("-LOW_EFFORT" "-MEDIUM_EFFORT" "-HIGH_EFFORT"))
  (org-agenda-filter-apply org-agenda-tag-filter 'tag t))
#+END_SRC

*** Attach File

#+BEGIN_SRC elisp
(defun +org|attach-file (x)
  "Attach a file and insert the link."
  (interactive "P")
  (->>
   (or x (let ((default-directory downloads-dir))
           (flet ((counsel-find-file-action (identity)))
             (counsel-find-file))))
   (+org/attach-file-and-insert-link)))
#+END_SRC
*** Insert Checkbox

#+BEGIN_SRC elisp
 (defun +org|toggle-checkbox ()
  (interactive)
  (org-toggle-radio-button '(4)))
#+END_SRC
*** Insert links for all attachments

Attach files from dired via ~org-attach-dired-to-subtree~

#+begin_src elisp
(defun +org|attach-dir-files ()
  "Take all entries from the current attachment id directory and insert them."
  (interactive)
  (->> (org-attach-dir-get-create)
    (f-entries)
    (--map (template "[[attachment:<<(f-filename it)>>]]"))
    (--reduce-from (concat acc "\n\n" it) "")
    (insert)))
#+end_src

** Package Config
*** Org Alert

#+BEGIN_SRC elisp
(use-package! org-alert
  :after org
  :config
  (setq org-alert-headline-regexp "\\(Sched.+:.+\\|Sched:.+\\):NOTIFY_ME:.*$"))

(use-package! alert
  :config
  (if (executable-find "notify-send")
      (setq alert-default-style 'libnotify)))
#+END_SRC

**** Custom headline checker

Bit of a dumb function...
But hey, the whole agenda parsing for times is kinda simple, right?
But if it works...

Overwrite ~org-alert~ headline checker to show notifications only when:
- Any upcoming items that have the ~:NOTIFY_ME:~ tag.
- Has a time range in the next 15 minutes
- Has not notified me already (is not in ~+org-alert:seen-notifications~ cache)

#+BEGIN_SRC elisp :tangle no
(defvar +org-alert:seen-notifications '())

(defvar +org-alert:alert-range-seconds 600)
(setq +org-alert:alert-range-seconds (* 15 60))

(defun +org-alert/agenda-parse-time-string (str)
  "Parse an org agenda line STR for the hours and minutes."
  (-when-let ((_ hh mm)
              (s-match "^ \\([0-9][0-9]\\):\\([0-9][0-9]\\).*" str))
    (list (string-to-number hh) (string-to-number mm))))

(defun +org-alert/agenda-str-seconds-until (str)
  (-when-let* (((hh mm) (+org-alert/agenda-parse-time-string str))
               (now (ts-now))
               (then (ts-apply :hour hh
                               :minute mm
                               :second 0
                               now)))
    (when (ts> then now)
      (ts-difference then now))))

(defun +org-alert/reset-buffer-names ()
  (let ((prev-org-agenda-buffer-name org-agenda-buffer-name)
        (prev-org-agenda-this-buffer-name org-agenda-this-buffer-name))))

(defun org-alert--get-headlines ()
  "Return the current org agenda as text only."
  ;; Cache buffer name, when setting org-agenda-buffer-tmp-name org-agenda saves it
  ;; Which leads to a faulty buffer name for any following agenda buffers
  ;; So we reset it after calling the agenda
  (let ((prev-org-agenda-buffer-name org-agenda-buffer-name)
        (str
         (with-temp-buffer
           (let ((org-agenda-sticky nil)
                 (org-agenda-buffer-tmp-name (buffer-name)))
             (ignore-errors
               (let ((org-agenda-files (+org/expand-org-file-name '("Main/inbox.org" "Work/work.org")))
                     (org-agenda-tag-filter-preset '("+NOTIFY_ME"))
                     (org-agenda-start-day nil)
                     (org-agenda-prefix-format
                      '((agenda  . " %?-12t% s"))))
                 (org-agenda-list 1)))
             (->>
              (buffer-substring-no-properties (point-min) (point-max))
              (s-split "\n")
              (-map #'s-collapse-whitespace)
              (--filter (or (-some->> (+org-alert/agenda-str-seconds-until it)
                              (> +org-alert:alert-range-seconds))))
              ((lambda (xs)
                 (let ((to-alert (-difference xs +org-alert:seen-notifications)))
                   (setq +org-alert:seen-notifications (-concat +org-alert:seen-notifications to-alert))
                   (kill-buffer org-agenda-buffer-tmp-name)
                   to-alert))))))))
    (setq org-agenda-buffer-name prev-org-agenda-buffer-name)
    (setq org-agenda-this-buffer-name prev-org-agenda-buffer-name)
    str))
#+END_SRC

*** Org Download

#+BEGIN_SRC elisp
(setq org-download-screenshot-method "flameshot gui --raw > %s")
#+END_SRC

**** Download image from clipboard

#+BEGIN_SRC elisp
(defun +org|attach-yank-image ()
  "Instert the image from the clipboard as an attachment."
  (interactive)
  (let ((path (concat (make-temp-file "screenshot") ".png")))
    (shell-command-to-string (t! "xclip -selection clipboard -target image/png -out > <<path>>"))
    (+org/attach-file-and-insert-link path)))

(defun +org-attach|dwim ()
  "Function docstring"
  (interactive)
  (let ((targets
         (->> (shell-command-to-string "xclip -selection clipboard -t TARGETS -o")
           (s-trim)
           (s-split "\n"))))
    (cond ((--find (s-contains? "image/png" it) targets)
           (+org|attach-yank-image))
          (t (let* ((timeout "timeout 0.05") ;; Wrap command in timeout to prevent emacs from freezing when xclip hangs
                    (txt (shell-command-to-string (t! "<<timeout>> xclip -o -selection clipboard"))))
               (cond ((or (string= "End of file during parsing" txt)
                          (string= "" txt))
                      (-log "xclip timed out"))
                     ((s-matches-p url-handler-regexp txt)
                      (+org/attach-file-and-insert-link txt))
                    (t (user-error "Could not save clipboard contents:\n%s" txt))))))))
#+END_SRC

*** Roam
**** Config

#+BEGIN_SRC elisp
(setq org-roam-directory (+org/expand-org-file-name "Roam"))
#+END_SRC

**** Journal

#+BEGIN_SRC elisp
(use-package! org-journal
  :config
  (setq org-journal-dir (+org/expand-org-file-name "Roam"))
  (setq org-journal-date-prefix "#+TITLE: ")
  (setq org-journal-file-format "%Y-%m-%d.org")
  (setq org-journal-date-format "%A, %d %B %Y")
  (setq org-journal-enable-agenda-integration t))
#+END_SRC

***** Private Journal

My private journal with personal thoughts and notes.
This will be encrypted and in a different directory than org-roam.

#+BEGIN_SRC elisp
(defvar +private-journal:dir nil
  "Location of the private journal.")
(setq +private-journal:dir (+org/expand-org-file-name "Journal"))

(defun +private-journal|new-entry ()
  "Create a new private journal entry file."
  (interactive)
  (let ((org-journal-encrypt-journal t)
        (org-journal-dir +private-journal:dir))
      (call-interactively #'org-journal-new-entry)
      (setq-local epa-file-encrypt-to +my:gpg-simple-key)))
#+END_SRC

*** Org Caldav

Calendar management using org mode and [[https://github.com/dengste/org-caldav][org-caldav]].

To sync the calendars use ~org-caldav-sync~.

**** Utils

***** Remove and sync

#+BEGIN_SRC elisp
(defun +caldav|remove-and-sync ()
  "The one way sync doesn't update entries that have been deleted/moved.
So I make sure to remove all caldav files and just do a fresh sync."
  (interactive)
  (require 'org-caldav)
  (setq org-caldav-sync-result nil)
  (ignore-errors (f-delete org-caldav-backup-file))

  ;; Empty the caldav file
  (save-excursion
    (find-file (car org-caldav-files))
    (goto-line 5)
    (delete-region (point) (point-max))
    (save-buffer (current-buffer))
    (kill-buffer (current-buffer)))

  ;; Remove cache files
  (-some->> (f-entries org-caldav-save-directory)
    (--find (s-contains? "org-caldav" (f-filename it)))
    (f-delete))

  (let ((org-caldav-debug-level 0))
    (org-caldav-sync)

    ;; Remove the result buffer
    (kill-buffer (get-buffer "*org caldav sync result*"))))
#+END_SRC

**** Config

#+BEGIN_SRC elisp
(use-package! org-caldav
  :after org
  :commands (org-caldav-sync)
  :config
  ;; org-caldav-url is set in secrets.el
  (setq org-caldav-calendar-id "family"
        org-caldav-inbox (f-join org-directory "Main/calendar-family.org")
        org-caldav-save-directory doom-cache-dir
        org-caldav-sync-direction 'cal->org
        org-icalendar-timezone "Europe/Berlin")
  (setq org-caldav-files (list org-caldav-inbox)))
#+END_SRC

*** Org QL

#+BEGIN_SRC elisp
(use-package! org-ql
  :commands (org-ql-search))
#+END_SRC

*** Org SuperAgenda
**** Config

#+BEGIN_SRC elisp
(use-package! org-super-agenda
  :after org
  :config
  (org-super-agenda-mode 1)
  ;; Disable org-super-agenda keymap which breaks evil mappings
  (setq org-super-agenda-header-map (make-sparse-keymap)))
#+END_SRC

**** Utils
***** Move between super agenda sections

#+BEGIN_SRC elisp
(defun +org-agenda/goto-super-agenda-group (forward?)
  "Move the cursor to a super agenda group."
  (let ((is-at-agenda-header
         (lambda () (eq (get-text-property (point) 'face) 'org-super-agenda-header)))
        (line-move-fn (if forward? #'next-line #'previous-line))
        (char-move-fn (if forward? #'forward-char #'backward-char)))

    ;; When the cursor is on a group already
    (if (funcall is-at-agenda-header)
        (funcall line-move-fn))

    ;; Special case for moving backward
    ;; Since moving backward would just stop at the current header
    (if (and (not forward?) (not (funcall is-at-agenda-header)))
        (progn
          (while (not (funcall is-at-agenda-header))
            (backward-char))
          (previous-line)
          (previous-line)))

    ;; Find the next header
    (while (not (funcall is-at-agenda-header))
      (funcall char-move-fn))

    ;; Move below the header to the first item
    (if (funcall is-at-agenda-header)
        (progn
          (next-line)
          (beginning-of-line)
          (back-to-indentation)))))

(defun +org-agenda|next-super-agenda-group ()
  "Move the cursor to the next super agenda group."
  (interactive)
  (+org-agenda/goto-super-agenda-group t))

(defun +org-agenda|prev-super-agenda-group ()
  "Move the cursor to the previous super agenda group."
  (interactive)
  (+org-agenda/goto-super-agenda-group nil))
#+END_SRC

*** Org Media Info

#+BEGIN_SRC elisp
(use-package! org-media-info
  :commands (org-media-insert-book org-media-insert-book-german))
#+END_SRC

*** Org Noter & PDF
**** Config

#+BEGIN_SRC elisp
(use-package! org-noter
  :commands (org-noter)
  :config
  (setq org-noter-always-create-frame nil)
  (setq org-noter-kill-frame-at-session-end nil))
#+END_SRC

**** Utils
***** Go to org-noter location

#+BEGIN_SRC elisp
(defun +org-noter|goto ()
  (interactive)
  (select-window (org-noter--get-notes-window))
  (counsel-org-goto)
  (org-noter-sync-current-note))
#+END_SRC

***** Flip between pages

#+BEGIN_SRC elisp :tangle no
;; (defcustom +pdf-flip-pages nil
;;   "Pageset"
;;   :type 'list)

;; (defun +pdf|flip-between ()
;;   (let ((current-page (pdf-view-current-page))))

;;   (cond ((eq +pdf-flip-pages)))
;;   (if +pdf-flip-pages)

;;   (let (())
;;     (pdf-history-backward)
;;     (setq +pdf-flip-pages (list (pdf-view-current-page) current-page))))
#+END_SRC

**** Bindings

#+BEGIN_SRC elisp
(map! :map pdf-view-mode-map
      :n "C-o" #'pdf-history-backward)

(map! :map (org-noter-doc-mode-map org-noter-doc-mode-map)
      :localleader
      :desc "Next Note" "g" #'+org-noter|goto
      :desc "Next Note" "n" #'org-noter-sync-next-note
      :desc "Next Note" "k" #'org-noter-sync-next-note
      :desc "Next Note" "p" #'org-noter-sync-prev-note
      :desc "Next Note" "j" #'org-noter-sync-prev-note)
#+END_SRC
*** Org Download

Copy screenshots from the clipboard to an attachment.

**** Config

Set my preferred clipboard paste method to ~xclip~.

#+BEGIN_SRC elisp
(setq org-download-screenshot-method "xclip -selection clipboard -t image/png -o > %s")
#+END_SRC
*** Counsel Org Clock

#+BEGIN_SRC elisp
(use-package! counsel-org-clock
  :after org)
#+END_SRC

** Bindings
*** Mode Bindings
**** Org Mode

#+BEGIN_SRC elisp
(map! :g "s-X" #'+org-capture/open-frame)

(map! :map evil-org-mode-map
 :mn "gH"    #'+org|org-topmost-todo-element
 :n "C-c C-l" (cmd! (+evil-org/normal-mode-paste-fix #'org-insert-link)))

(map! :map org-mode-map
      :gni [s-return]    #'+org/insert-item-below
      :gni [s-S-return]  #'+org/insert-item-above
      :n "M-k"           #'org-metaup
      :n "M-j"           #'org-metadown)
#+END_SRC

**** Agenda

#+BEGIN_SRC elisp
(map! :after evil-org-agenda
      :map evil-org-agenda-mode-map
      :m "RET"    #'+org-indirect|agenda-visit-entry
      :m [return] #'+org-indirect|agenda-visit-entry
      :m "K"      #'+org-agenda|prev-super-agenda-group
      :m "J"      #'+org-agenda|next-super-agenda-group
      :m "da"     #'org-agenda-archive
      :m "dA"     #'+org|agenda-archive-and-done)

(map! :map org-agenda-mode-map
      :m "C-c C-l" #'+org|agenda-change-link)
#+END_SRC

*** Leader Bindings

#+BEGIN_SRC elisp
(map!
 :leader
 (:prefix-map ("t" . "Toggle")
  :desc "Visal Fill Column"          "o" #'+org|toggle-visual-wrap
  :desc "Visal Fill Column (Center)" "O" (cmd! (+org|toggle-visual-wrap)))

 (:prefix-map ("n" . "Notes")
  :desc "Save All Org Buffers"       "S" #'org-save-all-org-buffers
  :desc "Save All Org Buffers"       "s" #'+default/org-notes-search
  :desc "Search"                     "f" #'+org|search
  :desc "Find in notes"              "n" #'+org|search-in-notes
  :desc "Agenda"                     "a" #'org-agenda
  :desc "Store Link"                 "y" #'org-store-link
  :desc "Store Link"                 "j" #'+private-journal|new-entry
  :desc "Visit Entry"              "SPC" #'+org-indirect|clock-visit-entry
  :desc "Docs"                       "d" #'+org|search-programming-docs
  :desc "Projects"                   "p" #'+org|search-projects

  (:prefix-map ("b" . "Bookmarks")
   :desc "Goto Bookmarks File"       "b" (cmd! (find-file +org:bookmarks-file))
   :desc "Search bookmarks"          "s" #'helm-org-pinboard)

  (:prefix-map ("r" . "Roam")
   ;; Create journal entry, but dont open roam link popup
   :desc "Journal: New Entry" "j"     (cmd! (let ((+org-roam-open-buffer-on-find-file nil))
                                              (call-interactively #'org-journal-new-entry)))
   :desc "List (Main)" "l" #'org-roam
   :desc "Insert" "i" (cmd! (+evil-org/normal-mode-paste-fix #'org-roam-insert))
   :desc "Switch to Buffer" "b" #'org-roam-switch-to-buffer
   :desc "Find File" "f" #'org-roam-find-file
   :desc "Show Graph" "g" #'org-roam-show-graph
   :desc "Capture" "c" #'org-roam-capture)

  ;; special goto locations I often visit
  :desc "Inbox"                      "i" (cmd! (+org/find-in-files "Main/inbox.org"))
  :desc "Work"                       "w" (cmd! (+org/find-in-files "Work/work.org"))

  (:prefix-map ("g" . "Goto")
   :desc "Goto Bookmarks File"       "b" (cmd! (find-file +org:bookmarks-file))
   :desc "Inbox"                     "i" (cmd! (+org/find-in-files "Main/inbox.org"))
   :desc "Work"                      "w" (cmd! (+org/find-in-files "Work/work.org"))
   :desc "Inbox"                     "i" (cmd! (+org/find-in-files "Main/inbox.org"))
   :desc "Projects"                  "p" (cmd! (+org/find-in-files "Main/projects.org"))
   :desc "Shoppinglist"              "s" (cmd! (+org/find-in-files "Main/shoppinglist.org"))
   :desc "Capture Last Stored"       "c" #'org-capture-goto-last-stored
   :desc "Refile Last Stored"        "r" #'org-refile-goto-last-stored)

  (:prefix-map ("c" . "clock")
   :desc "Timestamp Down"           "-"   #'org-clock-timestamps-down
   :desc "Timestamp Up"             "="   #'org-clock-timestamps-up
   :desc "Clock Out"                "C"   #'org-clock-out
   :desc "Goto Select"              "G"   (cmd! (org-clock-goto 'select))
   :desc "Clock In"                 "c"   #'org-clock-in
   :desc "Mark Default Task"        "d"   #'org-clock-mark-default-task
   :desc "Modify Effort Estimate"   "e"   #'org-clock-modify-effort-estimate
   :desc "Goto Current"             "g"   #'counsel-org-clock-history
   :desc "Resolve"                  "r"   #'org-resolve-clocks
   :desc "Clock In Last"            "l"   #'org-clock-in-last
   :desc "Clock In Last"            "o"   #'+org|clocked-visit-link
   :desc "Cancel"                   "x"   #'org-clock-cancel
   :desc "Visit Entry"              "SPC" #'+org-indirect|clock-visit-entry
   :desc "Visit Entry"              "'"   #'+org-indirect|clock-visit-entry)

  (:prefix-map ("q" . "Query")
   (:prefix-map ("w" . "Work")
    :desc "Projects: Work"            "w" #'+org-ql|work-projects
    :desc "Projects: Work"            "s" #'+org|work-search)
   :desc "Projects: Personal"        "p" #'+org-ql|projects)))
#+END_SRC
*** Local Leader
**** Org Mode

#+BEGIN_SRC elisp
(map! :map org-mode-map
      :localleader
      :desc  "Goto Archive"              "$"  #'+org|visit-archive-file
      :desc  "Align Tags"                "%"  #'+org|align-all-tags
      :desc  "Schedule Tomorrow"         "+"  #'+org|schedule-tomorrow
      :desc  "Archive Subtree and Done"  "A"  #'+org|archive-and-done
      :desc  "Grab tabs"                 "P"  #'+org|grab-chrome-tabs
      :desc  "Paste Subtree"             "P"  #'org-paste-subtree
      :desc  "Sort Entries"              "S"  #'+org|sort-entries
      :desc  "Archive Subtree"           "a"  #'org-archive-subtree
      :desc  "Deadline"                  "d"  #'org-deadline
      :desc  "Filter"                    "f"  #'org-match-sparse-tree
      :desc  "Set source key to tab"     "k"  #'+org|source-properties-key-from-browser
      :desc  "Set created property"      "K"  #'+org|add-created-property
      :desc  "Create/Edit Todo"          "o"  #'org-todo
      :desc  "Paste Chrome Link"         "p"  (cmd! (+evil-org/normal-mode-paste-fix #'+org|paste-chrome-link))
      :desc  "Tag heading"               "q"  #'+org|counsel-org-tag
      :desc  "Schedule"                  "s"  #'org-schedule
      :desc  "Tag heading"               "t"  #'+org|counsel-org-tag
      :desc  "MPV Link at point"         "v"  #'+org|mpv-link-at-point
      :desc  "Copy Buffer To Markdown"   "Y"  #'+org|copy-buffer-as-markdown

      (:prefix-map ("y" . "Yank")
       :desc "Link" "l" #'+org|copy-entire-link
       :desc "Url" "u" #'+org|copy-link-url
       :desc "Title" "t" #'+org|copy-link-title)

      (:prefix-map ("C" . "Cut")
       :desc "Item" "C" 'org-cut-subtree
       :desc "Link" "L" '+org|cut-link)

      (:prefix-map ("i" . "Insert")
       :desc "Attachment"         "a" #'+org|attach-file
       :desc "Inavtive Timestamp" "i" (cmd! (+evil-org/normal-mode-paste-fix #'org-time-stamp-inactive))
       :desc "Subheadeing"        "s" (cmd!
                                       (call-interactively 'org-insert-subheading)
                                       (evil-insert-state)))

      (:prefix-map ("g" . "Goto")
       :desc "Org Web Link" "l" #'+org-web-tools/read-url-at-point)

      (:prefix-map ("n" . "Narrow")
       :desc "Block"                "b" #'org-narrow-to-block
       :desc "Element"              "e" #'org-narrow-to-element
       :desc "Indirect Buffer Tree" "i" #'org-tree-to-indirect-buffer
       :desc "Subtree"              "s" #'org-narrow-to-subtree
       :desc "widen"                "w" #'widen)

      (:prefix-map ("w" . "Refile")
       :desc "Dynamic"            "w" 'org-refile
       :desc "Pinboard"           "p" '+org|refile-to-bookmarks
       :desc "To GTD Backlog"     "b" (cmd! (+org/refile "Main/gtd.org" "Backlog"))
       :desc "To GTD"             "g" (cmd! (+org/refile "Main/gtd.org" "GTD"))))
#+END_SRC

**** Agenda

#+BEGIN_SRC elisp
(map! :after org-agenda
      :map org-agenda-mode-map
      :localleader
      "q" #'+org|counsel-org-tag
      "v" #'+org|mpv-link-at-point
      "." #'counsel-org-agenda-headlines
      "t" nil ; Overwrite doom binding
      (:prefix ("t" . "toggle")
       :desc "Time Grid"           "t" #'org-agenda-toggle-time-grid)
      (:prefix ("f" . "Filter by")
       :desc "Tasks"               "t" (cmd! (+org/agenda-set-tag-filter '("+TASK")))
       :desc "Reviews"             "r" (cmd! (+org/agenda-set-tag-filter '("+REVIEW"))))
      (:prefix ("w" . "Refile")
       :desc "Dynamic"            "w" 'org-agenda-refile
       :desc "Pinboard"           "p" '+org|agenda-refile-to-bookmarks
       :desc "To GTD Backlog"     "b" (cmd! (+org/agenda-refile "Main/gtd.org" "Backlog"))
       :desc "To GTD"             "g" (cmd! (+org/agenda-refile "Main/gtd.org" "GTD"))
       :desc "To Reading List"    "r" (cmd! (+org/agenda-refile "Main/reading-list.org" "Reading List"))
       :desc "To shoppping list"  "s" (cmd! (+org/agenda-refile "Main/shoppinglist.org" "Supermarket"))
       :desc "To Work"            "W" (cmd! (+org/agenda-refile "Work/work.org" "GTD"))))
#+END_SRC

#+RESULTS:

*** Fixes
**** Link text object

#+BEGIN_SRC elisp
(evil-define-text-object +evil/textobj-inner-link
  (count &optional beg end type)
  "Select the closest outer quote."
  (let ((evil-textobj-anyblock-blocks
         '(("\\[\\]" . "\\]\\]"))))
    (evil-textobj-anyblock--make-textobj beg end type count nil)))

(evil-define-text-object +evil/textobj-around-link
  (count &optional beg end type)
  "Select the closest outer quote."
  (let ((evil-textobj-anyblock-blocks
         '(("\\[\\[" . "\\]\\]"))))
    (evil-textobj-anyblock--make-textobj beg end type count t)))

(evil-define-minor-mode-key '(operator visual) 'evil-org-mode
  "il" '+evil/textobj-inner-link)
(evil-define-minor-mode-key '(operator visual) 'evil-org-mode
  "al" '+evil/textobj-around-link)
#+END_SRC


**** Normal Mode Fixes

When I'm in insert mode I want the cursor to behave as if I'm in insert on the next character.
Also special fixes for pasting links and similar things, to automatically insert a space.
Unless I'm looking at a link, than continue like common.

#+BEGIN_SRC elisp
(defun +evil-org/normal-mode-paste-fix (fn)
  "Move forward one character and then paste."
  (cond ((not (evil-normal-state-p))
         (call-interactively fn))
        ((assoc :link (org-context))
         (call-interactively fn))
        ((and (eq (+ (point) 1) (point-at-eol))
              (not (looking-at " ")))
         (evil-insert-state)
         (forward-char 1)
         (insert " ")
         (+evil/normal-mode-paste-fix fn " ")
         (evil-normal-state))
        (t (+evil/normal-mode-paste-fix fn " "))))
#+END_SRC

**** Evil replace with register fixes

I've mapped ~gr~ with ~evil-replace-with-register~ and doom tries to override this.

#+BEGIN_SRC elisp
(use-package! evil-org
  :config
  (map! :map evil-org-mode-map
        :n "gr" nil
        :n "gR" nil))
#+END_SRC
** Hacks
*** Fix smart panes for org

Doom [[file:~/.emacs.d/modules/lang/org/config.el::provide 'smartparens-org)][disables smartparens]] initial load, which breaks it entirely.
For some reason ~(require 'smartparens-org)~ is not enough, so I hack around it by eval the file again.
I also did not know how to find the package file, so I made it so it wont crash when the file doesn't exist.

#+BEGIN_SRC elisp
(after! (org smartparens)
  (->> (f-join doom-local-dir "straight/repos/smartparens/smartparens-org.el")
       (-id-when #'f-exists?)
       (load)))
#+END_SRC
